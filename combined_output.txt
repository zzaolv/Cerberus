

.gitignore

*.iml
.gradle
/local.properties
/.idea/caches
/.idea/libraries
/.idea/modules.xml
/.idea/workspace.xml
/.idea/navEditor.xml
/.idea/assetWizardSettings.xml
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
.kotlin
local.properties
/magisk/Cerberus.zip
/magisk/cerberus-UI.apk
/magisk/cerberusd
daemon_context.txt
local.properties
daemon.py
collo.py
tree.py
project_context.txt
app/release/*
magisk/magisk.zip
magisk/system/bin/cerberusd
magisk/system/Cerberus-UI/Cerberus-UI.apk
hs_err_*.log
replay_*.log
magisk/Cerberus.apk



GEMINI.md

# 角色：首席全栈架构师、Android 内核与Android开发专家顾问

## 核心能力：

- 全栈视野：具备横跨前端、后端、移动端、网络、数据库及云原生架构的深厚技术功底。
- 项目优化：精通性能分析、代码重构、架构升级，致力于提升项目的**可用性、可扩展性与可维护性**。
- 语言大师：熟练掌握 C/C++,JAVA 等多种主流编程语言及其生态，并能迅速适应任何新技术栈。

## 行动准则：

- 深度思考：分析问题时，综合运用批判性、创造性、系统性思维，不仅要解决表面问题，更要洞察其**根本原因**，并提供兼具**前瞻性与实用性**的解决方案。
- 中文沟通：所有提问、解释和交流都必须使用**简体中文**进行。
- 严格按照用户需求解决问题。

README.md

#  Cerberus - 智能后台管理与系统监控工具

![Project Cerberus Banner](https://img.shields.io/badge/Project-Cerberus-blueviolet?style=for-the-badge&logo=android)
![Language](https://img.shields.io/badge/Language-Kotlin%20%26%20C%2B%2B-orange?style=for-the-badge)
![License](https://img.shields.io/badge/License-MIT-green?style=for-the-badge)
![Status](https://img.shields.io/badge/Status-Active%20Development-brightgreen?style=for-the-badge)

**中文** | [English](#) 

---

## 📖 项目简介

**Project Cerberus** 是一款专为 Android 极客和高级用户设计的系统级后台管理与性能监控工具。它不仅是一个应用冻结工具，更是一个深度融入系统、具备智能策略和精细化控制能力的“系统副脑”。

项目采用现代化的技术栈（Jetpack Compose, Kotlin Coroutines, C++17）和创新的混合架构（`Xposed`+`Daemon`），旨在实现极致的性能、功耗与通知体验的平衡。

## ✨ 核心功能

*   **智能应用管理**：
    *   **多策略冻结**：为每个应用设置“豁免”、“智能”、“严格”等不同管理策略。
    *   **优雅冻结技术**：优先使用现代 `Cgroup v2 Freezer` 和 `Binder` 冻结技术，确保应用在不被系统杀死的前提下被彻底“休眠”，并在必要时以 `SIGSTOP` 作为可靠后备。
    *   **ANR 保护**：通过Xposed Hook主动拦截针对已冻结应用的ANR（应用无响应）检测，从根本上防止它们被系统错误地杀死。

*   **事件驱动的智能唤醒**：
    *   **推送唤醒 (FCM/GCM)**：精准拦截FCM/GCM广播，在应用被冻结时，临时将其唤醒一小段时间以接收和处理推送，之后自动重新冻结。
    *   **通知唤醒**：当高优先级通知到达时，智能唤जिए醒对应应用。
    *   **定时心跳**：可配置的定时解冻机制，让依赖后台心跳的应用（如即时通讯软件）也能在严格管理下正常工作。

*   **全方位系统监控面板 (Dashboard)**：
    *   **实时数据流**：通过TCP与后台守护进程通信，实时展示系统总览（CPU、内存、Swap使用率）和各应用运行状态（CPU、内存占用、状态）。
    *   **多核CPU监控**：在统计图表中，清晰展示每个CPU核心的实时使用率。
    *   **电池与环境感知**：监控电池温度、功耗，并感知充电、亮屏、音频播放、定位等状态，为未来的智能策略提供数据基础。

*   **深度日志与统计**：
    *   **事件时间线**：记录所有核心操作（应用冻结/解冻、策略变更、唤醒事件等），帮助用户追溯系统行为。
    *   **Doze 报告**：在设备退出深度休眠后，自动生成一份报告，展示休眠期间哪些应用消耗了CPU资源。
    *   **资源历史图表**：以滚动图表形式可视化展示CPU、内存、电池温度的历史数据。

## 🏛️ 架构解析

Cerberus 采用创新的三体架构，各部分职责分明、高效协作：

1.  **前端UI (Android App - `app`模块)**
    *   **技术栈**: 100% Kotlin, Jetpack Compose, Material 3, ViewModel, Coroutines Flow, Coil。
    *   **职责**: 提供用户交互界面，展示来自`Daemon`的数据，并将用户配置发送给`Daemon`。UI层经过精心优化，通过自定义Coil Fetcher实现应用图标的按需加载和内存优化。

2.  **守护进程 (Native Daemon - `daemon`模块)**
    *   **技术栈**: C++17, aarch64/armv7a, TCP Server, SQLiteCpp, Nlohmann JSON。
    *   **职责**: 项目的“大脑”。以Root权限在后台运行，负责：
        *   执行真正的冻结/解冻操作 (`ActionExecutor`)。
        *   管理应用策略和配置，并持久化到SQLite数据库 (`DatabaseManager`)。
        *   监控系统核心指标 (`SystemMonitor`)。
        *   维护所有应用的核心状态机 (`StateManager`)。
        *   作为数据中心，通过TCP服务与UI和Probe通信。

3.  **系统探针 (Xposed Module - `lsp`模块)**
    *   **技术栈**: Xposed (LSPosed/EdXposed), Kotlin。
    *   **职责**: 项目的“神经触手”。注入到`system_server`进程中，负责：
        *   Hook系统关键服务（AMS, NMS, PowerManager等）。
        *   拦截并处理FCM/GCM广播、通知、ANR流程、Wakelock等。
        *   将捕获到的系统事件实时发送给`Daemon`进行决策。
        *   从`Daemon`接收冻结列表，为ANR保护等功能提供依据。

![Architecture Diagram](链接)

### 通信机制

*   **UI <-> Daemon**: 通过 `127.0.0.1:28900` 的TCP套接字进行双向JSON RPC通信。UI发送配置命令和查询请求，Daemon实时推送Dashboard、日志和统计数据流。
*   **Probe -> Daemon**: 通过短连接的TCP套接字，将捕获到的系统事件（如“应用唤醒请求”）单向发送给Daemon。同时，在Probe启动时会与Daemon建立连接以获取初始配置。

## 🚀 安装与构建

### 环境要求

*   Android 8.0+
*   已解锁并获取Root权限的设备
*   已安装 Magisk
*   已安装 LSPosed (或其他支持Xposed API 82的框架)

### 构建步骤

1.  **克隆仓库**:
    ```bash
    git clone https://github.com/your-repo/Project-Cerberus.git
    cd Project-Cerberus
    ```

2.  **构建前端 (APK)**:
    *   使用 Android Studio 打开项目。
    *   项目将自动通过Gradle Sync同步依赖。
    *   点击 `Build` -> `Build Bundle(s) / APK(s)` -> `Build APK(s)`。
    *   生成的APK位于 `app/build/outputs/apk/release/app-release.apk`。

3.  **构建后端 (Daemon)**:
    *   确保已安装Android NDK。
    *   在项目根目录执行以下命令（请根据您的NDK路径和目标架构进行调整）：
    ```bash
    cd daemon
    mkdir build && cd build
    
    # 为 arm64-v8a 构建
    cmake .. \
      -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \
      -DANDROID_ABI=arm64-v8a \
      -DANDROID_PLATFORM=android-30 \
      -DCMAKE_BUILD_TYPE=Release
      
    make cerberusd
    ```
    *   生成的可执行文件为 `daemon/build/cerberusd`。

### 部署与使用

1.  **安装APK**：将构建好的 `app-release.apk` 安装到您的设备上。
2.  **激活Xposed模块**：在LSPosed管理器中，激活 **CRFzit** 模块，并确保作用域勾选了 **系统框架 (`android`)**。重启设备。
3.  **部署Daemon**：
    *   将 `cerberusd` 可执行文件推送到设备的某个可执行路径，例如 `/data/adb/cerberus/`。
    *   赋予其可执行权限：`chmod +x /data/adb/cerberus/cerberusd`。
4.  **运行Daemon**：
    *   为了让Daemon在后台持续运行，建议通过Magisk启动脚本或rc脚本来启动它。一个简单的启动脚本 `post-fs-data.sh` 可能如下：
    ```sh
    #!/system/bin/sh
    MODDIR=${0%/*}
    
    # 确保目录存在
    mkdir -p /data/adb/cerberus
    cp $MODDIR/cerberusd /data/adb/cerberus/cerberusd
    chmod 755 /data/adb/cerberus/cerberusd
    
    # 启动守护进程
    /data/adb/cerberus/cerberusd &
    ```
5.  **开始使用**：打开CRFzit应用，如果一切正常，您应该能看到“主页”上实时跳动的数据。

## 致谢

*   **Rikka** & **LSPosed** 团队，为现代Android提供了强大的Hook框架。
*   **topjohnwu**，Magisk的创造者。
*   所有为Android开源社区做出贡献的开发者。

---
**免责声明**: 本项目涉及系统底层修改，请确保您了解相关风险。作者不对因使用本项目造成的任何数据丢失或设备损坏负责。

build.gradle.kts

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    // 正确引用在 toml 中定义的 compose 插件
    alias(libs.plugins.jetbrains.compose) apply false
}

daemon_context.txt

daemon/CMakeLists.txt
```
# daemon/CMakeLists.txt
#
# Project Cerberus - Daemon Build Script
# Verified against the provided third_party directory structure.
#
cmake_minimum_required(VERSION 3.20)
project(cerberusd CXX C)

# --- 1. 定义第三方库的根目录 ---
set(THIRDPARTY_DIR ${CMAKE_CURRENT_SOURCE_DIR}/third_party)

# --- 2. 构建 sqlite3 库 ---
# 源文件路径: third_party/sqlite3/sqlite3.c
add_library(sqlite3_lib STATIC
    ${THIRDPARTY_DIR}/sqlite3/sqlite3.c
)
# 头文件目录: third_party/sqlite3/ (包含 sqlite3.h)
target_include_directories(sqlite3_lib PUBLIC
    ${THIRDPARTY_DIR}/sqlite3
)

# --- 3. 构建 SQLiteCpp 库 ---
# 源文件路径: third_party/sqlitecpp/src/*.cpp
add_library(sqlitecpp_lib STATIC
    ${THIRDPARTY_DIR}/sqlitecpp/src/Backup.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Column.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Database.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Exception.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Savepoint.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Statement.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Transaction.cpp
)
# 头文件目录: third_party/sqlitecpp/include/
# 这样设置后，代码中可以使用 #include "SQLiteCpp/Database.h" 的形式
target_include_directories(sqlitecpp_lib PUBLIC
    ${THIRDPARTY_DIR}/sqlitecpp/include
)
# 声明 SQLiteCpp 依赖于我们刚刚定义的 sqlite3_lib
target_link_libraries(sqlitecpp_lib PUBLIC sqlite3_lib)

# --- 4. 定义最终的可执行文件 'cerberusd' ---
add_executable(cerberusd
    cpp/main.cpp
    cpp/uds_server.cpp
    cpp/system_monitor.cpp
    cpp/database_manager.cpp
    cpp/state_manager.cpp
    cpp/action_executor.cpp
   # cpp/process_monitor.cpp
    cpp/logger.cpp
    cpp/time_series_database.cpp   
)

# --- 5. 为 'cerberusd' 添加头文件搜索路径 ---
# nlohmann_json 是 header-only 库，只需提供其 include 目录
# 目录路径: third_party/nlohmann_json/include/
# 这样设置后，代码中可以使用 #include "nlohmann/json.hpp" 的形式
target_include_directories(cerberusd PRIVATE
    ${THIRDPARTY_DIR}/nlohmann_json/include
)

# --- 6. 链接 'cerberusd' 可执行文件 ---
# 链接我们自己构建的库和 Android 系统提供的日志库
target_link_libraries(cerberusd
    PRIVATE
    sqlitecpp_lib   # 链接 SQLiteCpp (它会自动链接 sqlite3)
    log             # 链接 Android NDK 的 log 库 (用于 __android_log_print)
)

# --- 7. 设置 C++ 标准和编译选项 ---
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
# 为 Release 构建开启优化
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2 -DNDEBUG")
# 消除 GNU 扩展相关的警告 (例如在 process_monitor.cpp 中可能出现)
add_compile_options(-Wno-gnu-empty-struct)
```

daemon/cpp/action_executor.cpp
```
// daemon/cpp/action_executor.cpp
#include "action_executor.h"
#include <android/log.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <fstream>
#include <filesystem>
#include <unistd.h>
#include <cerrno>
#include <cstring>
#include <sstream>
#include <csignal>
#include <algorithm>
#include <fcntl.h>
#include <vector>

#define LOG_TAG "cerberusd_action_v16_resilience" // 版本号更新
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;

ActionExecutor::ActionExecutor() {
    initialize_binder();
    initialize_cgroup();
}

ActionExecutor::~ActionExecutor() {
    cleanup_binder();
}

int ActionExecutor::freeze(const AppInstanceKey& key, const std::vector<int>& pids) {
    if (pids.empty()) return 0;

    int binder_result = handle_binder_freeze(pids, true);

    if (binder_result == -1) {
        LOGE("Binder freeze for %s failed critically. Rolling back...", key.first.c_str());
        handle_binder_freeze(pids, false);
        return -1;
    }

    if (binder_result == 2) {
        LOGW("Binder freeze for %s was resisted (EAGAIN). Escalating to SIGSTOP as fallback.", key.first.c_str());
        freeze_sigstop(pids);
        return 1;
    }

    LOGI("Binder freeze phase for %s completed. Proceeding with physical freeze.", key.first.c_str());
    bool cgroup_ok = freeze_cgroup(key, pids);

    if (cgroup_ok) {
        bool verified = false;
        if (!pids.empty()) {
            usleep(50000);
            verified = is_pid_frozen_by_cgroup(pids[0], key);
        }

        if(verified) {
             LOGI("Cgroup freeze for %s succeeded and verified.", key.first.c_str());
             return 0;
        } else {
             LOGW("Cgroup freeze for %s verification failed! Escalating to SIGSTOP.", key.first.c_str());
             freeze_sigstop(pids);
             return 1;
        }
    } else {
        LOGW("Cgroup freeze failed for %s, falling back to SIGSTOP.", key.first.c_str());
        freeze_sigstop(pids);
        return 1;
    }
}


bool ActionExecutor::unfreeze(const AppInstanceKey& key, const std::vector<int>& pids) {
    unfreeze_cgroup(key);
    unfreeze_sigstop(pids);
    handle_binder_freeze(pids, false);
    LOGI("Unfroze instance '%s' (user %d).", key.first.c_str(), key.second);
    return true;
}

int ActionExecutor::handle_binder_freeze(const std::vector<int>& pids, bool freeze) {
    if (binder_state_.fd < 0) return 0;

    const int BINDER_FREEZE_MAX_ATTEMPTS = 5;
    const useconds_t BINDER_FREEZE_RETRY_WAIT_US = 70000;

    bool has_soft_failure = false;
    binder_freeze_info info{ .pid = 0, .enable = (uint32_t)(freeze ? 1 : 0), .timeout_ms = 100 };

    for (int pid : pids) {
        info.pid = static_cast<__u32>(pid);
        bool op_success = false;

        // 使用上面定义的常量来控制循环
        for (int attempt = 0; attempt < BINDER_FREEZE_MAX_ATTEMPTS; ++attempt) {
            if (ioctl(binder_state_.fd, BINDER_FREEZE, &info) == 0) {
                op_success = true;
                break;
            }

            if (errno == EAGAIN) {
                if (attempt == BINDER_FREEZE_MAX_ATTEMPTS - 1) {
                    LOGW("Binder op for pid %d still has pending transactions (EAGAIN) after %d attempts. Marking as soft failure.", pid, BINDER_FREEZE_MAX_ATTEMPTS);
                    has_soft_failure = true;
                } else {
                    LOGD("Binder op for pid %d got EAGAIN, retrying in %d ms... (Attempt %d/%d)", pid, BINDER_FREEZE_RETRY_WAIT_US / 1000, attempt + 1, BINDER_FREEZE_MAX_ATTEMPTS);
                }
                usleep(BINDER_FREEZE_RETRY_WAIT_US);
                continue;
            }
            else if (freeze && (errno == EINVAL || errno == EPERM)) {
                LOGW("Cannot freeze pid %d (error: %s), likely a privileged process. Skipping this PID.", pid, strerror(errno));
                op_success = true;
                break;
            }
            else {
                LOGE("Binder op for pid %d failed with unrecoverable error: %s", pid, strerror(errno));
                return -1;
            }
        }

        if (!op_success && !has_soft_failure) {
            return -1;
        }
    }

    return has_soft_failure ? 2 : 0;
}

bool ActionExecutor::is_pid_frozen_by_cgroup(int pid, const AppInstanceKey& key) {
    std::string freeze_path = get_instance_cgroup_path(key) + "/cgroup.freeze";

    std::ifstream freeze_file(freeze_path);
    if (freeze_file.is_open()) {
        char state;
        freeze_file >> state;
        if (state == '1') {
            return true;
        }
    }

    return false;
}

bool ActionExecutor::initialize_binder() {
    binder_state_.fd = open("/dev/binder", O_RDWR | O_CLOEXEC);
    if (binder_state_.fd < 0) {
        LOGE("Failed to open /dev/binder: %s", strerror(errno));
        return false;
    }

    binder_version version;
    if (ioctl(binder_state_.fd, BINDER_VERSION, &version) < 0 || version.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION) {
        LOGE("Binder version mismatch or ioctl failed. Required: %d", BINDER_CURRENT_PROTOCOL_VERSION);
        close(binder_state_.fd);
        binder_state_.fd = -1;
        return false;
    }

    binder_state_.mapped = mmap(NULL, binder_state_.mapSize, PROT_READ, MAP_PRIVATE, binder_state_.fd, 0);
    if (binder_state_.mapped == MAP_FAILED) {
        LOGE("Binder mmap failed: %s", strerror(errno));
        close(binder_state_.fd);
        binder_state_.fd = -1;
        return false;
    }

    struct binder_frozen_status_info info = { .pid = (uint32_t)getpid() };
    if (ioctl(binder_state_.fd, BINDER_GET_FROZEN_INFO, &info) < 0) {
        LOGW("Kernel does not support BINDER_FREEZE feature (ioctl failed: %s). Binder freezing disabled.", strerror(errno));
        cleanup_binder();
        return false;
    }

    LOGI("Binder driver initialized successfully and BINDER_FREEZE feature is supported.");
    return true;
}

void ActionExecutor::cleanup_binder() {
    if (binder_state_.mapped && binder_state_.mapped != MAP_FAILED) {
        munmap(binder_state_.mapped, binder_state_.mapSize);
        binder_state_.mapped = nullptr;
    }
    if (binder_state_.fd >= 0) {
        close(binder_state_.fd);
        binder_state_.fd = -1;
    }
}

bool ActionExecutor::initialize_cgroup() {
    if (fs::exists("/sys/fs/cgroup/cgroup.controllers")) {
        cgroup_version_ = CgroupVersion::V2;
        cgroup_root_path_ = "/sys/fs/cgroup/";
        LOGI("Detected cgroup v2. Root: %s", cgroup_root_path_.c_str());
        if(!write_to_file(cgroup_root_path_ + "cgroup.subtree_control", "+freezer")) {
             LOGW("Failed to enable freezer controller in root cgroup. It might be already enabled.");
        }
        return true;
    }
    LOGW("cgroup v2 not detected. Cgroup freezer disabled.");
    cgroup_version_ = CgroupVersion::UNKNOWN;
    return false;
}

std::string ActionExecutor::get_instance_cgroup_path(const AppInstanceKey& key) const {
    std::string sanitized_package_name = key.first;
    std::replace(sanitized_package_name.begin(), sanitized_package_name.end(), '.', '_');
    return cgroup_root_path_ + "cerberus_" + sanitized_package_name + "_" + std::to_string(key.second);
}


bool ActionExecutor::freeze_cgroup(const AppInstanceKey& key, const std::vector<int>& pids) {
    if (cgroup_version_ != CgroupVersion::V2) return false;
    std::string instance_path = get_instance_cgroup_path(key);

    if (fs::exists(instance_path)) {
        LOGW("Residual cgroup found for %s. Attempting cleanup before freeze.", key.first.c_str());
        unfreeze_cgroup(key);
    }

    if (!create_instance_cgroup(instance_path)) {
        LOGE("Failed to create cgroup '%s' even after cleanup attempt.", instance_path.c_str());
        return false;
    }

    if (!move_pids_to_cgroup(pids, instance_path)) {
        LOGE("Failed to move pids for '%s' to its cgroup.", key.first.c_str());
        return false;
    }
    if (!write_to_file(instance_path + "/cgroup.freeze", "1")) {
        LOGE("Failed to write '1' to cgroup.freeze for '%s'.", key.first.c_str());
        return false;
    }
    return true;
}

bool ActionExecutor::unfreeze_cgroup(const AppInstanceKey& key) {
    if (cgroup_version_ != CgroupVersion::V2) return true;
    std::string instance_path = get_instance_cgroup_path(key);
    if (!fs::exists(instance_path)) return true;
    
    write_to_file(instance_path + "/cgroup.freeze", "0");
    
    std::string procs_file = instance_path + "/cgroup.procs";
    std::vector<int> pids_to_move;
    std::ifstream ifs(procs_file);
    int pid;
    while(ifs >> pid) { pids_to_move.push_back(pid); }
    if (!pids_to_move.empty()) { 
        move_pids_to_default_cgroup(pids_to_move); 
    }
    
    usleep(50000); 

    remove_instance_cgroup(instance_path);
    return true;
}

void ActionExecutor::freeze_sigstop(const std::vector<int>& pids) {
    for (int pid : pids) {
        if (kill(pid, SIGSTOP) < 0) {
            LOGW("Failed to send SIGSTOP to pid %d: %s", pid, strerror(errno));
        }
    }
}

void ActionExecutor::unfreeze_sigstop(const std::vector<int>& pids) {
    for (int pid : pids) {
        if (kill(pid, SIGCONT) < 0) { }
    }
}

bool ActionExecutor::create_instance_cgroup(const std::string& path) {
    if (fs::exists(path)) return true;
    try {
        fs::create_directory(path);
        return true;
    } catch (const fs::filesystem_error& e) {
        LOGE("Failed to create cgroup '%s': %s", path.c_str(), e.what());
        return false;
    }
}

bool ActionExecutor::remove_instance_cgroup(const std::string& path) {
    if (!fs::exists(path)) return true;
    if (rmdir(path.c_str()) != 0) {
        LOGW("Cannot remove cgroup '%s': %s. It might not be empty yet.", path.c_str(), strerror(errno));
        return false;
    }
    LOGI("Successfully removed cgroup '%s'", path.c_str());
    return true;
}

bool ActionExecutor::move_pids_to_cgroup(const std::vector<int>& pids, const std::string& cgroup_path) {
    std::string procs_file = cgroup_path + "/cgroup.procs";
    std::ofstream ofs(procs_file, std::ios_base::app);
    if (!ofs.is_open()) {
        LOGE("Failed to open '%s' to move pids: %s", procs_file.c_str(), strerror(errno));
        return false;
    }
    for (int pid : pids) {
        ofs << pid << std::endl;
        if (ofs.fail()) {
            LOGE("Error writing pid %d to %s", pid, procs_file.c_str());
            return false;
        }
    }
    return true;
}

bool ActionExecutor::move_pids_to_default_cgroup(const std::vector<int>& pids) {
    return move_pids_to_cgroup(pids, cgroup_root_path_);
}

bool ActionExecutor::write_to_file(const std::string& path, const std::string& value) {
    std::ofstream ofs(path);
    if (!ofs.is_open()) {
        if (path.find("subtree_control") == std::string::npos) {
            LOGE("Failed to open file '%s' for writing: %s", path.c_str(), strerror(errno));
        }
        return false;
    }
    ofs << value;
    if (ofs.fail()) {
        LOGE("Failed to write '%s' to '%s': %s", value.c_str(), path.c_str(), strerror(errno));
        return false;
    }
    return true;
}
```

daemon/cpp/action_executor.h
```
// daemon/cpp/action_executor.h
#ifndef CERBERUS_ACTION_EXECUTOR_H
#define CERBERUS_ACTION_EXECUTOR_H

#include <string>
#include <vector>
#include <utility> 
#include <linux/android/binder.h>

using AppInstanceKey = std::pair<std::string, int>;

class ActionExecutor {
public:
    ActionExecutor();
    ~ActionExecutor();

    /**
     * @brief 尝试冻结一个应用实例，采用带物理验证的策略。
     * @return 0: Cgroup冻结成功 | 1: SIGSTOP后备方案成功 | 2: 软失败(可重试) | -1: 彻底失败
     */
    int freeze(const AppInstanceKey& key, const std::vector<int>& pids);
    
    bool unfreeze(const AppInstanceKey& key, const std::vector<int>& pids);

private:
    bool initialize_binder();
    void cleanup_binder();
    
    /**
     * @brief 冻结/解冻Binder
     * @return 0: 成功 | 2: 软失败(EAGAIN) | -1: 致命失败
     */
    int handle_binder_freeze(const std::vector<int>& pids, bool freeze);
    
    /**
     * @brief [核心] 通过检查我们自己创建的cgroup.freeze文件来验证进程是否被物理冻结。
     * @return true 如果进程被cgroup冻结，否则 false。
     */
    bool is_pid_frozen_by_cgroup(int pid, const AppInstanceKey& key);

    enum class CgroupVersion { V2, UNKNOWN };
    bool initialize_cgroup();
    std::string get_instance_cgroup_path(const AppInstanceKey& key) const;
    bool freeze_cgroup(const AppInstanceKey& key, const std::vector<int>& pids);
    bool unfreeze_cgroup(const AppInstanceKey& key);

    void freeze_sigstop(const std::vector<int>& pids);
    void unfreeze_sigstop(const std::vector<int>& pids);

    bool create_instance_cgroup(const std::string& path);
    bool remove_instance_cgroup(const std::string& path);
    bool move_pids_to_cgroup(const std::vector<int>& pids, const std::string& cgroup_path);
    bool move_pids_to_default_cgroup(const std::vector<int>& pids);
    bool write_to_file(const std::string& path, const std::string& value);

    CgroupVersion cgroup_version_ = CgroupVersion::UNKNOWN;
    std::string cgroup_root_path_;
    
    struct BinderState {
        int fd = -1;
        void* mapped = nullptr;
        size_t mapSize = 128 * 1024ULL;
    } binder_state_;
};

#endif //CERBERUS_ACTION_EXECUTOR_H
```

daemon/cpp/database_manager.cpp
```
// daemon/cpp/database_manager.cpp
#include "database_manager.h"
#include <android/log.h>
#include <filesystem>

#define LOG_TAG "cerberusd_db_v9"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

DatabaseManager::DatabaseManager(const std::string& db_path)
    : db_(db_path, SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE) {
    LOGI("Database opened at %s", db_path.c_str());
    initialize_database();
}

void DatabaseManager::initialize_database() {
    try {
        if (!db_.tableExists("app_policies_v3")) {
            LOGI("Table 'app_policies_v3' does not exist. Creating it.");
            db_.exec(R"(
                CREATE TABLE app_policies_v3 (
                    package_name TEXT NOT NULL,
                    user_id INTEGER NOT NULL,
                    policy INTEGER NOT NULL DEFAULT 0,
                    PRIMARY KEY (package_name, user_id)
                )
            )");
        }

        // [核心修改] 更新 master_config 表结构和默认值
        if (!db_.tableExists("master_config_v2")) {
            LOGI("Table 'master_config_v2' does not exist. Creating it.");
            if (db_.tableExists("master_config_v1")) {
                 LOGI("Old 'master_config_v1' table found. Dropping it.");
                 db_.exec("DROP TABLE master_config_v1;");
            }
            db_.exec(R"(
                CREATE TABLE master_config_v2 (
                    key TEXT PRIMARY KEY,
                    value INTEGER NOT NULL
                )
            )");
            db_.exec("INSERT OR IGNORE INTO master_config_v2 (key, value) VALUES ('standard_timeout_sec', 90)");
            db_.exec("INSERT OR IGNORE INTO master_config_v2 (key, value) VALUES ('is_timed_unfreeze_enabled', 1)");
            db_.exec("INSERT OR IGNORE INTO master_config_v2 (key, value) VALUES ('timed_unfreeze_interval_sec', 1800)");
        }
    } catch (const std::exception& e) {
        LOGE("Database initialization failed: %s", e.what());
    }
}

std::optional<MasterConfig> DatabaseManager::get_master_config() {
    try {
        MasterConfig config;
        SQLite::Statement query(db_, "SELECT key, value FROM master_config_v2");
        while (query.executeStep()) {
            std::string key = query.getColumn(0).getString();
            int value = query.getColumn(1).getInt();
            if (key == "standard_timeout_sec") {
                config.standard_timeout_sec = value;
            } else if (key == "is_timed_unfreeze_enabled") {
                config.is_timed_unfreeze_enabled = (value != 0);
            } else if (key == "timed_unfreeze_interval_sec") {
                config.timed_unfreeze_interval_sec = value;
            }
        }
        return config;
    } catch (const std::exception& e) {
        LOGE("Failed to get master config: %s", e.what());
    }
    return std::nullopt;
}

bool DatabaseManager::set_master_config(const MasterConfig& config) {
    try {
        SQLite::Transaction transaction(db_);
        
        db_.exec("INSERT OR REPLACE INTO master_config_v2 (key, value) VALUES ('standard_timeout_sec', " + std::to_string(config.standard_timeout_sec) + ")");
        db_.exec("INSERT OR REPLACE INTO master_config_v2 (key, value) VALUES ('is_timed_unfreeze_enabled', " + std::to_string(config.is_timed_unfreeze_enabled ? 1 : 0) + ")");
        db_.exec("INSERT OR REPLACE INTO master_config_v2 (key, value) VALUES ('timed_unfreeze_interval_sec', " + std::to_string(config.timed_unfreeze_interval_sec) + ")");

        transaction.commit();
        return true;
    } catch (const std::exception& e) {
        LOGE("Failed to set master config: %s", e.what());
        return false;
    }
}

std::optional<AppConfig> DatabaseManager::get_app_config(const std::string& package_name, int user_id) {
    try {
        SQLite::Statement query(db_, "SELECT policy FROM app_policies_v3 WHERE package_name = ? AND user_id = ?");
        query.bind(1, package_name);
        query.bind(2, user_id);

        if (query.executeStep()) {
            AppConfig config;
            config.package_name = package_name;
            config.user_id = user_id;
            config.policy = static_cast<AppPolicy>(query.getColumn(0).getInt());
            return config;
        }
    } catch (const std::exception& e) {
        LOGE("Failed to get app config for '%s' (user %d): %s", package_name.c_str(), user_id, e.what());
    }
    return std::nullopt;
}

bool DatabaseManager::set_app_config(const AppConfig& config) {
    try {
        SQLite::Statement query(db_, R"(
            INSERT INTO app_policies_v3 (package_name, user_id, policy)
            VALUES (?, ?, ?)
            ON CONFLICT(package_name, user_id) DO UPDATE SET
                policy = excluded.policy
        )");
        query.bind(1, config.package_name);
        query.bind(2, config.user_id);
        query.bind(3, static_cast<int>(config.policy));
        
        return query.exec() > 0;
    } catch (const std::exception& e) {
        LOGE("Failed to set app config for '%s' (user %d): %s", config.package_name.c_str(), config.user_id, e.what());
        return false;
    }
}

bool DatabaseManager::clear_all_policies() {
    try {
        db_.exec("DELETE FROM app_policies_v3");
        return true;
    } catch (const std::exception& e) {
        LOGE("Failed to clear all policies: %s", e.what());
        return false;
    }
}

std::vector<AppConfig> DatabaseManager::get_all_app_configs() {
    std::vector<AppConfig> configs;
    try {
        SQLite::Statement query(db_, "SELECT package_name, user_id, policy FROM app_policies_v3");
        while (query.executeStep()) {
            AppConfig config;
            config.package_name = query.getColumn(0).getString();
            config.user_id = query.getColumn(1).getInt();
            config.policy = static_cast<AppPolicy>(query.getColumn(2).getInt());
            configs.push_back(config);
        }
    } catch (const std::exception& e) {
        LOGE("Failed to get all app configs: %s", e.what());
    }
    return configs;
}
```

daemon/cpp/database_manager.h
```
// daemon/cpp/database_manager.h
#ifndef CERBERUS_DATABASE_MANAGER_H
#define CERBERUS_DATABASE_MANAGER_H

#include <string>
#include <vector>
#include <optional>
#include <SQLiteCpp/Database.h>
#include <SQLiteCpp/Statement.h>
#include <SQLiteCpp/Transaction.h>

enum class AppPolicy {
    EXEMPTED = 0,
    IMPORTANT = 1,
    STANDARD = 2,
    STRICT = 3
};

struct AppConfig {
    std::string package_name;
    int user_id = 0; 
    AppPolicy policy = AppPolicy::STANDARD;
};

// [核心新增] 为 MasterConfig 增加定时解冻相关字段
struct MasterConfig {
    int standard_timeout_sec = 90;
    bool is_timed_unfreeze_enabled = true;
    int timed_unfreeze_interval_sec = 1800; // 30分钟
};

class DatabaseManager {
public:
    explicit DatabaseManager(const std::string& db_path);

    std::optional<MasterConfig> get_master_config();
    bool set_master_config(const MasterConfig& config);
    
    std::optional<AppConfig> get_app_config(const std::string& package_name, int user_id);
    bool set_app_config(const AppConfig& config);
    bool clear_all_policies();
    std::vector<AppConfig> get_all_app_configs();

private:
    void initialize_database();
    SQLite::Database db_;
};

#endif //CERBERUS_DATABASE_MANAGER_H
```

daemon/cpp/logger.cpp
```
// daemon/cpp/logger.cpp
#include "logger.h"
#include <fstream>
#include <filesystem>
#include <chrono>
#include <iomanip>
#include <ctime>
#include <algorithm>
#include <android/log.h>
#include <vector>
#include <regex>

#define LOG_TAG "cerberusd_logger_v7_polling" // 版本号更新
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;

const int MAX_LOG_LINES_PER_FILE = 200;
const int MAX_LOG_FILES_PER_DAY = 3;
const int MAX_LOG_RETENTION_DAYS = 3;

// --- LogEntry ---
json LogEntry::to_json() const {
    json j = {
        {"timestamp", timestamp_ms},
        {"level", static_cast<int>(level)},
        {"category", category},
        {"message", message},
    };
    if (!package_name.empty()) j["package_name"] = package_name;
    if (user_id != -1) j["user_id"] = user_id;
    return j;
}

std::shared_ptr<Logger> Logger::instance_ = nullptr;
std::mutex Logger::instance_mutex_;

std::shared_ptr<Logger> Logger::get_instance(const std::string& log_dir_path) {
    std::lock_guard<std::mutex> lock(instance_mutex_);
    if (!instance_) {
        struct make_shared_enabler : public Logger {
            make_shared_enabler(const std::string& path) : Logger(path) {}
        };
        instance_ = std::make_shared<make_shared_enabler>(log_dir_path);
    }
    return instance_;
}
Logger::Logger(const std::string& log_dir_path)
    : log_dir_path_(log_dir_path), is_running_(true) {
    if (!fs::exists(log_dir_path_)) {
        fs::create_directories(log_dir_path_);
    }
    manage_log_files(); // 初始化时就管理一下
    writer_thread_ = std::thread(&Logger::writer_thread_func, this);
}
Logger::~Logger() {
    stop();
}
void Logger::stop() {
    if (!is_running_.exchange(false)) return;
    cv_.notify_one();
    if (writer_thread_.joinable()) {
        writer_thread_.join();
    }
}
void Logger::log(LogLevel level, const std::string& category, const std::string& message, const std::string& package_name, int user_id) {
    long long timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()
    ).count();
    LogEntry entry{timestamp, level, category, message, package_name, user_id};

    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        log_queue_.push_back(entry);
    }
    cv_.notify_one();
}
void Logger::log_batch(const std::vector<LogEntry>& entries) {
    if (entries.empty()) return;
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        for(const auto& entry : entries) {
            log_queue_.push_back(entry);
        }
    }
    cv_.notify_one();
}
std::vector<std::string> Logger::get_log_files() const {
    std::vector<std::string> files;
    try {
        for (const auto& entry : fs::directory_iterator(log_dir_path_)) {
            if (entry.is_regular_file()) {
                std::string filename = entry.path().filename().string();
                if (filename.rfind("fct_", 0) == 0 && filename.rfind(".log") == filename.length() - 4) {
                    files.push_back(filename);
                }
            }
        }
    } catch (const fs::filesystem_error& e) {
        LOGE("Error listing log files: %s", e.what());
    }
    std::sort(files.rbegin(), files.rend());
    return files;
}

// [修改] 实现 since 和 before 的逻辑
std::vector<LogEntry> Logger::get_logs_from_file(const std::string& filename, int limit,
                                                 std::optional<long long> before_timestamp_ms,
                                                 std::optional<long long> since_timestamp_ms) const {
    std::vector<LogEntry> results;
    fs::path file_path = fs::path(log_dir_path_) / filename;

    if (!fs::exists(file_path)) return results;

    std::ifstream log_file(file_path);
    if (!log_file.is_open()) return results;

    // 为了 polling (since)，我们需要正向读取
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(log_file, line)) {
        lines.push_back(line);
    }

    // 从后往前遍历，这样可以很容易地应用 limit 和 before
    for (auto it = lines.rbegin(); it != lines.rend(); ++it) {
        if (limit > 0 && results.size() >= limit && !since_timestamp_ms) break;

        try {
            json j = json::parse(*it);
            long long timestamp = j.value("ts", 0LL);

            if (before_timestamp_ms.has_value() && timestamp >= before_timestamp_ms.value()) {
                continue;
            }
            
            if (since_timestamp_ms.has_value() && timestamp <= since_timestamp_ms.value()) {
                // 如果是 polling 请求，读到比 since 旧的就停止
                if (!before_timestamp_ms.has_value()) break; 
                else continue;
            }
            
            LogEntry entry{
                .timestamp_ms = timestamp,
                .level = static_cast<LogLevel>(j.value("lvl", 0)),
                .category = j.value("cat", ""),
                .message = j.value("msg", ""),
                .package_name = j.value("pkg", ""),
                .user_id = j.value("uid", -1)
            };
            results.push_back(entry);
        } catch (...) { /* ignore */ }
    }

    // 如果是 polling，结果需要是时间升序的
    if (since_timestamp_ms.has_value()) {
        std::reverse(results.begin(), results.end());
    }
    
    // Polling 也可能从内存队列获取
    if (since_timestamp_ms) {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        for(const auto& entry : log_queue_) {
            if (entry.timestamp_ms > since_timestamp_ms.value()) {
                results.push_back(entry);
            }
        }
        // 再次排序确保内存和文件的日志顺序正确
        std::sort(results.begin(), results.end(), [](const auto& a, const auto& b) {
            return a.timestamp_ms < b.timestamp_ms;
        });
    }

    return results;
}

void Logger::manage_log_files() {
    auto files = get_log_files(); // 已经是降序排序
    std::map<std::string, std::vector<std::string>> files_by_day;
    
    // 分组
    for (const auto& f : files) {
        try {
            std::string date_str = f.substr(4, 10);
            files_by_day[date_str].push_back(f);
        } catch(...) {}
    }
    
    // 清理每天多余的文件
    for (auto& [day, day_files] : files_by_day) {
        // 已经是降序的了，所以 0, 1, 2 是最新的
        if (day_files.size() > MAX_LOG_FILES_PER_DAY) {
            for (size_t i = MAX_LOG_FILES_PER_DAY; i < day_files.size(); ++i) {
                fs::remove(fs::path(log_dir_path_) / day_files[i]);
                 LOGD("Cleaned up excess log file: %s", day_files[i].c_str());
            }
        }
    }
    
    // 清理过期的天数
    if (files_by_day.size() > MAX_LOG_RETENTION_DAYS) {
        auto it = files_by_day.begin();
        std::advance(it, files_by_day.size() - MAX_LOG_RETENTION_DAYS);
        for(auto temp_it = files_by_day.begin(); temp_it != it; ++temp_it) {
            for (const auto& f : temp_it->second) {
                fs::remove(fs::path(log_dir_path_) / f);
                 LOGD("Cleaned up outdated log file: %s", f.c_str());
            }
        }
    }

    // 更新当前日志文件
    auto latest_files = get_log_files();
    if (latest_files.empty()) {
        current_log_file_path_ = "";
        current_log_line_count_ = 0;
    } else {
        current_log_file_path_ = fs::path(log_dir_path_) / latest_files[0];
        std::ifstream ifs(current_log_file_path_);
        current_log_line_count_ = std::count(std::istreambuf_iterator<char>(ifs), std::istreambuf_iterator<char>(), '\n');
    }
}
void Logger::rotate_log_file_if_needed(size_t new_entries_count) {
    time_t now = time(nullptr);
    tm ltm = {};
    localtime_r(&now, &ltm);
    char date_buf[16];
    strftime(date_buf, sizeof(date_buf), "%Y-%m-%d", &ltm);
    std::string current_date_str(date_buf);

    bool needs_new_file = false;
    if (current_log_file_path_.empty() || 
        current_log_file_path_.find(current_date_str) == std::string::npos ||
        (current_log_line_count_ + new_entries_count > MAX_LOG_LINES_PER_FILE)) {
        needs_new_file = true;
    }

    if (needs_new_file) {
        int next_index = 1;
        auto files = get_log_files();
        if (!files.empty() && files[0].find(current_date_str) != std::string::npos) {
            try {
                // fct_2024-01-01_1.log -> 1
                std::string last_file = files[0];
                size_t underscore_pos = last_file.rfind('_');
                size_t dot_pos = last_file.rfind('.');
                int last_index = std::stoi(last_file.substr(underscore_pos + 1, dot_pos - underscore_pos - 1));
                next_index = last_index + 1;
            } catch (...) {}
        }
        std::string new_filename = "fct_" + current_date_str + "_" + std::to_string(next_index) + ".log";
        current_log_file_path_ = fs::path(log_dir_path_) / new_filename;
        current_log_line_count_ = 0;
        cleanup_old_files();
    }
}
void Logger::cleanup_old_files() {}
void Logger::writer_thread_func() {
    while (is_running_) {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        cv_.wait(lock, [this]{ return !log_queue_.empty() || !is_running_; });

        if (!is_running_ && log_queue_.empty()) break;

        std::deque<LogEntry> temp_queue;
        temp_queue.swap(log_queue_);
        lock.unlock();

        if (temp_queue.empty()) continue;
        
        rotate_log_file_if_needed(temp_queue.size());

        std::ofstream log_file(current_log_file_path_, std::ios_base::app);
        if (!log_file.is_open()) {
            LOGE("Failed to open log file for writing: %s", current_log_file_path_.c_str());
            continue;
        }

        for (const auto& entry : temp_queue) {
            json file_json = {
                {"ts", entry.timestamp_ms},
                {"lvl", static_cast<int>(entry.level)},
                {"cat", entry.category},
                {"msg", entry.message}
            };
            if (!entry.package_name.empty()) file_json["pkg"] = entry.package_name;
            if (entry.user_id != -1) file_json["uid"] = entry.user_id;
            log_file << file_json.dump() << std::endl;
        }
        current_log_line_count_ += temp_queue.size();
    }
}
```

daemon/cpp/logger.h
```
// daemon/cpp/logger.h
#ifndef CERBERUS_LOGGER_H
#define CERBERUS_LOGGER_H

#include <string>
#include <vector>
#include <mutex>
#include <deque>
#include <thread>
#include <atomic>
#include <condition_variable>
#include <nlohmann/json.hpp>
#include <memory>
#include <optional>

using json = nlohmann::json;

enum class LogLevel {
    INFO,
    SUCCESS,
    WARN,
    ERROR,
    EVENT,
    DOZE,
    BATTERY,
    REPORT,
    ACTION_OPEN,
    ACTION_CLOSE,
    ACTION_FREEZE,
    ACTION_UNFREEZE,
    ACTION_DELAY,
    TIMER,
    BATCH_PARENT
};

struct LogEntry {
    long long timestamp_ms;
    LogLevel level;
    std::string category;
    std::string message;
    std::string package_name;
    int user_id;

    json to_json() const;
};

class Logger : public std::enable_shared_from_this<Logger> {
public:
    static std::shared_ptr<Logger> get_instance(const std::string& log_dir_path);
    ~Logger();

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    void log(LogLevel level, const std::string& category, const std::string& message,
             const std::string& package_name = "", int user_id = -1);
    
    void log_batch(const std::vector<LogEntry>& entries);

    // [修改] get_logs_from_file 现在支持 since 和 before
    std::vector<LogEntry> get_logs_from_file(const std::string& filename, int limit,
                                             std::optional<long long> before_timestamp_ms,
                                             std::optional<long long> since_timestamp_ms) const;
    
    std::vector<std::string> get_log_files() const;
    void stop();

private:
    explicit Logger(const std::string& log_dir_path);
    void writer_thread_func();
    void manage_log_files();
    void rotate_log_file_if_needed(size_t new_entries_count);
    void cleanup_old_files();
    
    static std::shared_ptr<Logger> instance_;
    static std::mutex instance_mutex_;

    std::string log_dir_path_;
    std::string current_log_file_path_;
    int current_log_line_count_ = 0;

    std::deque<LogEntry> log_queue_;
    mutable std::mutex queue_mutex_;
    std::condition_variable cv_;
    std::thread writer_thread_;
    std::atomic<bool> is_running_;
};

#endif // CERBERUS_LOGGER_H
```

daemon/cpp/main.cpp
```
// daemon/cpp/main.cpp
#include "uds_server.h"
#include "state_manager.h"
#include "system_monitor.h"
#include "database_manager.h"
#include "action_executor.h"
#include "main.h"
#include <nlohmann/json.hpp>
#include <android/log.h>
#include "logger.h"
#include "time_series_database.h"
#include <csignal>
#include <thread>
#include <chrono>
#include <memory>
#include <atomic>
#include <filesystem>
#include <mutex>
#include <unistd.h>

#define LOG_TAG "cerberusd_main_v34_wakeup" // 版本号更新
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

using json = nlohmann::json;
namespace fs = std::filesystem;

std::unique_ptr<UdsServer> g_server;
static std::shared_ptr<StateManager> g_state_manager;
static std::shared_ptr<SystemMonitor> g_sys_monitor;
static std::shared_ptr<Logger> g_logger;
static std::shared_ptr<TimeSeriesDatabase> g_ts_db;
static std::atomic<bool> g_is_running = true;
std::atomic<int> g_probe_fd = -1;
static std::thread g_worker_thread;
std::atomic<int> g_top_app_refresh_tickets = 0;


void handle_client_message(int client_fd, const std::string& message_str) {
    try {
        json msg = json::parse(message_str);
        std::string type = msg.value("type", "");

        if (type == "hello.ui") {
            g_server->identify_client_as_ui(client_fd);
            if (g_state_manager) {
                json payload = g_state_manager->get_dashboard_payload();
                g_server->send_message(client_fd, json{{"type", "stream.dashboard_update"}, {"payload", payload}}.dump());
            }
            return;
        }

        if (type == "query.get_logs") {
            const auto& payload_json = msg.value("payload", json::object());
            std::string filename = payload_json.value("filename", "");
            long long before_ts = payload_json.value("before", 0LL);
            long long since_ts = payload_json.value("since", 0LL);
            int limit = payload_json.value("limit", 50);

            std::vector<LogEntry> logs;
            if (!filename.empty()) {
                logs = g_logger->get_logs_from_file(filename, limit, 
                    before_ts > 0 ? std::optional(before_ts) : std::nullopt,
                    since_ts > 0 ? std::optional(since_ts) : std::nullopt);
            }

            json log_array = json::array();
            for(const auto& log : logs) { log_array.push_back(log.to_json()); }

            g_server->send_message(client_fd, json{
                {"type", "resp.get_logs"},
                {"req_id", msg.value("req_id", "")},
                {"payload", log_array}
            }.dump());
            return;
        }
        
        if (type == "query.get_log_files") {
            auto files = g_logger->get_log_files();
            g_server->send_message(client_fd, json{
                {"type", "resp.get_log_files"},
                {"req_id", msg.value("req_id", "")},
                {"payload", files}
            }.dump());
            return;
        }

        if (type == "query.get_history_stats") {
            auto records = g_ts_db->get_all_records();
            json record_array = json::array();
            for(const auto& record : records) { record_array.push_back(record.to_json()); }
            g_server->send_message(client_fd, json{ {"type", "resp.history_stats"}, {"req_id", msg.value("req_id", "")}, {"payload", record_array} }.dump());
            return;
        }

        if (!g_state_manager) return;

        // [核心新增] 添加对新唤醒事件的处理路由
        if (type == "event.app_wakeup_request_v2") {
            g_state_manager->on_wakeup_request_from_probe(msg.at("payload"));
        } else if (type == "cmd.proactive_unfreeze") {
            g_state_manager->on_proactive_unfreeze_request(msg.at("payload"));
        } else if (type == "event.app_foreground") {
            g_state_manager->on_app_foreground_event(msg.at("payload"));
        } else if (type == "event.app_background") {
            g_state_manager->on_app_background_event(msg.at("payload"));
        }
        else if (type == "cmd.request_temp_unfreeze_pkg") {
            g_state_manager->on_temp_unfreeze_request_by_pkg(msg.at("payload"));
        } else if (type == "cmd.request_temp_unfreeze_uid") {
            g_state_manager->on_temp_unfreeze_request_by_uid(msg.at("payload"));
        } else if (type == "cmd.request_temp_unfreeze_pid") {
            g_state_manager->on_temp_unfreeze_request_by_pid(msg.at("payload"));
        }
        else if (type == "event.app_wakeup_request") {
            // Note: This is the old event type. The new probe sends v2.
            // We can keep this for backward compatibility or remove it.
            g_state_manager->on_wakeup_request(msg.at("payload"));
        } else if (type == "cmd.set_policy") {
            if (g_state_manager->on_config_changed_from_ui(msg.at("payload"))) {
                notify_probe_of_config_change();
            }
            g_top_app_refresh_tickets = 1;
        }
        else if (type == "cmd.set_master_config") {
            MasterConfig cfg;
            const auto& payload = msg.at("payload");
            cfg.standard_timeout_sec = payload.value("standard_timeout_sec", 90);
            cfg.is_timed_unfreeze_enabled = payload.value("is_timed_unfreeze_enabled", true);
            cfg.timed_unfreeze_interval_sec = payload.value("timed_unfreeze_interval_sec", 1800);
            g_state_manager->update_master_config(cfg);
        }
        else if (type == "query.refresh_dashboard") {
            broadcast_dashboard_update();
        } else if (type == "query.get_all_policies") {
            json payload = g_state_manager->get_full_config_for_ui();
            g_server->send_message(client_fd, json{{"type", "resp.all_policies"}, {"req_id", msg.value("req_id", "")}, {"payload", payload}}.dump());
        } else if (type == "event.probe_hello") {
            g_probe_fd = client_fd;
            notify_probe_of_config_change();
        }
    } catch (const json::exception& e) { LOGE("JSON Error: %s in msg: %s", e.what(), message_str.c_str()); }
}

void handle_client_disconnect(int client_fd) {
    LOGI("Client fd %d has disconnected.", client_fd);
    if (client_fd == g_probe_fd.load()) {
        g_probe_fd = -1;
    }
}

void broadcast_dashboard_update() {
    if (g_server && g_server->has_clients() && g_state_manager) {
        LOGD("Broadcasting dashboard update...");
        json payload = g_state_manager->get_dashboard_payload();
        g_server->broadcast_message_except(json{{"type", "stream.dashboard_update"}, {"payload", payload}}.dump(), g_probe_fd.load());
    }
}

void notify_probe_of_config_change() {
    int probe_fd = g_probe_fd.load();
    if (g_server && probe_fd != -1 && g_state_manager) {
        json payload = g_state_manager->get_probe_config_payload();
        g_server->send_message(probe_fd, json{{"type", "stream.probe_config_update"}, {"payload", payload}}.dump());
    }
}

void signal_handler(int signum) {
    LOGW("Signal %d received, shutting down...", signum);
    g_is_running = false;
    if (g_server) g_server->stop();
    if (g_logger) g_logger->stop();
}

void worker_thread_func() {
    LOGI("Worker thread started.");
    g_top_app_refresh_tickets = 2;

    int reconcile_countdown = 15;
    int audio_scan_countdown = 3;
    int location_scan_countdown = 15;
    int audit_countdown = 30;
    int heartbeat_countdown = 7;

    const int SAMPLING_INTERVAL_SEC = 2;

    while (g_is_running) {
        auto loop_start_time = std::chrono::steady_clock::now();
        bool state_changed = false;

        auto metrics_opt = g_sys_monitor->collect_current_metrics();
        if (metrics_opt) {
            g_ts_db->add_record(*metrics_opt);
            g_state_manager->process_new_metrics(*metrics_opt);
        }

        if (g_top_app_refresh_tickets > 0) {
            g_top_app_refresh_tickets--;
            if (g_state_manager->handle_top_app_change_fast()) state_changed = true;
            audit_countdown = 30;
        }

        if (--audit_countdown <= 0) {
            if (g_state_manager->evaluate_and_execute_strategy()) state_changed = true;
            audit_countdown = 30;
        }

        if (g_state_manager->tick_state_machine()) {
            state_changed = true;
        }

        if (g_server && g_server->has_clients()) {
            if (g_state_manager->perform_staggered_stats_scan()) {
                state_changed = true;
            }
        }

        if (--reconcile_countdown <= 0) {
            if (g_state_manager->perform_deep_scan()) state_changed = true;
            reconcile_countdown = 15;
        }
        if (--audio_scan_countdown <= 0) {
            g_sys_monitor->update_audio_state();
            audio_scan_countdown = 3;
        }
        if (--location_scan_countdown <= 0) {
            g_sys_monitor->update_location_state();
            location_scan_countdown = 15;
        }

        if (--heartbeat_countdown <= 0) {
            if (g_server) {
                g_server->broadcast_message_to_ui("{\"type\":\"ping\"}");
            }
            heartbeat_countdown = 7;
        }

        if (state_changed) {
            broadcast_dashboard_update();
        }

        auto loop_end_time = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::seconds>(loop_end_time - loop_start_time);
        if (duration.count() < SAMPLING_INTERVAL_SEC) {
            std::this_thread::sleep_for(std::chrono::seconds(SAMPLING_INTERVAL_SEC - duration.count()));
        }
    }
    LOGI("Worker thread finished.");
}


int main(int argc, char *argv[]) {
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
    signal(SIGPIPE, SIG_IGN);

    const std::string DATA_DIR = "/data/adb/cerberus";
    const std::string DB_PATH = DATA_DIR + "/cerberus.db";
    const std::string LOG_DIR = DATA_DIR + "/logs";
    LOGI("Project Cerberus Daemon starting... (PID: %d)", getpid());

    try {
        if (!fs::exists(DATA_DIR)) fs::create_directories(DATA_DIR);
        if (!fs::exists(LOG_DIR)) fs::create_directories(LOG_DIR);
    } catch(const fs::filesystem_error& e) {
        LOGE("Failed to create data dir: %s", e.what());
        return 1;
    }

    auto db_manager = std::make_shared<DatabaseManager>(DB_PATH);
    auto action_executor = std::make_shared<ActionExecutor>();
    g_sys_monitor = std::make_shared<SystemMonitor>();
    g_logger = Logger::get_instance(LOG_DIR);
    g_ts_db = TimeSeriesDatabase::get_instance();
    g_state_manager = std::make_shared<StateManager>(db_manager, g_sys_monitor, action_executor, g_logger, g_ts_db);

    g_state_manager->initial_full_scan_and_warmup();

    g_logger->log(LogLevel::EVENT, "Daemon", "守护进程已启动");

    g_sys_monitor->start_top_app_monitor();
    g_sys_monitor->start_network_snapshot_thread();
    g_worker_thread = std::thread(worker_thread_func);

    const int DAEMON_PORT = 28900;
    g_server = std::make_unique<UdsServer>(DAEMON_PORT);
    g_server->set_message_handler(handle_client_message);
    g_server->set_disconnect_handler(handle_client_disconnect);
    g_server->run();

    g_is_running = false;
    if(g_worker_thread.joinable()) g_worker_thread.join();

    g_sys_monitor->stop_top_app_monitor();
    g_sys_monitor->stop_network_snapshot_thread();

    LOGI("Cerberus Daemon has shut down cleanly.");
    return 0;
}
```

daemon/cpp/main.h
```
// daemon/cpp/main.h
#ifndef CERBERUS_MAIN_H
#define CERBERUS_MAIN_H

#include <atomic>
#include <nlohmann/json.hpp>
#include <functional>
#include <variant>
#include <string>
#include <set>

// 这个 Task 结构看起来是为更高级的事件驱动模型准备的，暂时保留
struct ConfigChangeTask { nlohmann::json payload; };
struct TopAppChangeTask { std::set<int> pids; };
struct TickTask {};
struct RefreshDashboardTask {};
struct ProbeHelloTask { int fd; };
struct ClientDisconnectTask { int fd; };
struct ProbeFgEventTask { nlohmann::json payload; };
struct ProbeBgEventTask { nlohmann::json payload; };

using Task = std::variant<
    ConfigChangeTask,
    TopAppChangeTask,
    TickTask,
    RefreshDashboardTask,
    ProbeHelloTask,
    ClientDisconnectTask,
    ProbeFgEventTask,
    ProbeBgEventTask
>;

// --- 全局函数声明 ---
void broadcast_dashboard_update();
void notify_probe_of_config_change();

// 如果您暂时不使用 schedule_task，可以注释掉它以避免潜在的未定义引用错误
// void schedule_task(Task task); 

// [修复] 声明全局 probe fd
extern std::atomic<int> g_probe_fd;

#endif //CERBERUS_MAIN_H
```

daemon/cpp/state_manager.cpp
```
// daemon/cpp/state_manager.cpp
#include "state_manager.h"
#include "main.h"
#include <android/log.h>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <unistd.h>
#include <algorithm>
#include <sys/stat.h>
#include <unordered_map>
#include <ctime>
#include <iomanip>

#define LOG_TAG "cerberusd_state_v40_report_top7" // 版本号更新
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;
using json = nlohmann::json;

static std::string status_to_string(const AppRuntimeState& app, const MasterConfig& master_config) {
    if (app.current_status == AppRuntimeState::Status::STOPPED) return "未运行";
    if (app.current_status == AppRuntimeState::Status::FROZEN) {
        switch (app.freeze_method) {
            case AppRuntimeState::FreezeMethod::CGROUP: return "已冻结 (V2)";
            case AppRuntimeState::FreezeMethod::SIG_STOP: return "已冻结 (SIG)";
            default: return "已冻结";
        }
    }
    if (app.is_foreground) return "前台运行";
    if (app.config.policy == AppPolicy::EXEMPTED || app.config.policy == AppPolicy::IMPORTANT) return "后台运行 (已豁免)";
    if (app.background_since > 0) {
        time_t now = time(nullptr);
        int timeout_sec = 0;
        if (app.config.policy == AppPolicy::STRICT) {
            timeout_sec = 15;
        } else if (app.config.policy == AppPolicy::STANDARD) {
            timeout_sec = master_config.standard_timeout_sec;
        }
        if (app.freeze_retry_count > 0) {
            timeout_sec += (5 * app.freeze_retry_count);
        }
        int remaining = timeout_sec - (now - app.background_since);
        if (remaining < 0) remaining = 0;
        return "等待冻结 (" + std::to_string(remaining) + "s)";
    }
    if (app.observation_since > 0) {
        time_t now = time(nullptr);
        int remaining = 10 - (now - app.observation_since);
        if (remaining < 0) remaining = 0;
        return "后台观察中 (" + std::to_string(remaining) + "s)";
    }
    return "后台运行";
}


DozeManager::DozeManager(std::shared_ptr<Logger> logger, std::shared_ptr<ActionExecutor> executor)
    : logger_(logger), action_executor_(executor) {
    state_change_timestamp_ = std::chrono::steady_clock::now();
}

void DozeManager::enter_state(State new_state, const MetricsRecord& record) {
    if (new_state == current_state_) return;

    current_state_ = new_state;
    state_change_timestamp_ = std::chrono::steady_clock::now();

    switch(new_state) {
        case State::AWAKE:
            break;
        case State::IDLE:
             logger_->log(LogLevel::DOZE, "Doze", "进入IDLE (息屏, 未充电)");
            break;
        case State::INACTIVE:
            logger_->log(LogLevel::DOZE, "Doze", "进入INACTIVE (检查期)");
            break;
        case State::DEEP_DOZE:
            deep_doze_start_time_ = std::chrono::steady_clock::now();
            logger_->log(LogLevel::DOZE, "Doze", "😴 进入深度Doze");
            break;
    }
}

DozeManager::DozeEvent DozeManager::process_metrics(const MetricsRecord& record) {
    auto now = std::chrono::steady_clock::now();
    auto duration_in_state = std::chrono::duration_cast<std::chrono::seconds>(now - state_change_timestamp_).count();
    State old_state = current_state_;

    if (record.is_screen_on || record.is_charging) {
        enter_state(State::AWAKE, record);
    } else {
        if (current_state_ == State::AWAKE) {
            enter_state(State::IDLE, record);
        } else if (current_state_ == State::IDLE && duration_in_state > 30) {
            if (record.is_audio_playing || record.is_location_active) {
                state_change_timestamp_ = now;
            } else {
                enter_state(State::INACTIVE, record);
            }
        } else if (current_state_ == State::INACTIVE && duration_in_state > 60) {
             if (record.is_audio_playing || record.is_location_active) {
                enter_state(State::IDLE, record);
            } else {
                enter_state(State::DEEP_DOZE, record);
            }
        }
    }

    if (old_state == State::DEEP_DOZE && current_state_ != State::DEEP_DOZE) {
        auto doze_duration = std::chrono::duration_cast<std::chrono::seconds>(now - deep_doze_start_time_);
        long minutes = doze_duration.count() / 60;
        long seconds = doze_duration.count() % 60;
        std::stringstream ss;
        ss << "🤪 退出深度Doze，持续时长 " << minutes << "分" << seconds << "秒";
        logger_->log(LogLevel::DOZE, "Doze", ss.str());
        return DozeEvent::EXITED_DEEP_DOZE;
    }

    if (old_state != State::DEEP_DOZE && current_state_ == State::DEEP_DOZE) {
        return DozeEvent::ENTERED_DEEP_DOZE;
    }

    return DozeEvent::NONE;
}

StateManager::StateManager(std::shared_ptr<DatabaseManager> db, std::shared_ptr<SystemMonitor> sys, std::shared_ptr<ActionExecutor> act,
                           std::shared_ptr<Logger> logger, std::shared_ptr<TimeSeriesDatabase> ts_db)
    : db_manager_(db), sys_monitor_(sys), action_executor_(act), logger_(logger), ts_db_(ts_db) {
    LOGI("StateManager Initializing...");

    unfrozen_timeline_.resize(3600 * 2, 0);
    master_config_ = db_manager_->get_master_config().value_or(MasterConfig{});
    doze_manager_ = std::make_unique<DozeManager>(logger_, action_executor_);

    LOGI("Loaded master config: standard_timeout=%ds, timed_unfreeze_enabled=%d, timed_unfreeze_interval=%ds",
        master_config_.standard_timeout_sec, master_config_.is_timed_unfreeze_enabled, master_config_.timed_unfreeze_interval_sec);

    critical_system_apps_ = {
        "com.google.android.inputmethod.latin",
        "com.baidu.input",
        "com.sohu.inputmethod.sogou",
        "com.iflytek.inputmethod",
        "com.tencent.qqpinyin",
        "com.xiaomi.mibrain.speech",
        "com.xiaomi.scanner",
        "zygote",
        "zygote64",
        "com.xiaomi.xmsf",
        "com.xiaomi.xmsfkeeper",
        "com.xiaomi.misettings",
        "com.xiaomi.barrage",
        "com xiaomi.aireco",
        "com.xiaomi.account",
        "com.miui.notes",
        "com.miui.calculator",
        "com.miui.compass",
        "com.miui.mediaeditor",
        "com.miui.personalassistant",
        "com.miui.vipservice",
        "com.miui.systemAdSolution",
        "com.miui.home",
        "com.miui.carlink",
        "com.miui.packageinstaller",
        "com.miui.accessibility",
        "com.miui.core",
        "com.miui.privacycomputing",
        "com.miui.securityadd",
        "com.miui.securityinputmethod",
        "com.miui.system",
        "com.miui.vpnsdkmanager",
        "com.mfashiongallery.emag",
        "com.huawei.hwid",
        "cn.litiaotiao.app",
        "com.litiaotiao.app",
        "hello.litiaotiao.app",
        "com.zfdang.touchhelper",
        "com.giftedcat.adskiphelper",
        "com.merxury.blocker",
        "com.wpengapp.lightstart",
        "li.songe.gkd",
        "com.sevtinge.hyperceiler",
        "com.topjohnwu.magisk",
        "org.lsposed.manager",
        "name.monwf.customiuizer",
        "name.mikanoshi.customiuizer",
        "com.android.vending",
        "org.meowcat.xposed.mipush",
        "top.trumeet.mipush",
        "one.yufz.hmspush",
        "app.lawnchair",
        "com.microsoft.launcher",
        "com.teslacoilsw.launcher",
        "com.hola.launcher",
        "com.transsion.XOSLauncher",
        "com.mi.android.globallauncher",
        "com.gau.go.launcherex",
        "bitpit.launcher",
        "com.oppo.launcher",
        "me.weishu.kernelsu",
        "top.canyie.dreamland.manager",
        "com.coloros.packageinstaller",
        "com.oplus.packageinstaller",
        "com.iqoo.packageinstaller",
        "com.vivo.packageinstaller",
        "com.google.android.packageinstaller",
        "com.baidu.input_huawei",
        "com.baidu.input_oppo",
        "com.baidu.input_vivo",
        "com.baidu.input_yijia",
        "com.sohu.inputmethod.sogou.xiaomi",
        "com.sohu.inputmethod.sogou.meizu",
        "com.sohu.inputmethod.sogou.nubia",
        "com.sohu.inputmethod.sogou.chuizi",
        "com.sohu.inputmethod.sogou.moto",
        "com.sohu.inputmethod.sogou.zte",
        "com.sohu.inputmethod.sogou.samsung",
        "com.sohu.input_yijia",
        "com.iflytek.inputmethod.miui",
        "com.iflytek.inputmethod.googleplay",
        "com.iflytek.inputmethod.smartisan",
        "com.iflytek.inputmethod.oppo",
        "com.iflytek.inputmethod.oem",
        "com.iflytek.inputmethod.custom",
        "com.iflytek.inputmethod.blackshark",
        "com.iflytek.inputmethod.zte",
        "com.touchtype.swiftkey",
        "com.touchtype.swiftkey.beta",
        "im.weshine.keyboard",
        "com.komoxo.octopusime",
        "com.qujianpan.duoduo",
        "com.lxlm.lhl.softkeyboard",
        "com.jinkey.unfoldedime",
        "com.iflytek.inputmethods.DungkarIME",
        "com.oyun.qingcheng",
        "com.ziipin.softkeyboard",
        "com.kongzue.secretinput",
        "com.google.android.ext.services",
        "com.google.android.ext.shared",
        "com.google.android.gms",
        "com.google.android.gsf",
        "com.google.android.systemui.gxoverlay",
        "com.google.android.tag",
        "com.google.android.documentsui",
        "com.google.android.captiveportallogin",
        "com.google.android.printservice.recommendation",
        "com.google.android.gms.supervision",
        "com.google.android.as.oss",
        "com.google.android.configupdater",
        "com.google.android.apps.restore",
        "com.google.android.onetimeinitializer",
        "com.google.android.odad",
        "com.google.android.settings.intelligence",
        "com.google.android.partnersetup",
        "com.google.android.projection.gearhead",
        "com.google.android.apps.wellbeing",
        "com.google.android.as",
        "com.google.android.apps.messaging",
        "com.google.android.googlequicksearchbox",
        "com.google.android.webview",
        "com.google.android.tts",
        "com.google.android.deskclock",
        "com.google.android.markup",
        "com.google.android.calendar",
        "com.google.android.soundpicker",
        "com.google.android.apps.wallpaper.nexus",
        "com.google.android.modulemetadata",
        "com.google.android.contacts",
        "com.google.android.apps.customization.pixel",
        "com.google.android.apps.photos",
        "com.google.android.feedback",
        "com.google.android.apps.wallpaper",
        "com.google.android.providers.media.module",
        "com.google.android.wifi.resources",
        "com.google.android.hotspot2.osulogin",
        "com.google.android.safetycenter.resources",
        "com.google.android.permissioncontroller",
        "com.google.android.ondevicepersonalization.services",
        "com.google.android.adservices.api",
        "com.google.android.devicelockcontroller",
        "com.google.android.connectivity.resources",
        "com.google.android.healthconnect.controller",
        "com.google.android.cellbroadcastreceiver",
        "com.google.android.uwb.resources",
        "com.google.android.rkpdapp",
        "com.android.launcher",
        "com.android.launcher2",
        "com.android.launcher4",
        "com.android.camera",
        "com.android.camera2",
        "com.android.apps.tag",
        "com.android.bips",
        "com.android.bluetoothmidiservice",
        "com.android.cameraextensions",
        "com.android.carrierdefaultapp",
        "com.android.certinstaller",
        "com.android.companiondevicemanager",
        "com.android.dreams.basic",
        "com.android.egg",
        "com.android.emergency",
        "com.android.externalstorage",
        "com.android.htmlviewer",
        "com.android.internal.display.cutout.emulation.corner",
        "com.android.internal.display.cutout.emulation.double",
        "com.android.internal.display.cutout.emulation.hole",
        "com.android.internal.display.cutout.emulation.tall",
        "com.android.internal.display.cutout.emulation.waterfall",
        "com.android.internal.systemui.navbar.gestural",
        "com.android.internal.systemui.navbar.gestural_extra_wide_back",
        "com.android.internal.systemui.navbar.gestural_narrow_back",
        "com.android.internal.systemui.navbar.gestural_wide_back",
        "com.android.internal.systemui.navbar.threebutton",
        "com.android.managedprovisioning",
        "com.android.mms",
        "com.android.mtp",
        "com.android.musicfx",
        "com.android.networkstack.inprocess.overlay",
        "com.android.networkstack.overlay",
        "com.android.networkstack.tethering.inprocess.overlay",
        "com.android.networkstack.tethering.overlay",
        "com.android.packageinstaller",
        "com.android.pacprocessor",
        "com.android.printspooler",
        "com.android.providers.calendar",
        "com.android.providers.contacts",
        "com.android.providers.downloads.ui",
        "com.android.proxyhandler",
        "com.android.server.telecom.overlay.miui",
        "com.android.simappdialog",
        "com.android.soundrecorder",
        "com.android.statementservice",
        "com.android.storagemanager",
        "com.android.theme.font.notoserifsource",
        "com.android.traceur",
        "com.android.vpndialogs",
        "com.android.wallpaper.livepicker",
        "com.debug.loggerui",
        "com.fingerprints.sensortesttool",
        "com.lbe.security.miui",
        "com.mediatek.callrecorder",
        "com.mediatek.duraspeed",
        "com.mediatek.engineermode",
        "com.mediatek.lbs.em2.ui",
        "com.mediatek.location.mtkgeofence",
        "com.mediatek.mdmconfig",
        "com.mediatek.mdmlsample",
        "com.mediatek.miravision.ui",
        "com.mediatek.op01.telecom",
        "com.mediatek.op09clib.phone.plugin",
        "com.mediatek.op09clib.telecom",
        "com.mediatek.ygps",
        "com.tencent.soter.soterserver",
        "com.unionpay.tsmservice.mi",
        "android.ext.services",
        "android.ext.shared",
        "com.android.bookmarkprovider",
        "com.android.cellbroadcastreceiver.module",
        "com.android.dreams.phototable",
        "com.android.intentresolver",
        "com.android.internal.display.cutout.emulation.noCutout",
        "com.android.internal.systemui.navbar.twobutton",
        "com.android.messaging",
        "com.android.wallpaper",
        "com.qualcomm.qti.cne",
        "com.qualcomm.qti.poweroffalarm",
        "com.qualcomm.wfd.service",
        "org.lineageos.aperture",
        "org.lineageos.audiofx",
        "org.lineageos.backgrounds",
        "org.lineageos.customization",
        "org.lineageos.eleven",
        "org.lineageos.etar",
        "org.lineageos.jelly",
        "org.lineageos.overlay.customization.blacktheme",
        "org.lineageos.overlay.font.lato",
        "org.lineageos.overlay.font.rubik",
        "org.lineageos.profiles",
        "org.lineageos.recorder",
        "org.lineageos.updater",
        "org.protonaosp.deviceconfig",
        "android.aosp.overlay",
        "android.miui.home.launcher.res",
        "android.miui.overlay",
        "com.android.carrierconfig",
        "com.android.carrierconfig.overlay.miui",
        "com.android.incallui.overlay",
        "com.android.managedprovisioning.overlay",
        "com.android.overlay.cngmstelecomm",
        "com.android.overlay.gmscontactprovider",
        "com.android.overlay.gmssettingprovider",
        "com.android.overlay.gmssettings",
        "com.android.overlay.gmstelecomm",
        "com.android.overlay.gmstelephony",
        "com.android.overlay.systemui",
        "com.android.phone.overlay.miui",
        "com.android.providers.settings.overlay",
        "com.android.sdksandbox",
        "com.android.settings.overlay.miui",
        "com.android.stk.overlay.miui",
        "com.android.systemui.gesture.line.overlay",
        "com.android.systemui.navigation.bar.overlay",
        "com.android.systemui.overlay.miui",
        "com.android.wallpapercropper",
        "com.android.wallpaperpicker",
        "com.android.wifi.dialog",
        "com.android.wifi.resources.overlay",
        "com.android.wifi.resources.xiaomi",
        "com.android.wifi.system.mainline.resources.overlay",
        "com.android.wifi.system.resources.overlay",
        "com.google.android.cellbroadcastreceiver.overlay.miui",
        "com.google.android.cellbroadcastservice.overlay.miui",
        "com.google.android.overlay.gmsconfig",
        "com.google.android.overlay.modules.ext.services",
        "com.google.android.trichromelibrary_511209734",
        "com.google.android.trichromelibrary_541411734",
        "com.mediatek.FrameworkResOverlayExt",
        "com.mediatek.SettingsProviderResOverlay",
        "com.mediatek.batterywarning",
        "com.mediatek.cellbroadcastuiresoverlay",
        "com.mediatek.frameworkresoverlay",
        "com.mediatek.gbaservice",
        "com.mediatek.voiceunlock",
        "com.miui.core.internal.services",
        "com.miui.face.overlay.miui",
        "com.miui.miwallpaper.overlay.customize",
        "com.miui.miwallpaper.wallpaperoverlay.config.overlay",
        "com.miui.rom",
        "com.miui.settings.rro.device.config.overlay",
        "com.miui.settings.rro.device.hide.statusbar.overlay",
        "com.miui.settings.rro.device.type.overlay",
        "com.miui.system.overlay",
        "com.miui.systemui.carriers.overlay",
        "com.miui.systemui.devices.overlay",
        "com.miui.systemui.overlay.devices.android",
        "com.miui.translation.kingsoft",
        "com.miui.translation.xmcloud",
        "com.miui.translationservice",
        "com.miui.voiceassistoverlay",
        "com.xiaomi.bluetooth.rro.device.config.overlay",
        "android.auto_generated_rro_product__",
        "android.auto_generated_rro_vendor__",
        "com.android.backupconfirm",
        "com.android.carrierconfig.auto_generated_rro_vendor__",
        "com.android.cts.ctsshim",
        "com.android.cts.priv.ctsshim",
        "com.android.documentsui.auto_generated_rro_product__",
        "com.android.emergency.auto_generated_rro_product__",
        "com.android.imsserviceentitlement",
        "com.android.imsserviceentitlement.auto_generated_rro_product__",
        "com.android.inputmethod.latin.auto_generated_rro_product__",
        "com.android.launcher3.overlay",
        "com.android.managedprovisioning.auto_generated_rro_product__",
        "com.android.nearby.halfsheet",
        "com.android.phone.auto_generated_rro_vendor__",
        "com.android.providers.settings.auto_generated_rro_product__",
        "com.android.providers.settings.auto_generated_rro_vendor__",
        "com.android.settings.auto_generated_rro_product__",
        "com.android.sharedstoragebackup",
        "com.android.smspush",
        "com.android.storagemanager.auto_generated_rro_product__",
        "com.android.systemui.auto_generated_rro_product__",
        "com.android.systemui.auto_generated_rro_vendor__",
        "com.android.systemui.plugin.globalactions.wallet",
        "com.android.wallpaper.auto_generated_rro_product__",
        "com.android.wifi.resources.oneplus_sdm845",
        "com.qualcomm.timeservice",
        "lineageos.platform.auto_generated_rro_product__",
        "lineageos.platform.auto_generated_rro_vendor__",
        "org.codeaurora.ims",
        "org.lineageos.aperture.auto_generated_rro_vendor__",
        "org.lineageos.lineageparts.auto_generated_rro_product__",
        "org.lineageos.lineagesettings.auto_generated_rro_product__",
        "org.lineageos.lineagesettings.auto_generated_rro_vendor__",
        "org.lineageos.overlay.customization.navbar.nohint",
        "org.lineageos.settings.device.auto_generated_rro_product__",
        "org.lineageos.settings.doze.auto_generated_rro_product__",
        "org.lineageos.settings.doze.auto_generated_rro_vendor__",
        "org.lineageos.setupwizard.auto_generated_rro_product__",
        "org.lineageos.updater.auto_generated_rro_product__",
        "org.protonaosp.deviceconfig.auto_generated_rro_product__"
      };

    load_all_configs();
    next_scan_iterator_ = managed_apps_.begin();
    last_battery_level_info_ = std::nullopt;
    LOGI("StateManager Initialized. Ready for warmup.");
}

void StateManager::initial_full_scan_and_warmup() {
    LOGI("Starting initial full scan and data warmup...");
    std::lock_guard<std::mutex> lock(state_mutex_);

    reconcile_process_state_full();

    int warmed_up_count = 0;
    for (auto& [key, app] : managed_apps_) {
        if (!app.pids.empty()) {
            sys_monitor_->update_app_stats(app.pids, app.mem_usage_kb, app.swap_usage_kb, app.cpu_usage_percent);
            warmed_up_count++;
        }
    }

    LOGI("Warmup complete. Populated initial stats for %d running app instances.", warmed_up_count);
    logger_->log(LogLevel::EVENT, "Daemon", "启动预热完成，已填充初始数据");
}

bool StateManager::perform_staggered_stats_scan() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    if (managed_apps_.empty()) {
        return false;
    }

    const int APPS_PER_TICK = 2;

    for (int i = 0; i < APPS_PER_TICK; ++i) {
        if (next_scan_iterator_ == managed_apps_.end()) {
            next_scan_iterator_ = managed_apps_.begin();
        }
        if (next_scan_iterator_ == managed_apps_.end()) {
            break;
        }

        auto& app = next_scan_iterator_->second;
        if (!app.pids.empty()) {
            sys_monitor_->update_app_stats(app.pids, app.mem_usage_kb, app.swap_usage_kb, app.cpu_usage_percent);
        }

        ++next_scan_iterator_;
    }

    return true;
}

bool StateManager::evaluate_and_execute_strategy() {
    bool state_has_changed = false;
    
    auto visible_app_keys = sys_monitor_->get_visible_app_keys();
    
    state_has_changed |= update_foreground_state(visible_app_keys);

    if (state_has_changed) {
        auto process_tree = sys_monitor_->get_full_process_tree();
        audit_app_structures(process_tree);
    }

    return state_has_changed;
}

bool StateManager::handle_top_app_change_fast() {
    auto top_pids = sys_monitor_->read_top_app_pids();
    return update_foreground_state_from_pids(top_pids);
}

void StateManager::process_new_metrics(const MetricsRecord& record) {
    std::lock_guard<std::mutex> lock(state_mutex_);

    auto doze_event = doze_manager_->process_metrics(record);

    if (doze_event == DozeManager::DozeEvent::ENTERED_DEEP_DOZE) {
        doze_start_process_info_.clear();
        for (const auto& [key, app] : managed_apps_) {
            for (int pid : app.pids) {
                doze_start_process_info_[pid] = {
                    .start_jiffies = sys_monitor_->get_total_cpu_jiffies_for_pids({pid}),
                    .process_name = sys_monitor_->get_app_name_from_pid(pid),
                    .package_name = app.package_name,
                    .user_id = app.user_id
                };
            }
        }
    } else if (doze_event == DozeManager::DozeEvent::EXITED_DEEP_DOZE) {
        generate_doze_exit_report();
        doze_start_process_info_.clear();
    }

    if (last_metrics_record_) {
        handle_charging_state_change(*last_metrics_record_, record);
        analyze_battery_change(*last_metrics_record_, record);
    }

    last_metrics_record_ = record;
}

void StateManager::generate_doze_exit_report() {
    struct ProcessActivity {
        std::string process_name;
        double cpu_seconds;
    };

    struct AppActivitySummary {
        std::string app_name;
        std::string package_name;
        int user_id;
        double total_cpu_seconds = 0.0;
        std::vector<ProcessActivity> processes;
    };

    std::map<AppInstanceKey, AppActivitySummary> grouped_activities;
    const long TCK = sysconf(_SC_CLK_TCK);
    if (TCK <= 0) return;

    for (const auto& [pid, start_record] : doze_start_process_info_) {
        std::string base_package_name = start_record.package_name;
        size_t colon_pos = base_package_name.find(':');
        if (colon_pos != std::string::npos) {
            base_package_name = base_package_name.substr(0, colon_pos);
        }

        long long end_jiffies = sys_monitor_->get_total_cpu_jiffies_for_pids({pid});
        if (end_jiffies > start_record.start_jiffies) {
            double cpu_seconds = static_cast<double>(end_jiffies - start_record.start_jiffies) / TCK;
            if (cpu_seconds > 0.01) {
                AppInstanceKey key = {base_package_name, start_record.user_id};
                if (grouped_activities.find(key) == grouped_activities.end()) {
                    auto it = managed_apps_.find(key);
                    grouped_activities[key].app_name = (it != managed_apps_.end() && !it->second.app_name.empty()) ? it->second.app_name : key.first;
                    grouped_activities[key].package_name = key.first;
                    grouped_activities[key].user_id = key.second;
                }
                grouped_activities[key].processes.push_back({start_record.process_name, cpu_seconds});
                grouped_activities[key].total_cpu_seconds += cpu_seconds;
            }
        }
    }

    if (grouped_activities.empty()) {
        logger_->log(LogLevel::BATCH_PARENT, "报告", "Doze期间无明显应用活动。");
        return;
    }
    
    std::vector<LogEntry> batch_log_entries;
    long long now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();

    batch_log_entries.push_back({now_ms, LogLevel::BATCH_PARENT, "报告", "Doze期间应用的CPU活跃时间：", "", -1});

    std::vector<AppActivitySummary> sorted_apps;
    for (auto const& [key, val] : grouped_activities) {
        sorted_apps.push_back(val);
    }
    std::sort(sorted_apps.begin(), sorted_apps.end(),
              [](const auto& a, const auto& b) { return a.total_cpu_seconds > b.total_cpu_seconds; });

    // [核心修改] 只取前7个
    const int REPORT_LIMIT = 7;
    int count = 0;
    for (const auto& summary : sorted_apps) {
        if (++count > REPORT_LIMIT) break;

        std::stringstream report_ss;
        report_ss << summary.app_name << " 总计: "
                  << std::fixed << std::setprecision(3) << summary.total_cpu_seconds << "s";
        
        if (!summary.processes.empty()) {
            report_ss << "\n包括:";
        }
        
        for (const auto& proc : summary.processes) {
            report_ss << "\n- " << proc.process_name << ": " << std::fixed << std::setprecision(3) << proc.cpu_seconds << "s";
        }
        batch_log_entries.push_back({now_ms, LogLevel::REPORT, "报告", report_ss.str(), summary.package_name, summary.user_id});
    }

    logger_->log_batch(batch_log_entries);
}


void StateManager::handle_charging_state_change(const MetricsRecord& old_record, const MetricsRecord& new_record) {
    if (old_record.is_charging != new_record.is_charging) {
        if (new_record.is_charging) {
            logger_->log(LogLevel::BATTERY, "充电", "⚡️ 开始充电 (当前电量: " + std::to_string(new_record.battery_level) + "%)");
        } else {
            logger_->log(LogLevel::BATTERY, "充电", "🔌 停止充电 (当前电量: " + std::to_string(new_record.battery_level) + "%)");
        }
    }
}

void StateManager::analyze_battery_change(const MetricsRecord& old_record, const MetricsRecord& new_record) {
    if (new_record.is_charging || new_record.battery_level < 0) {
        last_battery_level_info_ = std::nullopt;
        return;
    }

    if (!last_battery_level_info_) {
        last_battery_level_info_ = {new_record.battery_level, new_record.timestamp_ms};
        return;
    }

    if (new_record.battery_level < last_battery_level_info_->first) {
        long long time_delta_ms = new_record.timestamp_ms - last_battery_level_info_->second;
        int level_delta = last_battery_level_info_->first - new_record.battery_level;

        if (time_delta_ms <= 0 || level_delta <= 0) return;

        long long time_per_percent_ms = time_delta_ms / level_delta;

        std::stringstream ss;
        ss << "[当前: " << new_record.battery_level << "%] [消耗: " << level_delta << "%/"
           << (time_delta_ms / 1000 / 60) << "m " << (time_delta_ms / 1000) % 60 << "s] "
           << "[功率: " << std::fixed << std::setprecision(2) << new_record.battery_power_watt << "W] "
           << "[温度: " << std::fixed << std::setprecision(1) << new_record.battery_temp_celsius << "°C]";

        LogLevel level = (time_per_percent_ms < 300000) ? LogLevel::WARN : LogLevel::BATTERY;
        std::string category = (time_per_percent_ms < 300000) ? "电量警告" : "电量";
        if (level == LogLevel::WARN) ss << " (耗电较快)";
        else ss << " (状态更新)";

        logger_->log(level, category, ss.str());

        last_battery_level_info_ = {new_record.battery_level, new_record.timestamp_ms};
    }
}

bool StateManager::unfreeze_and_observe_nolock(AppRuntimeState& app, const std::string& reason, WakeupType wakeup_type) {
    cancel_timed_unfreeze(app);

    if (app.current_status == AppRuntimeState::Status::FROZEN) {
        std::string msg = "因 " + reason + " 而解冻";
        logger_->log(LogLevel::ACTION_UNFREEZE, "解冻", msg, app.package_name, app.user_id);

        action_executor_->unfreeze({app.package_name, app.user_id}, app.pids);
        app.current_status = AppRuntimeState::Status::RUNNING;
        app.freeze_method = AppRuntimeState::FreezeMethod::NONE;
        
        // [核心新增] 根据唤醒类型设置不同的观察期（即重冻延迟）
        // 观察期总时长为10秒。
        time_t now = time(nullptr);
        switch(wakeup_type) {
            case WakeupType::GENERIC_NOTIFICATION:
                // 对于普通通知，认为应用处理时间短，设置一个短的观察期。
                // now - 7 意味着10秒的观察期已经过去了7秒，还剩3秒。
                app.observation_since = now - 7;
                LOGI("Smart Unfreeze: %s gets 3s observation for generic notification.", app.package_name.c_str());
                break;
            case WakeupType::FCM_PUSH:
                // 对于FCM，应用可能需要联网等操作，给予更长的观察期。
                // now + 5 意味着10秒的观察期从5秒后才开始计算，总计15秒。
                app.observation_since = now + 5;
                LOGI("Smart Unfreeze: %s gets 15s observation for FCM push.", app.package_name.c_str());
                break;
            default:
                // 默认10秒观察期
                app.observation_since = now;
                LOGI("Smart Unfreeze: %s gets default 10s observation.", app.package_name.c_str());
                break;
        }
        
        app.background_since = 0;
        app.freeze_retry_count = 0;

        return true;
    } else {
        LOGD("UNFREEZE [%s]: Request for %s ignored. Reason: App not frozen (current state: %d).",
            reason.c_str(), app.package_name.c_str(), static_cast<int>(app.current_status));
        return false;
    }
}

void StateManager::on_wakeup_request_from_probe(const json& payload) {
    bool state_changed = false;
    try {
        int uid = payload.value("uid", -1);
        int type_int = payload.value("type_int", static_cast<int>(WakeupType::OTHER));
        auto wakeup_type = static_cast<WakeupType>(type_int);
        
        if (uid < 0) return;

        std::string reason = (wakeup_type == WakeupType::FCM_PUSH) ? "FCM" : "Notification";
        LOGD("Received wakeup request for UID: %d, Reason: %s", uid, reason.c_str());

        std::lock_guard<std::mutex> lock(state_mutex_);
        bool app_found = false;
        for (auto& [key, app] : managed_apps_) {
            if (app.uid == uid) {
                app_found = true;
                if (unfreeze_and_observe_nolock(app, reason, wakeup_type)) {
                    state_changed = true;
                }
                break; // 假设一个UID只对应一个应用实例
            }
        }
        if (!app_found) {
            LOGW("Wakeup request for unknown UID: %d", uid);
        }
    } catch (const json::exception& e) {
        LOGE("Error processing wakeup request from probe: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}


void StateManager::audit_app_structures(const std::map<int, ProcessInfo>& process_tree) {
    std::lock_guard<std::mutex> lock(state_mutex_);
    for(auto& [key, app] : managed_apps_) {
        app.has_rogue_structure = false;
        app.rogue_puppet_pid = -1;
        app.rogue_master_pid = -1;

        if (app.is_foreground || app.pids.size() < 2) continue;

        for (int pid : app.pids) {
            auto it_pid = process_tree.find(pid);
            if (it_pid == process_tree.end()) continue;

            const auto& child_info = it_pid->second;
            if (child_info.oom_score_adj <= 0) {
                auto it_ppid = process_tree.find(child_info.ppid);
                if (it_ppid != process_tree.end() && it_ppid->second.pkg_name == app.package_name) {
                    const auto& parent_info = it_ppid->second;
                    if (parent_info.oom_score_adj > 200) {
                        if (!app.has_logged_rogue_warning) {
                            LOGW("AUDIT: Rogue structure detected in %s! Puppet: pid=%d (adj=%d), Master: pid=%d (adj=%d)",
                                app.package_name.c_str(), child_info.pid, child_info.oom_score_adj,
                                parent_info.pid, parent_info.oom_score_adj);
                            logger_->log(LogLevel::WARN, "审计", "检测到流氓进程结构", app.package_name, app.user_id);
                            app.has_logged_rogue_warning = true;
                        }
                        app.has_rogue_structure = true;
                        app.rogue_puppet_pid = child_info.pid;
                        app.rogue_master_pid = parent_info.pid;
                        break;
                    }
                }
            }
        }
    }
}

bool StateManager::update_foreground_state(const std::set<AppInstanceKey>& visible_app_keys) {
    bool state_has_changed = false;
    bool probe_config_needs_update = false;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        if (visible_app_keys == last_known_visible_app_keys_) {
            return false;
        }

        last_known_visible_app_keys_ = visible_app_keys;

        std::string current_ime_pkg = sys_monitor_->get_current_ime_package();
        if (!current_ime_pkg.empty()) {
            last_known_visible_app_keys_.insert({current_ime_pkg, 0});
        }

        std::set<AppInstanceKey> prev_foreground_keys;
        for (const auto& [key, app] : managed_apps_) {
            if (app.is_foreground) prev_foreground_keys.insert(key);
        }

        const auto& final_foreground_keys = last_known_visible_app_keys_;

        time_t now = time(nullptr);
        for (auto& [key, app] : managed_apps_) {
            bool is_now_foreground = final_foreground_keys.count(key);
            if (app.is_foreground != is_now_foreground) {
                state_has_changed = true;
                app.is_foreground = is_now_foreground;

                if (is_now_foreground) {
                    app.has_logged_rogue_warning = false;
                    if (prev_foreground_keys.find(key) == prev_foreground_keys.end()) {
                         logger_->log(LogLevel::ACTION_OPEN, "打开", "已打开 (权威)", app.package_name, app.user_id);
                         app.last_foreground_timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                    }
                    if (unfreeze_and_observe_nolock(app, "切换至前台(权威)")) {
                        probe_config_needs_update = true;
                    }
                    app.observation_since = 0;
                    app.background_since = 0;
                    app.freeze_retry_count = 0;
                } else {
                     if (prev_foreground_keys.count(key) > 0) {
                        long long now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                        long long current_runtime_ms = (app.last_foreground_timestamp_ms > 0) ? (now_ms - app.last_foreground_timestamp_ms) : 0;
                        app.total_runtime_ms += current_runtime_ms;
                        long total_seconds = app.total_runtime_ms / 1000;
                        std::stringstream ss_msg;
                        ss_msg << "已关闭 [本次: " << (current_runtime_ms / 1000) << "s] [累计: "
                               << (total_seconds / 3600) << "h" << ((total_seconds % 3600) / 60) << "m" << (total_seconds % 60) << "s]";
                        logger_->log(LogLevel::ACTION_CLOSE, "关闭", ss_msg.str(), app.package_name, app.user_id);
                    }
                    if (app.current_status == AppRuntimeState::Status::RUNNING && (app.config.policy == AppPolicy::STANDARD || app.config.policy == AppPolicy::STRICT) && !app.pids.empty()) {
                        app.observation_since = now;
                    }
                }
            }
        }
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return state_has_changed;
}

bool StateManager::update_foreground_state_from_pids(const std::set<int>& top_pids) {
    bool state_has_changed = false;
    bool probe_config_needs_update = false;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);

        std::map<int, AppInstanceKey> pid_to_key_map;
        std::set<AppInstanceKey> top_app_keys;
        for (int pid : top_pids) {
            int uid = -1, user_id = -1;
            std::string pkg_name = get_package_name_from_pid(pid, uid, user_id);
            if (!pkg_name.empty() && user_id != -1) {
                AppInstanceKey key = {pkg_name, user_id};
                top_app_keys.insert(key);
                pid_to_key_map[pid] = key;
            }
        }

        std::string current_ime_pkg = sys_monitor_->get_current_ime_package();
        if (!current_ime_pkg.empty()) {
            top_app_keys.insert({current_ime_pkg, 0});
        }

        for (const auto& key : top_app_keys) {
            if (managed_apps_.find(key) == managed_apps_.end()) {
                LOGI("Discovered new top app via fast path: %s (user %d). Creating state...", key.first.c_str(), key.second);
                AppRuntimeState* new_app = get_or_create_app_state(key.first, key.second);
                if (new_app) {
                    for (const auto& [pid, mapped_key] : pid_to_key_map) {
                        if (mapped_key == key) {
                            int uid = -1, user_id_ignored = -1;
                            get_package_name_from_pid(pid, uid, user_id_ignored);
                            add_pid_to_app(pid, key.first, key.second, uid);
                        }
                    }
                    LOGI("State created and PIDs populated for new app %s.", key.first.c_str());
                    state_has_changed = true;
                }
            }
        }

        std::set<AppInstanceKey> prev_foreground_keys;
        for (const auto& [key, app] : managed_apps_) {
            if (app.is_foreground) prev_foreground_keys.insert(key);
        }

        if (top_app_keys == prev_foreground_keys && !state_has_changed) {
            return false;
        }

        const auto& final_foreground_keys = top_app_keys;
        
        time_t now = time(nullptr);
        for (auto& [key, app] : managed_apps_) {
            bool is_now_foreground = final_foreground_keys.count(key);
            if (app.is_foreground != is_now_foreground) {
                state_has_changed = true;
                app.is_foreground = is_now_foreground;

                if (is_now_foreground) {
                    app.has_logged_rogue_warning = false;
                    if (prev_foreground_keys.find(key) == prev_foreground_keys.end()) {
                         logger_->log(LogLevel::ACTION_OPEN, "打开", "已打开 (快速)", app.package_name, app.user_id);
                         app.last_foreground_timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                    }
                    if (unfreeze_and_observe_nolock(app, "切换至前台(快速)")) {
                        probe_config_needs_update = true;
                    }
                    app.observation_since = 0;
                    app.background_since = 0;
                    app.freeze_retry_count = 0;
                } else {
                     if (prev_foreground_keys.count(key) > 0) {
                        long long now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                        long long current_runtime_ms = (app.last_foreground_timestamp_ms > 0) ? (now_ms - app.last_foreground_timestamp_ms) : 0;
                        app.total_runtime_ms += current_runtime_ms;
                        long total_seconds = app.total_runtime_ms / 1000;
                        std::stringstream ss_msg;
                        ss_msg << "已关闭 [本次: " << (current_runtime_ms / 1000) << "s] [累计: "
                               << (total_seconds / 3600) << "h" << ((total_seconds % 3600) / 60) << "m" << (total_seconds % 60) << "s]";
                        logger_->log(LogLevel::ACTION_CLOSE, "关闭", ss_msg.str(), app.package_name, app.user_id);
                    }
                    if (app.current_status == AppRuntimeState::Status::RUNNING && (app.config.policy == AppPolicy::STANDARD || app.config.policy == AppPolicy::STRICT) && !app.pids.empty()) {
                        app.observation_since = now;
                    }
                }
            }
        }
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return state_has_changed;
}

void StateManager::on_app_foreground_event(const json& payload) {
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("EVENT: Received foreground event for %s (user %d), issuing refresh ticket.", package_name.c_str(), user_id);
        g_top_app_refresh_tickets = 1;

    } catch (const json::exception& e) {
        LOGE("Error processing foreground event: %s", e.what());
    }
}

void StateManager::on_app_background_event(const json& payload) {
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("EVENT: Received background event for %s (user %d), issuing refresh ticket.", package_name.c_str(), user_id);

        g_top_app_refresh_tickets = 1;

    } catch (const json::exception& e) {
        LOGE("Error processing background event: %s", e.what());
    }
}


void StateManager::on_proactive_unfreeze_request(const json& payload) {
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("PROACTIVE: Received unfreeze request for %s (user %d)", package_name.c_str(), user_id);

        std::lock_guard<std::mutex> lock(state_mutex_);
        AppInstanceKey key = {package_name, user_id};
        auto it = managed_apps_.find(key);
        if (it != managed_apps_.end()) {
            if (it->second.current_status == AppRuntimeState::Status::FROZEN) {
                 if(unfreeze_and_observe_nolock(it->second, "PROACTIVE_START", WakeupType::PROACTIVE_START)) {
                    broadcast_dashboard_update();
                    notify_probe_of_config_change();
                 }
            }
        }
    } catch (const json::exception& e) {
        LOGE("Error processing proactive unfreeze request: %s", e.what());
    }
}

void StateManager::on_wakeup_request(const json& payload) {
    bool state_changed = false;
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("Received wakeup request for %s (user %d)", package_name.c_str(), user_id);

        std::lock_guard<std::mutex> lock(state_mutex_);
        AppInstanceKey key = {package_name, user_id};
        auto it = managed_apps_.find(key);
        if (it != managed_apps_.end()) {
            state_changed = unfreeze_and_observe_nolock(it->second, "WAKEUP_REQUEST");
        } else {
            LOGW("Wakeup request for unknown app: %s", package_name.c_str());
        }
    } catch (const json::exception& e) {
        LOGE("Error processing wakeup request: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::on_temp_unfreeze_request_by_pkg(const json& payload) {
    bool state_changed = false;
    try {
        std::string package_name = payload.value("package_name", "");
        if (package_name.empty()) return;

        LOGD("Received temp unfreeze request by package: %s", package_name.c_str());

        std::lock_guard<std::mutex> lock(state_mutex_);
        bool app_found = false;
        for (auto& [key, app] : managed_apps_) {
            if (key.first == package_name) {
                app_found = true;
                if (unfreeze_and_observe_nolock(app, "FCM")) {
                    state_changed = true;
                }
            }
        }
        if (!app_found) {
            LOGW("Temp unfreeze request for unknown package: %s", package_name.c_str());
        }
    } catch (const json::exception& e) {
        LOGE("Error processing temp unfreeze by pkg: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::on_temp_unfreeze_request_by_uid(const json& payload) {
    bool state_changed = false;
    try {
        int uid = payload.value("uid", -1);
        if (uid < 0) return;

        LOGD("Received temp unfreeze request by UID: %d", uid);

        std::lock_guard<std::mutex> lock(state_mutex_);
        bool app_found = false;
        for (auto& [key, app] : managed_apps_) {
            if (app.uid == uid) {
                app_found = true;
                if (unfreeze_and_observe_nolock(app, "AUDIO_FOCUS", WakeupType::OTHER)) {
                    state_changed = true;
                }
                break;
            }
        }
        if(!app_found) {
            LOGW("Temp unfreeze request for unknown UID: %d", uid);
        }
    } catch (const json::exception& e) {
        LOGE("Error processing temp unfreeze by uid: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::on_temp_unfreeze_request_by_pid(const json& payload) {
    bool state_changed = false;
    try {
        int pid = payload.value("pid", -1);
        if (pid < 0) return;

        LOGD("Received temp unfreeze request by PID: %d", pid);

        std::lock_guard<std::mutex> lock(state_mutex_);
        auto it = pid_to_app_map_.find(pid);
        if (it != pid_to_app_map_.end()) {
            if (unfreeze_and_observe_nolock(*(it->second), "SIGKILL_PROTECT")) {
                state_changed = true;
            }
        } else {
            LOGW("Temp unfreeze request for unknown PID: %d", pid);
        }
    } catch (const json::exception& e) {
        LOGE("Error processing temp unfreeze by pid: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::update_master_config(const MasterConfig& config) {
    std::lock_guard<std::mutex> lock(state_mutex_);
    master_config_ = config;
    db_manager_->set_master_config(config);
    LOGI("Master config updated: standard_timeout=%ds, timed_unfreeze_enabled=%d, timed_unfreeze_interval=%ds",
        master_config_.standard_timeout_sec, master_config_.is_timed_unfreeze_enabled, master_config_.timed_unfreeze_interval_sec);
    logger_->log(LogLevel::EVENT, "配置", "核心配置已更新");
}

bool StateManager::tick_state_machine() {
    bool changed1 = check_timers();
    bool changed2 = check_timed_unfreeze();
    return changed1 || changed2;
}

bool StateManager::is_app_playing_audio(const AppRuntimeState& app) {
    return sys_monitor_->is_uid_playing_audio(app.uid);
}

bool StateManager::check_timers() {
    bool changed = false;
    bool probe_config_needs_update = false;
    const int MAX_FREEZE_RETRIES = 3;
    const int RETRY_DELAY_BASE_SEC = 5;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        time_t now = time(nullptr);
        const double NETWORK_THRESHOLD_KBPS = 50.0;

        for (auto& [key, app] : managed_apps_) {
            if (app.is_foreground || app.config.policy == AppPolicy::EXEMPTED || app.config.policy == AppPolicy::IMPORTANT) {
                if (app.observation_since > 0 || app.background_since > 0) {
                    app.observation_since = 0;
                    app.background_since = 0;
                    app.freeze_retry_count = 0;
                    changed = true;
                }
                continue;
            }

            if (app.observation_since > 0 && now - app.observation_since >= 10) {
                app.observation_since = 0;

                std::vector<std::string> active_reasons;
                if (is_app_playing_audio(app)) active_reasons.push_back("音频");
                if (sys_monitor_->is_uid_using_location(app.uid)) active_reasons.push_back("定位");
                if (sys_monitor_->get_cached_network_speed(app.uid).download_kbps > NETWORK_THRESHOLD_KBPS) active_reasons.push_back("网络");

                if (!active_reasons.empty()) {
                    std::string reason_str;
                    for (size_t i = 0; i < active_reasons.size(); ++i) {
                        reason_str += active_reasons[i] + (i < active_reasons.size() - 1 ? " / " : "");
                    }
                    std::string log_msg = "因 " + reason_str + " 活跃而推迟冻结";
                    logger_->log(LogLevel::ACTION_DELAY, "延迟", log_msg, app.package_name, app.user_id);
                    app.observation_since = now;
                    changed = true;
                    continue;
                }

                app.background_since = now;
                app.freeze_retry_count = 0;
                changed = true;
            }

            if (app.background_since > 0) {
                int timeout_sec = 0;
                if(app.config.policy == AppPolicy::STRICT) timeout_sec = 15;
                else if(app.config.policy == AppPolicy::STANDARD) timeout_sec = master_config_.standard_timeout_sec;
                if (app.freeze_retry_count > 0) timeout_sec += (RETRY_DELAY_BASE_SEC * app.freeze_retry_count);

                if (timeout_sec > 0 && (now - app.background_since >= timeout_sec)) {
                    size_t total_pids = app.pids.size();
                    std::vector<int> pids_to_freeze;
                    std::string strategy_log_msg;

                    if (app.has_rogue_structure) {
                        strategy_log_msg = "检测到流氓结构，执行“斩首行动”";
                        for (int pid : app.pids) {
                            if (pid != app.rogue_puppet_pid) {
                                pids_to_freeze.push_back(pid);
                            }
                        }
                    } else {
                        strategy_log_msg = "执行“常规打击”";
                        pids_to_freeze = app.pids;
                    }
                    size_t frozen_pids_count = pids_to_freeze.size();

                    logger_->log(LogLevel::INFO, "冻结", strategy_log_msg, app.package_name, app.user_id);
                    int freeze_result = action_executor_->freeze(key, pids_to_freeze);
                    
                    std::stringstream log_msg_ss;
                    log_msg_ss << "[" << frozen_pids_count << "/" << total_pids << "] ";

                    switch (freeze_result) {
                        case 0:
                            app.current_status = AppRuntimeState::Status::FROZEN;
                            app.freeze_method = AppRuntimeState::FreezeMethod::CGROUP;
                            log_msg_ss << "因后台超时被冻结 (Cgroup)";
                            logger_->log(LogLevel::ACTION_FREEZE, "冻结", log_msg_ss.str(), app.package_name, app.user_id);
                            schedule_timed_unfreeze(app);
                            probe_config_needs_update = true;
                            app.background_since = 0;
                            app.freeze_retry_count = 0;
                            break;
                        case 1:
                            app.current_status = AppRuntimeState::Status::FROZEN;
                            app.freeze_method = AppRuntimeState::FreezeMethod::SIG_STOP;
                            log_msg_ss << "因后台超时被冻结 (SIGSTOP)";
                            logger_->log(LogLevel::ACTION_FREEZE, "冻结", log_msg_ss.str(), app.package_name, app.user_id);
                            schedule_timed_unfreeze(app);
                            probe_config_needs_update = true;
                            app.background_since = 0;
                            app.freeze_retry_count = 0;
                            break;
                        case 2:
                            app.freeze_retry_count++;
                            if (app.freeze_retry_count > MAX_FREEZE_RETRIES) {
                                logger_->log(LogLevel::WARN, "冻结", "多次尝试冻结失败，已放弃", app.package_name, app.user_id);
                                app.background_since = 0;
                                app.freeze_retry_count = 0;
                            } else {
                                logger_->log(LogLevel::INFO, "冻结", "冻结遇到软失败，将重试", app.package_name, app.user_id);
                                app.background_since = now;
                            }
                            break;
                        default:
                             logger_->log(LogLevel::ERROR, "冻结", "冻结遇到致命错误，已中止", app.package_name, app.user_id);
                            app.background_since = 0;
                            app.freeze_retry_count = 0;
                            break;
                    }
                    changed = true;
                }
            }
        }
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return changed;
}

void StateManager::cancel_timed_unfreeze(AppRuntimeState& app) {
    if (app.scheduled_unfreeze_idx != -1) {
        if (app.scheduled_unfreeze_idx < unfrozen_timeline_.size()) {
            if (unfrozen_timeline_[app.scheduled_unfreeze_idx] == app.uid) {
                unfrozen_timeline_[app.scheduled_unfreeze_idx] = 0;
                LOGD("TIMELINE: Cancelled scheduled unfreeze for %s at index %d.", app.package_name.c_str(), app.scheduled_unfreeze_idx);
            }
        }
        app.scheduled_unfreeze_idx = -1;
    }
}

void StateManager::schedule_timed_unfreeze(AppRuntimeState& app) {
    if (!master_config_.is_timed_unfreeze_enabled || master_config_.timed_unfreeze_interval_sec <= 0 || app.uid < 0) {
        return;
    }
    cancel_timed_unfreeze(app);
    uint32_t future_index = (timeline_idx_ + master_config_.timed_unfreeze_interval_sec) % unfrozen_timeline_.size();
    for (size_t i = 0; i < unfrozen_timeline_.size(); ++i) {
        uint32_t current_index = (future_index + i) % unfrozen_timeline_.size();
        if (unfrozen_timeline_[current_index] == 0) {
            unfrozen_timeline_[current_index] = app.uid;
            app.scheduled_unfreeze_idx = current_index;
            LOGD("TIMELINE: Scheduled timed unfreeze for %s (uid %d) at index %u.", app.package_name.c_str(), app.uid, current_index);
            return;
        }
    }
    LOGW("TIMELINE: Could not find empty slot for %s. Timeline is full!", app.package_name.c_str());
}

bool StateManager::check_timed_unfreeze() {
    bool state_changed = false;
    int uid_to_unfreeze;
    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        timeline_idx_ = (timeline_idx_ + 1) % unfrozen_timeline_.size();
        uid_to_unfreeze = unfrozen_timeline_[timeline_idx_];
        if (uid_to_unfreeze == 0) return false;
        unfrozen_timeline_[timeline_idx_] = 0;
    }
    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        for (auto& [key, app] : managed_apps_) {
            if (app.uid == uid_to_unfreeze) {
                if (app.current_status == AppRuntimeState::Status::FROZEN && !app.is_foreground) {
                    LOGI("TIMELINE: Executing timed unfreeze for %s.", app.package_name.c_str());
                    logger_->log(LogLevel::TIMER, "定时器", "执行定时解冻", app.package_name, app.user_id);
                    if(unfreeze_and_observe_nolock(app, "定时器唤醒")) {
                       state_changed = true;
                    }
                }
                app.scheduled_unfreeze_idx = -1;
                break;
            }
        }
    }
    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
    return state_changed;
}

bool StateManager::perform_deep_scan() {
    bool changed = false;
    {
        std::lock_guard<std::mutex> lock(state_mutex_);

        changed = reconcile_process_state_full();

        time_t now = time(nullptr);

        for (auto& [key, app] : managed_apps_) {
            if (app.pids.empty() && app.current_status != AppRuntimeState::Status::STOPPED) {
                if (app.undetected_since == 0) {
                    app.undetected_since = now;
                } else if (now - app.undetected_since >= 3) {
                    if (app.current_status == AppRuntimeState::Status::FROZEN) {
                         LOGI("Frozen app %s no longer has active PIDs. Marking as STOPPED.", app.package_name.c_str());
                         cancel_timed_unfreeze(app);
                    }
                    app.current_status = AppRuntimeState::Status::STOPPED;
                    app.freeze_method = AppRuntimeState::FreezeMethod::NONE;
                    app.is_foreground = false;
                    app.background_since = 0;
                    app.observation_since = 0;
                    app.freeze_retry_count = 0;
                    app.mem_usage_kb = 0;
                    app.swap_usage_kb = 0;
                    app.cpu_usage_percent = 0.0f;
                    app.undetected_since = 0;
                    changed = true;
                }
            } else if (!app.pids.empty()) {
                app.undetected_since = 0;
            }
        }
    }
    return changed;
}

bool StateManager::on_config_changed_from_ui(const json& payload) {
    bool probe_config_needs_update = false;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        if (!payload.contains("policies")) return false;

        LOGI("Applying new configuration from UI...");
        db_manager_->clear_all_policies();

        for (const auto& policy_item : payload["policies"]) {
            AppConfig new_config;
            new_config.package_name = policy_item.value("package_name", "");
            new_config.user_id = policy_item.value("user_id", 0);
            new_config.policy = static_cast<AppPolicy>(policy_item.value("policy", 0));

            if (new_config.package_name.empty()) continue;
            db_manager_->set_app_config(new_config);

            AppRuntimeState* app = get_or_create_app_state(new_config.package_name, new_config.user_id);
            if (app) {
                bool policy_changed = app->config.policy != new_config.policy;
                app->config = new_config;

                if (policy_changed && app->current_status == AppRuntimeState::Status::FROZEN && (new_config.policy == AppPolicy::EXEMPTED || new_config.policy == AppPolicy::IMPORTANT)) {
                     if (unfreeze_and_observe_nolock(*app, "策略变更", WakeupType::OTHER)) {
                         probe_config_needs_update = true;
                     }
                }
            }
        }
        logger_->log(LogLevel::EVENT, "配置", "应用策略已从UI更新");
        LOGI("New configuration applied.");
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return true;
}

json StateManager::get_dashboard_payload() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    json payload;
    if (last_metrics_record_) {
        payload["global_stats"] = {
            {"total_cpu_usage_percent", last_metrics_record_->total_cpu_usage_percent},
            {"total_mem_kb", last_metrics_record_->mem_total_kb},
            {"avail_mem_kb", last_metrics_record_->mem_available_kb},
            {"swap_total_kb", last_metrics_record_->swap_total_kb},
            {"swap_free_kb", last_metrics_record_->swap_free_kb},
        };
    } else {
        payload["global_stats"] = json::object();
    }

    json apps_state = json::array();
    for (auto& [key, app] : managed_apps_) {
        if (app.pids.empty() && app.current_status == AppRuntimeState::Status::STOPPED) {
            continue;
        }
        json app_json;
        app_json["package_name"] = app.package_name;
        app_json["app_name"] = app.app_name;
        app_json["user_id"] = app.user_id;
        app_json["display_status"] = status_to_string(app, master_config_);
        app_json["mem_usage_kb"] = app.mem_usage_kb;
        app_json["swap_usage_kb"] = app.swap_usage_kb;
        app_json["cpu_usage_percent"] = app.cpu_usage_percent;
        app_json["is_whitelisted"] = app.config.policy == AppPolicy::EXEMPTED || app.config.policy == AppPolicy::IMPORTANT;
        app_json["is_foreground"] = app.is_foreground;
        if (app.current_status == AppRuntimeState::Status::RUNNING && !app.is_foreground) {
            if (is_app_playing_audio(app)) {
                app_json["exemption_reason"] = "PLAYING_AUDIO";
            }
        }
        apps_state.push_back(app_json);
    }
    payload["apps_runtime_state"] = apps_state;
    return payload;
}

json StateManager::get_full_config_for_ui() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    auto db_master_config = db_manager_->get_master_config().value_or(MasterConfig{});
    auto all_db_configs = db_manager_->get_all_app_configs();
    json response;
    response["master_config"] = {
        {"is_enabled", true},
        {"freeze_on_screen_off", true},
        {"standard_timeout_sec", db_master_config.standard_timeout_sec},
        {"is_timed_unfreeze_enabled", db_master_config.is_timed_unfreeze_enabled},
        {"timed_unfreeze_interval_sec", db_master_config.timed_unfreeze_interval_sec}
    };
    response["exempt_config"] = {{"exempt_foreground_services", true}};
    json policies = json::array();
    for (const auto& config : all_db_configs) {
        policies.push_back({
            {"package_name", config.package_name},
            {"user_id", config.user_id},
            {"policy", static_cast<int>(config.policy)}
        });
    }
    response["policies"] = policies;
    return response;
}

json StateManager::get_probe_config_payload() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    json payload = get_full_config_for_ui();
    json frozen_uids = json::array();
    json frozen_pids = json::array();

    for (const auto& [key, app] : managed_apps_) {
        if (app.current_status == AppRuntimeState::Status::FROZEN) {
            if (app.uid != -1) {
                frozen_uids.push_back(app.uid);
            }
            for (int pid : app.pids) {
                frozen_pids.push_back(pid);
            }
        }
    }
    payload["frozen_uids"] = frozen_uids;
    payload["frozen_pids"] = frozen_pids;
    return payload;
}

bool StateManager::reconcile_process_state_full() {
    bool changed = false;
    std::unordered_map<int, std::tuple<std::string, int, int>> current_pids;
    for (const auto& entry : fs::directory_iterator("/proc")) {
        if (!entry.is_directory()) continue;
        try {
            int pid = std::stoi(entry.path().filename().string());
            int uid = -1, user_id = -1;
            std::string pkg_name = get_package_name_from_pid(pid, uid, user_id);
            if (!pkg_name.empty()) {
                current_pids[pid] = {pkg_name, user_id, uid};
            }
        } catch (...) { continue; }
    }

    std::vector<int> dead_pids;
    for(const auto& [pid, app_ptr] : pid_to_app_map_) {
        if (current_pids.find(pid) == current_pids.end()) {
            dead_pids.push_back(pid);
        }
    }
    if (!dead_pids.empty()) {
        changed = true;
        for (int pid : dead_pids) remove_pid_from_app(pid);
    }

    for(const auto& [pid, info_tuple] : current_pids) {
        if (pid_to_app_map_.find(pid) == pid_to_app_map_.end()) {
            changed = true;
            const auto& [pkg_name, user_id, uid] = info_tuple;
            add_pid_to_app(pid, pkg_name, user_id, uid);
        }
    }
    return changed;
}

void StateManager::load_all_configs() {
    auto configs = db_manager_->get_all_app_configs();
    for (const auto& db_config : configs) {
        get_or_create_app_state(db_config.package_name, db_config.user_id);
    }
}

std::string StateManager::get_package_name_from_pid(int pid, int& uid, int& user_id) {
    constexpr int PER_USER_RANGE = 100000;
    uid = -1; user_id = -1;

    char path_buffer[64];
    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d", pid);
    struct stat st;
    if (stat(path_buffer, &st) != 0) return "";
    uid = st.st_uid;
    if (uid < 10000) return "";
    user_id = uid / PER_USER_RANGE;

    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d/cmdline", pid);
    std::ifstream cmdline_file(path_buffer);
    if (!cmdline_file.is_open()) return "";

    std::string cmdline;
    std::getline(cmdline_file, cmdline, '\0');

    if (cmdline.empty() || cmdline.find('.') == std::string::npos) {
        return "";
    }

    size_t colon_pos = cmdline.find(':');
    if (colon_pos != std::string::npos) {
        return cmdline.substr(0, colon_pos);
    }

    return cmdline;
}

AppRuntimeState* StateManager::get_or_create_app_state(const std::string& package_name, int user_id) {
    if (package_name.empty()) return nullptr;
    AppInstanceKey key = {package_name, user_id};
    auto it = managed_apps_.find(key);
    if (it != managed_apps_.end()) return &it->second;

    AppRuntimeState new_state;
    new_state.package_name = package_name;
    new_state.user_id = user_id;
    new_state.app_name = package_name;

    auto config_opt = db_manager_->get_app_config(package_name, user_id);
    if (config_opt) {
        new_state.config = *config_opt;
    } else {
        LOGI("New app instance discovered: %s (user %d). Creating default DB entry.", package_name.c_str(), user_id);
        if (is_critical_system_app(package_name)) {
            new_state.config = AppConfig{package_name, user_id, AppPolicy::EXEMPTED};
        } else {
            new_state.config = AppConfig{package_name, user_id, AppPolicy::EXEMPTED};
        }
        db_manager_->set_app_config(new_state.config);
    }

    new_state.current_status = AppRuntimeState::Status::STOPPED;
    auto [map_iterator, success] = managed_apps_.emplace(key, new_state);
    return &map_iterator->second;
}

void StateManager::add_pid_to_app(int pid, const std::string& package_name, int user_id, int uid) {
    AppRuntimeState* app = get_or_create_app_state(package_name, user_id);
    if (!app) return;
    if (app->uid == -1) app->uid = uid;

    if (app->app_name == app->package_name) {
        std::string friendly_name = sys_monitor_->get_app_name_from_pid(pid);
        if (!friendly_name.empty()) {
            size_t colon_pos = friendly_name.find(':');
            if (colon_pos != std::string::npos) {
                app->app_name = friendly_name.substr(0, colon_pos);
            } else {
                app->app_name = friendly_name;
            }
        }
    }

    if (std::find(app->pids.begin(), app->pids.end(), pid) == app->pids.end()) {
        app->pids.push_back(pid);
        pid_to_app_map_[pid] = app;
        if (app->current_status == AppRuntimeState::Status::STOPPED) {
           app->current_status = AppRuntimeState::Status::RUNNING;
           logger_->log(LogLevel::INFO, "进程", "检测到新进程启动", app->package_name, user_id);
        }
    }
}

void StateManager::remove_pid_from_app(int pid) {
    auto it = pid_to_app_map_.find(pid);
    if (it == pid_to_app_map_.end()) return;
    AppRuntimeState* app = it->second;
    pid_to_app_map_.erase(it);
    if (app) {
        auto& pids = app->pids;
        pids.erase(std::remove(pids.begin(), pids.end(), pid), pids.end());
        if (pids.empty()) {
            app->mem_usage_kb = 0;
            app->swap_usage_kb = 0;
            app->cpu_usage_percent = 0.0f;
            app->is_foreground = false;
            app->background_since = 0;
            app->observation_since = 0;
            app->freeze_retry_count = 0;
            app->undetected_since = 0;
            app->freeze_method = AppRuntimeState::FreezeMethod::NONE;
            cancel_timed_unfreeze(*app);
        }
    }
}

bool StateManager::is_critical_system_app(const std::string& package_name) const {
    return critical_system_apps_.count(package_name) > 0;
}
```

daemon/cpp/state_manager.h
```
// daemon/cpp/state_manager.h
#ifndef CERBERUS_STATE_MANAGER_H
#define CERBERUS_STATE_MANAGER_H

#include <nlohmann/json.hpp>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <mutex>
#include <unordered_set>
#include <set>
#include <chrono>
#include "database_manager.h"
#include "system_monitor.h"
#include "action_executor.h"
#include "logger.h"
#include "time_series_database.h"

using json = nlohmann::json;

enum class WakeupType {
    GENERIC_NOTIFICATION, // 普通通知，重冻时间较短
    FCM_PUSH,             // FCM推送，重冻时间较长
    PROACTIVE_START,      // 用户主动启动
    OTHER                 // 其他类型
};

struct AppRuntimeState {
    enum class Status {
        STOPPED,
        RUNNING,
        FROZEN
    } current_status = Status::STOPPED;

    enum class FreezeMethod {
        NONE,
        CGROUP,
        SIG_STOP
    } freeze_method = FreezeMethod::NONE;

    std::string package_name;
    std::string app_name;
    int uid = -1;
    int user_id = 0;
    std::vector<int> pids;
    AppConfig config;

    bool is_foreground = false;
    time_t background_since = 0;
    time_t observation_since = 0;
    time_t undetected_since = 0;
    int freeze_retry_count = 0;

    bool has_rogue_structure = false;
    int rogue_puppet_pid = -1;
    int rogue_master_pid = -1;

    bool has_logged_rogue_warning = false;

    int scheduled_unfreeze_idx = -1;

    float cpu_usage_percent = 0.0f;
    long mem_usage_kb = 0;
    long swap_usage_kb = 0;
    long long last_foreground_timestamp_ms = 0;
    long long total_runtime_ms = 0;
};

class DozeManager {
public:
    enum class State { AWAKE, IDLE, INACTIVE, DEEP_DOZE };
    enum class DozeEvent { NONE, ENTERED_DEEP_DOZE, EXITED_DEEP_DOZE };

    DozeManager(std::shared_ptr<Logger> logger, std::shared_ptr<ActionExecutor> executor);
    DozeEvent process_metrics(const MetricsRecord& record);

private:
    void enter_state(State new_state, const MetricsRecord& record);

    State current_state_ = State::AWAKE;
    std::chrono::steady_clock::time_point state_change_timestamp_;
    std::chrono::steady_clock::time_point deep_doze_start_time_;
    std::shared_ptr<Logger> logger_;
    std::shared_ptr<ActionExecutor> action_executor_;
};

// [核心重构] 为Doze报告增加一个专门的结构体
struct DozeProcessRecord {
    long long start_jiffies;
    std::string process_name;
    std::string package_name;
    int user_id;
};

class StateManager {
public:
    StateManager(std::shared_ptr<DatabaseManager>, std::shared_ptr<SystemMonitor>, std::shared_ptr<ActionExecutor>,
                 std::shared_ptr<Logger>, std::shared_ptr<TimeSeriesDatabase>);

    void initial_full_scan_and_warmup();
    bool evaluate_and_execute_strategy();
    bool handle_top_app_change_fast();
    void process_new_metrics(const MetricsRecord& record);
    bool tick_state_machine();
    bool perform_deep_scan();
    bool on_config_changed_from_ui(const json& payload);
    void update_master_config(const MasterConfig& config);
    json get_dashboard_payload();
    json get_full_config_for_ui();
    json get_probe_config_payload();
    void on_app_foreground_event(const json& payload);
    void on_app_background_event(const json& payload);
    void on_proactive_unfreeze_request(const json& payload);
    void on_wakeup_request(const json& payload);
    void on_temp_unfreeze_request_by_pkg(const json& payload);
    void on_temp_unfreeze_request_by_uid(const json& payload);
    void on_temp_unfreeze_request_by_pid(const json& payload);
    bool perform_staggered_stats_scan();
    void on_wakeup_request_from_probe(const json& payload);

private:
    void handle_charging_state_change(const MetricsRecord& old_record, const MetricsRecord& new_record);
    void generate_doze_exit_report();
    void analyze_battery_change(const MetricsRecord& old_record, const MetricsRecord& new_record);
    bool unfreeze_and_observe_nolock(AppRuntimeState& app, const std::string& reason, WakeupType wakeup_type = WakeupType::OTHER);
    bool reconcile_process_state_full();
    void load_all_configs();
    std::string get_package_name_from_pid(int pid, int& uid, int& user_id);
    void add_pid_to_app(int pid, const std::string&, int user_id, int uid);
    void remove_pid_from_app(int pid);
    AppRuntimeState* get_or_create_app_state(const std::string&, int user_id);
    bool is_critical_system_app(const std::string&) const;
    bool is_app_playing_audio(const AppRuntimeState& app);
    void schedule_timed_unfreeze(AppRuntimeState& app);
    bool check_timed_unfreeze();
    void cancel_timed_unfreeze(AppRuntimeState& app);
    bool check_timers();
    bool update_foreground_state_from_pids(const std::set<int>& top_pids);
    bool update_foreground_state(const std::set<AppInstanceKey>& visible_app_keys);
    void audit_app_structures(const std::map<int, ProcessInfo>& process_tree);

    std::shared_ptr<DatabaseManager> db_manager_;
    std::shared_ptr<SystemMonitor> sys_monitor_;
    std::shared_ptr<ActionExecutor> action_executor_;
    std::shared_ptr<Logger> logger_;
    std::shared_ptr<TimeSeriesDatabase> ts_db_;

    MasterConfig master_config_;
    std::unique_ptr<DozeManager> doze_manager_;
    std::mutex state_mutex_;
    std::set<AppInstanceKey> last_known_visible_app_keys_;
    std::optional<MetricsRecord> last_metrics_record_;
    std::optional<std::pair<int, long long>> last_battery_level_info_;
    uint32_t timeline_idx_ = 0;
    std::vector<int> unfrozen_timeline_;
    
    // [核心重构] 修改Doze数据结构，以PID为key
    std::map<int, DozeProcessRecord> doze_start_process_info_;

    std::map<AppInstanceKey, AppRuntimeState> managed_apps_;
    std::map<int, AppRuntimeState*> pid_to_app_map_;
    std::unordered_set<std::string> critical_system_apps_;
    std::map<AppInstanceKey, AppRuntimeState>::iterator next_scan_iterator_;
};

#endif //CERBERUS_STATE_MANAGER_H
```

daemon/cpp/system_monitor.cpp
```
// daemon/cpp/system_monitor.cpp
#include "system_monitor.h"
#include <fstream>
#include <sstream>
#include <android/log.h>
#include <unistd.h>
#include <filesystem>
#include <sys/inotify.h>
#include <sys/select.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <climits>
#include <vector>
#include <cstdio>
#include <array>
#include <cctype>
#include <ctime>
#include <algorithm>
#include <iterator>
#include <chrono>
#include <string>
#include <memory>
#include <map>
#include <unordered_set>
#include <numeric>

#define LOG_TAG "cerberusd_monitor_v32_multicore" // 版本号更新
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;

constexpr long long CACHE_DURATION_MS = 2000;

SystemMonitor::ProcFileReader::ProcFileReader(std::string path) : path_(std::move(path)) {}

SystemMonitor::ProcFileReader::~ProcFileReader() {
    if (fd_ != -1) {
        close(fd_);
    }
}

bool SystemMonitor::ProcFileReader::open_fd() {
    if (fd_ != -1) return true;
    fd_ = open(path_.c_str(), O_RDONLY | O_CLOEXEC);
    if (fd_ == -1) {
        // This can happen, not always an error worth logging loudly.
        return false;
    }
    return true;
}

bool SystemMonitor::ProcFileReader::read_contents(std::string& out_contents) {
    if (!open_fd()) return false;

    char buffer[4096];
    if (lseek(fd_, 0, SEEK_SET) != 0) {
        close(fd_);
        fd_ = -1;
        if (!open_fd()) return false;
    }
    
    ssize_t bytes_read = read(fd_, buffer, sizeof(buffer) - 1);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        out_contents = buffer;
        return true;
    }
    return false;
}

std::string SystemMonitor::read_file_once(const std::string& path, size_t max_size) {
    int fd = open(path.c_str(), O_RDONLY | O_CLOEXEC);
    if (fd == -1) return "";

    std::string content;
    content.resize(max_size);
    ssize_t bytes_read = read(fd, content.data(), max_size - 1);
    close(fd);

    if (bytes_read > 0) {
        content.resize(bytes_read);
        return content;
    }
    return "";
}

static std::optional<long> read_long_from_file_str(const std::string& content) {
    if (content.empty()) return std::nullopt;
    try {
        return std::stol(content);
    } catch (...) {
        return std::nullopt;
    }
}

std::string SystemMonitor::exec_shell_pipe_efficient(const std::vector<std::string>& args) {
    if (args.empty()) return "";

    int pipe_fd[2];
    if (pipe2(pipe_fd, O_CLOEXEC) == -1) {
        LOGE("pipe2 failed: %s", strerror(errno));
        return "";
    }

    pid_t pid = fork();
    if (pid == -1) {
        LOGE("fork failed: %s", strerror(errno));
        close(pipe_fd[0]);
        close(pipe_fd[1]);
        return "";
    }

    if (pid == 0) { 
        close(pipe_fd[0]); 
        dup2(pipe_fd[1], STDOUT_FILENO);
        close(pipe_fd[1]);
        
        std::vector<char*> c_args;
        for (const auto& arg : args) {
            c_args.push_back(const_cast<char*>(arg.c_str()));
        }
        c_args.push_back(nullptr);

        execvp(c_args[0], c_args.data());
        exit(127);
    }

    close(pipe_fd[1]);
    std::string result;
    result.reserve(65536);
    char buffer[4096];
    ssize_t count;

    while ((count = read(pipe_fd[0], buffer, sizeof(buffer))) > 0) {
        result.append(buffer, count);
    }
    close(pipe_fd[0]);

    int status;
    waitpid(pid, &status, 0);

    return result;
}

int get_uid_from_pid(int pid) {
    char path_buffer[64];
    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d", pid);
    struct stat st;
    if (stat(path_buffer, &st) != 0) return -1;
    return st.st_uid;
}

SystemMonitor::SystemMonitor() : proc_stat_reader_("/proc/stat") {
    if (fs::exists("/dev/cpuset/top-app/tasks")) {
        top_app_tasks_path_ = "/dev/cpuset/top-app/tasks";
    } else if (fs::exists("/dev/cpuset/top-app/cgroup.procs")) {
        top_app_tasks_path_ = "/dev/cpuset/top-app/cgroup.procs";
    } else {
        LOGE("Could not find top-app tasks file. Active monitoring disabled.");
    }

    MetricsRecord dummy_record;
    update_cpu_usage(dummy_record); // Initial call to populate prev times
    
    last_screen_state_check_time_ = {};
    last_visible_apps_check_time_ = {};
}

SystemMonitor::~SystemMonitor() {
    stop_top_app_monitor();
    stop_network_snapshot_thread();
}

std::optional<MetricsRecord> SystemMonitor::collect_current_metrics() {
    MetricsRecord record;
    record.timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();
    
    update_cpu_usage(record);
    update_mem_info(record.mem_total_kb, record.mem_available_kb, record.swap_total_kb, record.swap_free_kb);
    
    get_battery_stats(record.battery_level, record.battery_temp_celsius, record.battery_power_watt, record.is_charging);
    record.is_screen_on = get_screen_state();

    {
        std::lock_guard<std::mutex> lock(audio_uids_mutex_);
        record.is_audio_playing = !uids_playing_audio_.empty();
    }
    {
        std::lock_guard<std::mutex> lock(location_uids_mutex_);
        record.is_location_active = !uids_using_location_.empty();
    }

    return record;
}

// [核心修改] update_cpu_usage现在计算总的和每个核心的使用率
void SystemMonitor::update_cpu_usage(MetricsRecord& record) {
    std::string stat_content;
    if (!proc_stat_reader_.read_contents(stat_content) || stat_content.empty()) return;

    std::stringstream ss(stat_content);
    std::string line;
    std::vector<TotalCpuTimes> current_per_core_times;

    // Process total CPU (first line)
    std::getline(ss, line);
    std::string cpu_label;
    TotalCpuTimes current_total_times;
    std::stringstream total_ss(line);
    total_ss >> cpu_label >> current_total_times.user >> current_total_times.nice >> current_total_times.system >> current_total_times.idle
             >> current_total_times.iowait >> current_total_times.irq >> current_total_times.softirq >> current_total_times.steal;
    
    if (cpu_label == "cpu") {
        long long prev_total = prev_total_cpu_times_.total();
        long long current_total = current_total_times.total();
        long long delta_total = current_total - prev_total;
        if (delta_total > 0) {
            long long delta_idle = current_total_times.idle_total() - prev_total_cpu_times_.idle_total();
            float cpu_usage = 100.0f * static_cast<float>(delta_total - delta_idle) / static_cast<float>(delta_total);
            record.total_cpu_usage_percent = std::max(0.0f, std::min(100.0f, cpu_usage));
        } else {
            record.total_cpu_usage_percent = 0.0f;
        }
        prev_total_cpu_times_ = current_total_times;
    }

    // Process per-core CPUs
    while (std::getline(ss, line)) {
        if (line.rfind("cpu", 0) != 0) break; // Stop if not a cpu line
        std::stringstream core_ss(line);
        TotalCpuTimes core_times;
        core_ss >> cpu_label >> core_times.user >> core_times.nice >> core_times.system >> core_times.idle
                >> core_times.iowait >> core_times.irq >> core_times.softirq >> core_times.steal;
        current_per_core_times.push_back(core_times);
    }

    if (prev_per_core_cpu_times_.empty()) {
        LOGI("First CPU poll, found %zu cores. Storing initial values.", current_per_core_times.size());
        prev_per_core_cpu_times_ = current_per_core_times;
        record.per_core_cpu_usage.assign(current_per_core_times.size(), 0.0f);
        return;
    }

    size_t num_cores = std::min(prev_per_core_cpu_times_.size(), current_per_core_times.size());
    record.per_core_cpu_usage.resize(num_cores);

    for (size_t i = 0; i < num_cores; ++i) {
        const auto& prev = prev_per_core_cpu_times_[i];
        const auto& curr = current_per_core_times[i];
        long long delta_total = curr.total() - prev.total();
        if (delta_total > 0) {
            long long delta_idle = curr.idle_total() - prev.idle_total();
            float usage = 100.0f * static_cast<float>(delta_total - delta_idle) / static_cast<float>(delta_total);
            record.per_core_cpu_usage[i] = std::max(0.0f, std::min(100.0f, usage));
        } else {
            record.per_core_cpu_usage[i] = 0.0f;
        }
    }

    prev_per_core_cpu_times_ = current_per_core_times;
}

void SystemMonitor::update_mem_info(long& total, long& available, long& swap_total, long& swap_free) {
    std::string meminfo_content = read_file_once("/proc/meminfo");
    if (meminfo_content.empty()) return;

    std::stringstream ss(meminfo_content);
    std::string line;
    while (std::getline(ss, line)) {
        std::string key;
        long value;
        std::stringstream line_ss(line);
        line_ss >> key >> value;
        if (key == "MemTotal:") total = value;
        else if (key == "MemAvailable:") available = value;
        else if (key == "SwapTotal:") swap_total = value;
        else if (key == "SwapFree:") swap_free = value;
    }
}

void SystemMonitor::update_app_stats(const std::vector<int>& pids, long& total_mem_kb, long& total_swap_kb, float& total_cpu_percent) {
    total_mem_kb = 0;
    total_swap_kb = 0;
    total_cpu_percent = 0.0f;
    if (pids.empty()) return;

    for (int pid : pids) {
        std::string proc_path = "/proc/" + std::to_string(pid);
        if (!fs::exists(proc_path)) continue;
        
        std::string rollup_content = read_file_once(proc_path + "/smaps_rollup");
        if (!rollup_content.empty()) {
            std::stringstream ss(rollup_content);
            std::string line;
            while (std::getline(ss, line)) {
                std::stringstream line_ss(line);
                std::string key;
                long value;
                line_ss >> key >> value;
                if (key == "Pss:") total_mem_kb += value;
                else if (key == "Swap:") total_swap_kb += value;
            }
        }
        
        std::string stat_content = read_file_once(proc_path + "/stat");
        if (!stat_content.empty()) {
            std::stringstream ss(stat_content);
            std::string value;
            for(int i = 0; i < 13; ++i) ss >> value;
            long long utime, stime;
            ss >> utime >> stime;
            long long current_app_jiffies = utime + stime;
            long long current_total_jiffies;
            {
                std::lock_guard<std::mutex> lock(data_mutex_);
                current_total_jiffies = prev_total_cpu_times_.total();
            }
            auto& prev_times = app_cpu_times_[pid];
            if (prev_times.app_jiffies > 0 && prev_times.total_jiffies > 0) {
                long long app_delta = current_app_jiffies - prev_times.app_jiffies;
                long long total_delta = current_total_jiffies - prev_times.total_jiffies;
                if (total_delta > 0 && app_delta >= 0) {
                    total_cpu_percent += 100.0f * static_cast<float>(app_delta) / static_cast<float>(total_delta);
                }
            }
            prev_times.app_jiffies = current_app_jiffies;
            prev_times.total_jiffies = current_total_jiffies;
        }
    }
}
std::string SystemMonitor::get_app_name_from_pid(int pid) {
    std::string cmdline = read_file_once("/proc/" + std::to_string(pid) + "/cmdline");
    if (!cmdline.empty()) {
        size_t null_pos = cmdline.find('\0');
        if(null_pos != std::string::npos) cmdline.resize(null_pos);
        if(!cmdline.empty()) return cmdline;
    }
    std::string status_content = read_file_once("/proc/" + std::to_string(pid) + "/status");
    if (!status_content.empty()) {
        std::stringstream ss(status_content);
        std::string line;
        while (std::getline(ss, line)) {
            if (line.rfind("Name:", 0) == 0) {
                std::string name = line.substr(line.find(":") + 1);
                name.erase(0, name.find_first_not_of(" \t"));
                name.erase(name.find_last_not_of(" \t\n") + 1);
                return name;
            }
        }
    }
    return "Unknown";
}
long long SystemMonitor::get_total_cpu_jiffies_for_pids(const std::vector<int>& pids) {
    long long total_jiffies = 0;
    for (int pid : pids) {
        std::string stat_content = read_file_once(std::string("/proc/") + std::to_string(pid) + "/stat");
        if (!stat_content.empty()) {
            std::stringstream ss(stat_content);
            std::string value;
            for(int i = 0; i < 13; ++i) ss >> value;
            long long utime = 0, stime = 0;
            ss >> utime >> stime;
            total_jiffies += (utime + stime);
        }
    }
    return total_jiffies;
}
bool SystemMonitor::get_screen_state() {
    std::lock_guard<std::mutex> lock(screen_state_mutex_);
    auto now = std::chrono::steady_clock::now();
    auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_screen_state_check_time_).count();
    if (elapsed_ms < CACHE_DURATION_MS) {
        return cached_screen_on_state_;
    }
    LOGD("Screen state cache expired, executing dumpsys power...");
    last_screen_state_check_time_ = now;
    std::string result = exec_shell_pipe_efficient({"dumpsys", "power"});
    size_t pos = result.find("mWakefulness=");
    if(pos == std::string::npos) pos = result.find("mWakefulnessRaw=");
    if(pos != std::string::npos) {
        cached_screen_on_state_ = result.find("Awake", pos) != std::string::npos;
        return cached_screen_on_state_;
    }
    return cached_screen_on_state_;
}
void SystemMonitor::get_battery_stats(int& level, float& temp, float& power, bool& charging) {
    const std::string battery_path = "/sys/class/power_supply/battery/";
    const std::string bms_path = "/sys/class/power_supply/bms/";
    std::string final_path = fs::exists(battery_path) ? battery_path : (fs::exists(bms_path) ? bms_path : "");
    if (final_path.empty()) {
        level = -1; temp = 0.0f; power = 0.0f; charging = false;
        return;
    }
    level = read_long_from_file_str(read_file_once(final_path + "capacity")).value_or(-1);
    auto temp_raw = read_long_from_file_str(read_file_once(final_path + "temp"));
    if (temp_raw.has_value()) {
        temp = static_cast<float>(*temp_raw) / 10.0f;
    } else {
        temp = 0.0f;
    }
    auto current_now_ua = read_long_from_file_str(read_file_once(final_path + "current_now"));
    auto voltage_now_uv = read_long_from_file_str(read_file_once(final_path + "voltage_now"));
    if (current_now_ua.has_value() && voltage_now_uv.has_value()) {
        double current_a = static_cast<double>(*current_now_ua) / 1000.0;
        double voltage_v = static_cast<double>(*voltage_now_uv) / 1000000.0;
        power = static_cast<float>(std::abs(current_a * voltage_v));
    } else {
        power = 0.0f;
    }
    std::string status = read_file_once(final_path + "status");
    if(!status.empty()) {
        status.erase(status.find_last_not_of(" \n\r\t")+1);
        charging = (status == "Charging" || status == "Full");
    } else {
        charging = false;
    }
}
void SystemMonitor::start_top_app_monitor() {
    if (top_app_tasks_path_.empty()) return;
    monitoring_active_ = true;
    monitor_thread_ = std::thread(&SystemMonitor::top_app_monitor_thread, this);
    LOGI("Top-app monitor started for path: %s", top_app_tasks_path_.c_str());
}
void SystemMonitor::stop_top_app_monitor() {
    monitoring_active_ = false;
    if (monitor_thread_.joinable()) {
        monitor_thread_.join();
    }
}
std::set<int> SystemMonitor::read_top_app_pids() {
    std::set<int> pids;
    if (top_app_tasks_path_.empty()) return pids;
    std::string content = read_file_once(top_app_tasks_path_);
    if(content.empty()) return pids;
    std::stringstream ss(content);
    int pid;
    while (ss >> pid) {
        pids.insert(pid);
    }
    return pids;
}
void SystemMonitor::top_app_monitor_thread() {
    int fd = inotify_init1(IN_CLOEXEC);
    if (fd < 0) { LOGE("inotify_init1 failed: %s", strerror(errno)); return; }
    int wd = inotify_add_watch(fd, top_app_tasks_path_.c_str(), IN_CLOSE_WRITE | IN_OPEN | IN_MODIFY);
    if (wd < 0) { LOGE("inotify_add_watch failed for %s: %s", top_app_tasks_path_.c_str(), strerror(errno)); close(fd); return; }
    char buf[sizeof(struct inotify_event) + NAME_MAX + 1];
    while (monitoring_active_) {
        ssize_t len = read(fd, buf, sizeof(buf));
        if (!monitoring_active_) break;
        if (len < 0) {
            if (errno == EINTR) continue;
            break;
        }
        g_top_app_refresh_tickets = 2; 
    }
    inotify_rm_watch(fd, wd);
    close(fd);
    LOGI("Top-app monitor stopped.");
}
std::set<AppInstanceKey> SystemMonitor::get_visible_app_keys() {
    std::lock_guard<std::mutex> lock(visible_apps_mutex_);
    auto now = std::chrono::steady_clock::now();
    auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_visible_apps_check_time_).count();
    if (elapsed_ms < CACHE_DURATION_MS) {
        return cached_visible_app_keys_;
    }
    LOGD("Visible apps cache expired, executing dumpsys activity activities...");
    last_visible_apps_check_time_ = now;
    std::set<AppInstanceKey> visible_keys;
    std::string dumpsys_output = exec_shell_pipe_efficient({"dumpsys", "activity", "activities"});
    if (dumpsys_output.empty()) {
        cached_visible_app_keys_ = visible_keys;
        return visible_keys;
    }
    std::stringstream ss(dumpsys_output);
    std::string line;
    std::vector<std::string> lines;
    while(std::getline(ss, line)) {
        lines.push_back(line);
    }
    size_t start_index = (lines.size() > 15) ? (lines.size() - 15) : 0;
    for (size_t i = start_index; i < lines.size(); ++i) {
        const auto& current_line = lines[i];
        if (current_line.find("VisibleActivityProcess:") != std::string::npos) {
            std::stringstream line_ss(current_line);
            std::string token;
            while (line_ss >> token) {
                size_t u_pos = token.find("/u");
                if (u_pos != std::string::npos) {
                    try {
                        std::string package_name = token.substr(0, u_pos);
                        std::string user_part = token.substr(u_pos + 2);
                        size_t a_pos = user_part.find('a');
                        if (a_pos != std::string::npos) {
                            user_part = user_part.substr(0, a_pos);
                        }
                        int user_id = std::stoi(user_part);
                        visible_keys.insert({package_name, user_id});
                    } catch (...) { /* ignore parse errors */ }
                }
            }
            break;
        }
    }
    cached_visible_app_keys_ = visible_keys;
    return visible_keys;
}
std::map<int, ProcessInfo> SystemMonitor::get_full_process_tree() {
    std::map<int, ProcessInfo> process_map;
    constexpr int PER_USER_RANGE = 100000;
    for (const auto& entry : fs::directory_iterator("/proc")) {
        if (!entry.is_directory()) continue;
        int pid = 0;
        try {
            pid = std::stoi(entry.path().filename().string());
        } catch (...) { continue; }
        char path_buffer[256];
        snprintf(path_buffer, sizeof(path_buffer), "/proc/%d", pid);
        struct stat st;
        if (stat(path_buffer, &st) != 0 || st.st_uid < 10000) continue;
        ProcessInfo info;
        info.pid = pid;
        info.uid = st.st_uid;
        info.user_id = info.uid / PER_USER_RANGE;
        std::string stat_content = read_file_once(std::string("/proc/") + std::to_string(pid) + "/stat");
        if (!stat_content.empty()) {
            std::stringstream stat_ss(stat_content);
            std::string s;
            stat_ss >> s >> s >> s >> info.ppid;
        }
        info.oom_score_adj = read_long_from_file_str(read_file_once(std::string("/proc/") + std::to_string(pid) + "/oom_score_adj")).value_or(1001);
        info.pkg_name = read_file_once(std::string("/proc/") + std::to_string(pid) + "/cmdline");
        size_t null_pos = info.pkg_name.find('\0');
        if(null_pos != std::string::npos) info.pkg_name.resize(null_pos);
        if (!info.pkg_name.empty() && info.pkg_name.find('.') != std::string::npos) {
           size_t colon_pos = info.pkg_name.find(':');
           if (colon_pos != std::string::npos) {
               info.pkg_name = info.pkg_name.substr(0, colon_pos);
           }
           process_map[pid] = info;
        }
    }
    return process_map;
}
void SystemMonitor::update_audio_state() {
    std::map<int, std::vector<int>> uid_session_states;
    std::unordered_set<std::string> ignored_usages = {"USAGE_ASSISTANCE_SONIFICATION", "USAGE_TOUCH_INTERACTION_RESPONSE"};
    std::string dumpsys_output = exec_shell_pipe_efficient({"dumpsys", "audio"});
    std::stringstream ss(dumpsys_output);
    std::string line;
    bool in_players_section = false;
    while (std::getline(ss, line)) {
        if (!in_players_section) {
            if (line.find("players:") != std::string::npos) {
                in_players_section = true;
            }
            continue;
        }
        if (line.find("ducked players piids:") != std::string::npos) {
            break;
        }
        if (line.find("AudioPlaybackConfiguration") != std::string::npos) {
            try {
                bool is_ignored = false;
                for (const auto& usage : ignored_usages) {
                    if (line.find(usage) != std::string::npos) {
                        is_ignored = true;
                        break;
                    }
                }
                if (is_ignored) continue;
                int uid = -1;
                size_t upid_pos = line.find("u/pid:");
                if (upid_pos != std::string::npos) {
                    std::stringstream line_ss(line.substr(upid_pos + 6));
                    line_ss >> uid;
                }
                if (uid < 10000) continue;
                size_t state_pos = line.find(" state:");
                if (state_pos != std::string::npos) {
                    std::string state_str = line.substr(state_pos + 7);
                    if (state_str.rfind("started", 0) == 0) {
                        uid_session_states[uid].push_back(1);
                    } else if (state_str.rfind("paused", 0) == 0) {
                        uid_session_states[uid].push_back(0);
                    }
                }
            } catch (...) {}
        }
    }
    std::set<int> active_uids;
    for (const auto& [uid, states] : uid_session_states) {
        if (states.empty()) continue;
        int product = std::accumulate(states.begin(), states.end(), 1, std::multiplies<int>());
        if (product == 1) {
            active_uids.insert(uid);
        }
    }
    {
        std::lock_guard<std::mutex> lock(audio_uids_mutex_);
        if (uids_playing_audio_ != active_uids) {
            LOGI("Active audio UIDs changed. Old count: %zu, New count: %zu.", uids_playing_audio_.size(), active_uids.size());
            uids_playing_audio_ = active_uids;
        }
    }
}
bool SystemMonitor::is_uid_playing_audio(int uid) {
    std::lock_guard<std::mutex> lock(audio_uids_mutex_);
    return uids_playing_audio_.count(uid) > 0;
}
void SystemMonitor::start_network_snapshot_thread() {
    if (network_monitoring_active_) return;
    network_monitoring_active_ = true;
    {
        std::lock_guard<std::mutex> lock(traffic_mutex_);
        last_traffic_snapshot_ = read_current_traffic();
        last_snapshot_time_ = std::chrono::steady_clock::now();
    }
    network_thread_ = std::thread(&SystemMonitor::network_snapshot_thread_func, this);
    LOGI("Network snapshot thread started.");
}
void SystemMonitor::stop_network_snapshot_thread() {
    network_monitoring_active_ = false;
    if (network_thread_.joinable()) {
        network_thread_.join();
    }
}
void SystemMonitor::network_snapshot_thread_func() {
    while (network_monitoring_active_) {
        std::this_thread::sleep_for(std::chrono::seconds(5));
        if (!network_monitoring_active_) break;
        auto current_snapshot = read_current_traffic();
        auto current_time = std::chrono::steady_clock::now();
        std::map<int, TrafficStats> last_snapshot;
        std::chrono::steady_clock::time_point last_time;
        {
            std::lock_guard<std::mutex> lock(traffic_mutex_);
            last_snapshot = last_traffic_snapshot_;
            last_time = last_snapshot_time_;
        }
        double time_delta_sec = std::chrono::duration_cast<std::chrono::duration<double>>(current_time - last_time).count();
        if (time_delta_sec < 0.1) continue;
        {
            std::lock_guard<std::mutex> lock(speed_mutex_);
            const double DECAY_FACTOR = 0.5;
            for (auto& [uid, speed] : uid_network_speed_) {
                speed.download_kbps *= DECAY_FACTOR;
                speed.upload_kbps *= DECAY_FACTOR;
                if (speed.download_kbps < 0.1) speed.download_kbps = 0.0;
                if (speed.upload_kbps < 0.1) speed.upload_kbps = 0.0;
            }
            for (const auto& [uid, current_stats] : current_snapshot) {
                auto last_it = last_snapshot.find(uid);
                if (last_it != last_snapshot.end()) {
                    long long rx_delta = (current_stats.rx_bytes > last_it->second.rx_bytes) ? (current_stats.rx_bytes - last_it->second.rx_bytes) : 0;
                    long long tx_delta = (current_stats.tx_bytes > last_it->second.tx_bytes) ? (current_stats.tx_bytes - last_it->second.tx_bytes) : 0;
                    if (rx_delta > 0 || tx_delta > 0) {
                        uid_network_speed_[uid] = {
                            .download_kbps = (static_cast<double>(rx_delta) / 1024.0) / time_delta_sec,
                            .upload_kbps = (static_cast<double>(tx_delta) / 1024.0) / time_delta_sec
                        };
                    }
                }
            }
        }
        {
            std::lock_guard<std::mutex> lock(traffic_mutex_);
            last_traffic_snapshot_ = current_snapshot;
            last_snapshot_time_ = current_time;
        }
    }
    LOGI("Network snapshot thread stopped.");
}
NetworkSpeed SystemMonitor::get_cached_network_speed(int uid) {
    std::lock_guard<std::mutex> lock(speed_mutex_);
    auto it = uid_network_speed_.find(uid);
    if (it != uid_network_speed_.end()) {
        return it->second;
    }
    return NetworkSpeed();
}
std::map<int, TrafficStats> SystemMonitor::read_current_traffic() {
    std::map<int, TrafficStats> snapshot;
    const std::string qtaguid_path = "/proc/net/xt_qtaguid/stats";
    std::string qtaguid_content = read_file_once(qtaguid_path, 256 * 1024);
    if (!qtaguid_content.empty()) {
        std::stringstream ss(qtaguid_content);
        std::string line;
        std::getline(ss, line);
        while (std::getline(ss, line)) {
            std::stringstream line_ss(line);
            std::string idx, iface, acct_tag, set;
            int uid, cnt_set, protocol;
            long long rx_bytes, rx_packets, tx_bytes, tx_packets;
            line_ss >> idx >> iface >> acct_tag >> uid >> cnt_set >> set >> protocol >> rx_bytes >> rx_packets >> tx_bytes >> tx_packets;
            if (uid >= 10000) {
                snapshot[uid].rx_bytes += rx_bytes;
                snapshot[uid].tx_bytes += tx_bytes;
            }
        }
        if (!snapshot.empty()) {
            return snapshot;
        }
    }
    std::string result = exec_shell_pipe_efficient({"dumpsys", "netstats"});
    std::stringstream ss(result);
    std::string line;
    enum class ParseState { searching, in_mTun, in_mStatsFactory };
    ParseState state = ParseState::searching;
    while (std::getline(ss, line)) {
        if (state == ParseState::searching) {
            if (line.find("mTunAnd464xlatAdjustedStats ") != std::string::npos) {
                state = ParseState::in_mTun;
                continue;
            } else if (line.find("mStatsFactory:") != std::string::npos) {
                state = ParseState::in_mStatsFactory;
                continue;
            }
        }
        if (state == ParseState::in_mStatsFactory || state == ParseState::in_mTun) {
            if (line.find(" uid=") != std::string::npos && line.find(" rxBytes=") != std::string::npos) {
                try {
                    int uid = -1;
                    long long rx = -1, tx = -1;
                    std::string part;
                    std::stringstream line_ss(line);
                    while (line_ss >> part && part.find("uid=") == std::string::npos);
                    if (part.find("uid=") == 0) {
                        uid = std::stoi(part.substr(4));
                        while (line_ss >> part && part.find("rxBytes=") == std::string::npos);
                        if(part.find("rxBytes=") == 0) rx = std::stoll(part.substr(8));
                        while (line_ss >> part && part.find("txBytes=") == std::string::npos);
                        if(part.find("txBytes=") == 0) tx = std::stoll(part.substr(8));
                        if (uid >= 10000 && rx != -1 && tx != -1) {
                            snapshot[uid].rx_bytes += rx;
                            snapshot[uid].tx_bytes += tx;
                        }
                    }
                } catch (const std::exception& e) {}
            }
        }
    }
    if (snapshot.empty()) {
        LOGW("Both /proc and dumpsys netstats parsing failed to get any traffic data.");
    }
    return snapshot;
}
std::string SystemMonitor::get_current_ime_package() {
    std::lock_guard<std::mutex> lock(ime_mutex_);
    time_t now = time(nullptr);
    if (now - last_ime_check_time_ > 60 || current_ime_package_.empty()) {
        std::string result = exec_shell_pipe_efficient({"settings", "get", "secure", "default_input_method"});
        size_t slash_pos = result.find('/');
        if (slash_pos != std::string::npos) {
            current_ime_package_ = result.substr(0, slash_pos);
        } else {
            result.erase(std::remove(result.begin(), result.end(), '\n'), result.end());
            current_ime_package_ = result;
        }
        last_ime_check_time_ = now;
        LOGD("Checked default IME: '%s'", current_ime_package_.c_str());
    }
    return current_ime_package_;
}
void SystemMonitor::update_location_state() {
    std::set<int> active_uids;
    std::string result = exec_shell_pipe_efficient({"dumpsys", "location"});
    std::stringstream ss(result);
    std::string line;
    bool in_gps_provider_section = false;
    while (std::getline(ss, line)) {
        if (!in_gps_provider_section) {
            if (line.find("gps provider:") != std::string::npos) {
                in_gps_provider_section = true;
                if (line.find("[OFF]") != std::string::npos) {
                    in_gps_provider_section = false; 
                }
            }
            continue;
        }
        if (line.find("user 0:") != std::string::npos) {
            in_gps_provider_section = false;
            continue;
        }
        size_t ws_pos = line.find("WorkSource{");
        if (ws_pos != std::string::npos) {
            try {
                std::string ws_content = line.substr(ws_pos + 11);
                std::stringstream ws_ss(ws_content);
                int uid = -1;
                ws_ss >> uid;
                if (uid >= 10000) {
                    active_uids.insert(uid);
                }
            } catch (const std::exception& e) {
                 LOGW("Failed to parse WorkSource line: %s", line.c_str());
            }
        }
    }
    {
        std::lock_guard<std::mutex> lock(location_uids_mutex_);
        if (uids_using_location_ != active_uids) {
            std::stringstream log_ss;
            for(int uid : active_uids) { log_ss << uid << " "; }
            LOGI("Active location UIDs changed (gps provider policy). Old count: %zu, New count: %zu. Active UIDs: [ %s]", uids_using_location_.size(), active_uids.size(), log_ss.str().c_str());
            uids_using_location_ = active_uids;
        }
    }
}
bool SystemMonitor::is_uid_using_location(int uid) {
    std::lock_guard<std::mutex> lock(location_uids_mutex_);
    return uids_using_location_.count(uid) > 0;
}
int SystemMonitor::get_pid_from_pkg(const std::string& pkg_name) {
    for (const auto& entry : fs::directory_iterator("/proc")) {
        if (!entry.is_directory()) continue;
        try {
            int pid = std::stoi(entry.path().filename().string());
            std::string cmdline = read_file_once(std::string("/proc/") + std::to_string(pid) + "/cmdline");
            if (cmdline.rfind(pkg_name, 0) == 0) {
                return pid;
            }
        } catch (...) { continue; }
    }
    return -1;
}
```

daemon/cpp/system_monitor.h
```
// daemon/cpp/system_monitor.h
#ifndef CERBERUS_SYSTEM_MONITOR_H
#define CERBERUS_SYSTEM_MONITOR_H

#include "time_series_database.h"
#include <string>
#include <mutex>
#include <map>
#include <vector>
#include <set>
#include <thread>
#include <atomic>
#include <functional>
#include <optional>
#include <utility>
#include <chrono>

using AppInstanceKey = std::pair<std::string, int>;

struct CpuTimeSlice {
    long long app_jiffies = 0;
    long long total_jiffies = 0;
};

struct NetworkSpeed {
    double download_kbps = 0.0;
    double upload_kbps = 0.0;
};

struct TrafficStats {
    long long rx_bytes = 0;
    long long tx_bytes = 0;
};

struct ProcessInfo {
    int pid = 0;
    int ppid = 0;
    int oom_score_adj = 1001;
    std::string pkg_name;
    int user_id = -1;
    int uid = -1;
};

extern std::atomic<int> g_top_app_refresh_tickets;

class SystemMonitor {
public:
    SystemMonitor();
    ~SystemMonitor();

    std::optional<MetricsRecord> collect_current_metrics();

    void update_app_stats(const std::vector<int>& pids, long& mem_kb, long& swap_kb, float& cpu_percent);
    std::string get_app_name_from_pid(int pid);

    long long get_total_cpu_jiffies_for_pids(const std::vector<int>& pids);

    void start_top_app_monitor();
    void stop_top_app_monitor();
    std::set<int> read_top_app_pids();

    std::set<AppInstanceKey> get_visible_app_keys();
    std::map<int, ProcessInfo> get_full_process_tree();

    void update_audio_state();
    bool is_uid_playing_audio(int uid);

    void update_location_state();
    bool is_uid_using_location(int uid);

    std::string get_current_ime_package();

    void start_network_snapshot_thread();
    void stop_network_snapshot_thread();
    NetworkSpeed get_cached_network_speed(int uid);

private:
    class ProcFileReader {
    public:
        ProcFileReader(std::string path);
        ~ProcFileReader();
        bool read_contents(std::string& out_contents);

    private:
        int fd_ = -1;
        std::string path_;
        bool open_fd();
    };

    std::string exec_shell_pipe_efficient(const std::vector<std::string>& args);
    static std::string read_file_once(const std::string& path, size_t max_size = 4096);

    // [核心修改] update_cpu_usage 现在填充 MetricsRecord
    void update_cpu_usage(MetricsRecord& record);
    void update_mem_info(long& total, long& available, long& swap_total, long& swap_free);
    bool get_screen_state();
    void get_battery_stats(int& level, float& temp, float& power, bool& charging);

    int get_pid_from_pkg(const std::string& pkg_name);

    void top_app_monitor_thread();

    struct TotalCpuTimes {
        long long user = 0, nice = 0, system = 0, idle = 0;
        long long iowait = 0, irq = 0, softirq = 0, steal = 0;
        long long total() const { return user + nice + system + idle + iowait + irq + softirq + steal; }
        long long idle_total() const { return idle + iowait; }
    };

    mutable std::mutex data_mutex_;
    // [核心修改] 存储上一次总CPU和每个核心的CPU时间
    TotalCpuTimes prev_total_cpu_times_;
    std::vector<TotalCpuTimes> prev_per_core_cpu_times_;
    std::map<int, CpuTimeSlice> app_cpu_times_;

    ProcFileReader proc_stat_reader_;

    std::set<int> last_known_top_pids_;
    std::thread monitor_thread_;
    std::atomic<bool> monitoring_active_{false};
    std::string top_app_tasks_path_;

    std::mutex audio_uids_mutex_;
    std::set<int> uids_playing_audio_;

    mutable std::mutex location_uids_mutex_;
    std::set<int> uids_using_location_;

    mutable std::mutex ime_mutex_;
    std::string current_ime_package_;
    time_t last_ime_check_time_ = 0;

    mutable std::mutex screen_state_mutex_;
    std::chrono::steady_clock::time_point last_screen_state_check_time_;
    bool cached_screen_on_state_ = true;

    mutable std::mutex visible_apps_mutex_;
    std::chrono::steady_clock::time_point last_visible_apps_check_time_;
    std::set<AppInstanceKey> cached_visible_app_keys_;

    void network_snapshot_thread_func();
    std::map<int, TrafficStats> read_current_traffic();

    std::thread network_thread_;
    std::atomic<bool> network_monitoring_active_{false};
    mutable std::mutex traffic_mutex_;
    std::map<int, TrafficStats> last_traffic_snapshot_;
    std::chrono::steady_clock::time_point last_snapshot_time_;
    mutable std::mutex speed_mutex_;
    std::map<int, NetworkSpeed> uid_network_speed_;
};

#endif //CERBERUS_SYSTEM_MONITOR_H
```

daemon/cpp/time_series_database.cpp
```
// daemon/cpp/time_series_database.cpp
#include "time_series_database.h"
#include "uds_server.h"

extern std::unique_ptr<UdsServer> g_server;

std::shared_ptr<TimeSeriesDatabase> TimeSeriesDatabase::instance_ = nullptr;
std::mutex TimeSeriesDatabase::instance_mutex_;

json MetricsRecord::to_json() const {
    return json{
        {"timestamp", timestamp_ms},
        // [核心修改] 字段重命名以保持一致
        {"cpu_usage_percent", total_cpu_usage_percent},
        // [核心新增] 序列化每核心使用率
        {"per_core_cpu_usage_percent", per_core_cpu_usage},
        {"mem_total_kb", mem_total_kb},
        {"mem_available_kb", mem_available_kb},
        {"swap_total_kb", swap_total_kb},
        {"swap_free_kb", swap_free_kb},
        {"battery_level", battery_level},
        {"battery_temp_celsius", battery_temp_celsius},
        {"battery_power_watt", battery_power_watt},
        {"is_charging", is_charging},
        {"is_screen_on", is_screen_on},
        {"is_audio_playing", is_audio_playing},
        {"is_location_active", is_location_active}
    };
}

std::shared_ptr<TimeSeriesDatabase> TimeSeriesDatabase::get_instance(size_t max_size) {
    std::lock_guard<std::mutex> lock(instance_mutex_);
    if (!instance_) {
        struct make_shared_enabler : public TimeSeriesDatabase {
            make_shared_enabler(size_t size) : TimeSeriesDatabase(size) {}
        };
        instance_ = std::make_shared<make_shared_enabler>(max_size);
    }
    return instance_;
}

TimeSeriesDatabase::TimeSeriesDatabase(size_t max_size) : max_size_(max_size) {}

void TimeSeriesDatabase::add_record(const MetricsRecord& record) {
    {
        std::lock_guard<std::mutex> lock(db_mutex_);
        if (records_.size() >= max_size_) {
            records_.pop_front();
        }
        records_.push_back(record);
    }
    
    if (g_server) {
        g_server->broadcast_message(json{
            {"type", "stream.new_stats_record"},
            {"payload", record.to_json()}
        }.dump());
    }
}

std::vector<MetricsRecord> TimeSeriesDatabase::get_records_since(long long timestamp_ms) const {
    std::vector<MetricsRecord> result;
    std::lock_guard<std::mutex> lock(db_mutex_);
    for (const auto& record : records_) {
        if (record.timestamp_ms >= timestamp_ms) {
            result.push_back(record);
        }
    }
    return result;
}

std::vector<MetricsRecord> TimeSeriesDatabase::get_all_records() const {
    std::lock_guard<std::mutex> lock(db_mutex_);
    return std::vector<MetricsRecord>(records_.begin(), records_.end());
}

std::optional<MetricsRecord> TimeSeriesDatabase::get_latest_record() const {
    std::lock_guard<std::mutex> lock(db_mutex_);
    if (records_.empty()) {
        return std::nullopt;
    }
    return records_.back();
}
```

daemon/cpp/time_series_database.h
```
// daemon/cpp/time_series_database.h
#ifndef CERBERUS_TIME_SERIES_DATABASE_H
#define CERBERUS_TIME_SERIES_DATABASE_H

#include <vector>
#include <deque>
#include <mutex>
#include <chrono>
#include <nlohmann/json.hpp>
#include <memory>
#include <optional>

using json = nlohmann::json;

struct MetricsRecord {
    long long timestamp_ms;
    // [核心修改] total_cpu_usage_percent 用于仪表盘和旧逻辑
    float total_cpu_usage_percent = 0.0f; 
    // [核心新增] per_core_cpu_usage 用于新的统计图表
    std::vector<float> per_core_cpu_usage; 
    long mem_total_kb = 0;
    long mem_available_kb = 0;
    long swap_total_kb = 0;
    long swap_free_kb = 0;
    int battery_level = -1;
    float battery_temp_celsius = 0.0f;
    float battery_power_watt = 0.0f;
    bool is_charging = false;
    bool is_screen_on = true;
    bool is_audio_playing = false;
    bool is_location_active = false;

    json to_json() const;
};

class TimeSeriesDatabase : public std::enable_shared_from_this<TimeSeriesDatabase> {
public:
    static std::shared_ptr<TimeSeriesDatabase> get_instance(size_t max_size = 900);
    ~TimeSeriesDatabase() = default;

    TimeSeriesDatabase(const TimeSeriesDatabase&) = delete;
    TimeSeriesDatabase& operator=(const TimeSeriesDatabase&) = delete;

    void add_record(const MetricsRecord& record);
    std::vector<MetricsRecord> get_records_since(long long timestamp_ms) const;
    std::vector<MetricsRecord> get_all_records() const;
    std::optional<MetricsRecord> get_latest_record() const;

private:
    explicit TimeSeriesDatabase(size_t max_size);

    static std::shared_ptr<TimeSeriesDatabase> instance_;
    static std::mutex instance_mutex_;

    size_t max_size_;
    std::deque<MetricsRecord> records_;
    mutable std::mutex db_mutex_;
};

#endif // CERBERUS_TIME_SERIES_DATABASE_H
```

daemon/cpp/uds_server.cpp
```
// daemon/cpp/uds_server.cpp
#include "uds_server.h"
#include <android/log.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h> // [新增] For TCP_NODELAY
#include <arpa/inet.h>
#include <unistd.h>
#include <cerrno>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cstddef>
#include <sys/select.h>
#include <thread>

#define LOG_TAG "cerberusd_tcp_v3_nodelay" // 版本号更新
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

UdsServer::UdsServer(int port)
    : port_(port), server_fd_(-1), is_running_(false) {}

UdsServer::~UdsServer() {
    stop();
}

void UdsServer::set_message_handler(std::function<void(int, const std::string&)> handler) {
    on_message_received_ = std::move(handler);
}

void UdsServer::set_disconnect_handler(std::function<void(int)> handler) {
    on_disconnect_ = std::move(handler);
}

void UdsServer::identify_client_as_ui(int client_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    LOGI("Client fd %d identified as UI.", client_fd);
    ui_client_fds_.insert(client_fd);
}

void UdsServer::broadcast_message_to_ui(const std::string& message) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    if (ui_client_fds_.empty()) return;

    auto ui_clients_copy = ui_client_fds_;
    for (int fd : ui_clients_copy) {
        send_message(fd, message);
    }
}

bool UdsServer::has_clients() const {
    std::lock_guard<std::mutex> lock(client_mutex_);
    return !client_fds_.empty();
}

void UdsServer::add_client(int client_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    client_fds_.push_back(client_fd);
    client_buffers_[client_fd] = "";
    LOGI("Client connected, fd: %d. Total clients: %zu", client_fd, client_fds_.size());
}

void UdsServer::remove_client(int client_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    auto it = std::remove(client_fds_.begin(), client_fds_.end(), client_fd);
    if (it != client_fds_.end()) {
        client_fds_.erase(it, client_fds_.end());
        client_buffers_.erase(client_fd);
        ui_client_fds_.erase(client_fd);
        close(client_fd);
        LOGI("Client disconnected, fd: %d. Total clients: %zu, UI clients: %zu", client_fd, client_fds_.size(), ui_client_fds_.size());
        if (on_disconnect_) {
            on_disconnect_(client_fd);
        }
    }
}

void UdsServer::broadcast_message_except(const std::string& message, int excluded_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    if (client_fds_.empty()) return;

    auto clients_copy = client_fds_;
    for (int fd : clients_copy) {
        if (fd != excluded_fd) {
            send_message(fd, message);
        }
    }
}

bool UdsServer::send_message(int client_fd, const std::string& message) {
    std::string line = message + "\n";
    ssize_t bytes_sent = send(client_fd, line.c_str(), line.length(), MSG_NOSIGNAL);
    if (bytes_sent < 0) {
        if (errno == EPIPE || errno == ECONNRESET) {
            LOGW("Send to fd %d failed (connection closed), removing client.", client_fd);
            std::thread([this, client_fd] { this->remove_client(client_fd); }).detach();
        } else {
            LOGE("Send to fd %d failed: %s", client_fd, strerror(errno));
        }
        return false;
    }
    return true;
}

void UdsServer::broadcast_message(const std::string& message) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    if (client_fds_.empty()) return;

    auto clients_copy = client_fds_;
    for (int fd : clients_copy) {
        send_message(fd, message);
    }
}

void UdsServer::handle_client_data(int client_fd) {
    char buffer[4096];
    ssize_t bytes_read = recv(client_fd, buffer, sizeof(buffer), 0);

    if (bytes_read <= 0) {
        remove_client(client_fd);
        return;
    }

    std::string received_data(buffer, bytes_read);
    std::vector<std::string> messages_to_process;

    {
        std::lock_guard<std::mutex> lock(client_mutex_);
        auto buffer_it = client_buffers_.find(client_fd);
        if (buffer_it == client_buffers_.end()) return;
        
        buffer_it->second += received_data;
        std::string& client_buffer = buffer_it->second;

        size_t pos;
        while ((pos = client_buffer.find('\n')) != std::string::npos) {
            std::string message = client_buffer.substr(0, pos);
            if (!message.empty()) {
                messages_to_process.push_back(message);
            }
            client_buffer.erase(0, pos + 1);
        }
    }

    if (on_message_received_ && !messages_to_process.empty()) {
        for (const auto& msg : messages_to_process) {
            on_message_received_(client_fd, msg);
        }
    }
}

void UdsServer::stop() {
    if (!is_running_.exchange(false)) return;
    LOGI("Stopping TCP server...");
    
    if (server_fd_ != -1) {
        shutdown(server_fd_, SHUT_RDWR);
        close(server_fd_);
        server_fd_ = -1;
    }

    std::lock_guard<std::mutex> lock(client_mutex_);
    for (int fd : client_fds_) {
        close(fd);
    }
    client_fds_.clear();
    ui_client_fds_.clear();
    client_buffers_.clear();
    LOGI("TCP Server stopped and all clients disconnected.");
}

void UdsServer::run() {
    server_fd_ = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, 0);
    if (server_fd_ == -1) {
        LOGE("Failed to create TCP socket: %s", strerror(errno));
        return;
    }

    int opt = 1;
    if (setsockopt(server_fd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        LOGE("setsockopt(SO_REUSEADDR) failed: %s", strerror(errno));
        close(server_fd_);
        return;
    }

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons(port_);

    if (bind(server_fd_, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        LOGE("Failed to bind TCP socket to 127.0.0.1:%d : %s", port_, strerror(errno));
        close(server_fd_);
        return;
    }

    if (listen(server_fd_, 5) == -1) {
        LOGE("Failed to listen on TCP socket: %s", strerror(errno));
        close(server_fd_);
        return;
    }

    LOGI("Server listening on TCP 127.0.0.1:%d", port_);
    is_running_ = true;

    while (is_running_) {
        fd_set read_fds;
        FD_ZERO(&read_fds);
        FD_SET(server_fd_, &read_fds);
        int max_fd = server_fd_;

        {
            std::lock_guard<std::mutex> lock(client_mutex_);
            for (int fd : client_fds_) {
                FD_SET(fd, &read_fds);
                max_fd = std::max(max_fd, fd);
            }
        }
        
        struct timeval tv { .tv_sec = 1, .tv_usec = 0 };
        int activity = select(max_fd + 1, &read_fds, nullptr, nullptr, &tv);

        if (activity < 0) {
            if (errno == EINTR) continue;
            LOGE("select() error: %s", strerror(errno));
            break;
        }
        if (!is_running_) break;
        if (activity == 0) continue;

        if (FD_ISSET(server_fd_, &read_fds)) {
            struct sockaddr_in client_addr;
            socklen_t client_len = sizeof(client_addr);
            int new_socket = accept(server_fd_, (struct sockaddr*)&client_addr, &client_len);
            if (new_socket >= 0) {
                // [通信优化] 禁用Nagle算法
                int nodelay_opt = 1;
                if (setsockopt(new_socket, IPPROTO_TCP, TCP_NODELAY, &nodelay_opt, sizeof(nodelay_opt)) < 0) {
                    LOGW("setsockopt(TCP_NODELAY) failed for client fd %d: %s", new_socket, strerror(errno));
                }
                add_client(new_socket);
            }
        }
        
        std::vector<int> clients_to_check;
        {
            std::lock_guard<std::mutex> lock(client_mutex_);
            clients_to_check = client_fds_;
        }
        for (int fd : clients_to_check) {
            if (FD_ISSET(fd, &read_fds)) {
                handle_client_data(fd);
            }
        }
    }
    LOGI("Server event loop terminated.");
}
```

daemon/cpp/uds_server.h
```
// daemon/cpp/uds_server.h
#ifndef CERBERUSD_UDS_SERVER_H
#define CERBERUSD_UDS_SERVER_H

#include <string>
#include <vector>
#include <mutex>
#include <atomic>
#include <functional>
#include <map>
#include <set> // [新增] 用于存放UI客户端

// 为了减少文件重命名，我们继续使用这个类名，但它现在是一个TCP服务器
class UdsServer {
public:
    // 构造函数现在接受一个端口号
    explicit UdsServer(int port);
    ~UdsServer();

    UdsServer(const UdsServer&) = delete;
    UdsServer& operator=(const UdsServer&) = delete;

    void run();
    void stop();
    
    void broadcast_message(const std::string& message);
    void set_message_handler(std::function<void(int client_fd, const std::string&)> handler);
    bool send_message(int client_fd, const std::string& message);
    bool has_clients() const;
    void broadcast_message_except(const std::string& message, int excluded_fd);
    void set_disconnect_handler(std::function<void(int client_fd)> handler);

    // [新增] 专门用于心跳等UI特定广播
    void broadcast_message_to_ui(const std::string& message);
    // [新增] 外部调用的方法，用于识别客户端类型
    void identify_client_as_ui(int client_fd);

private:
    void add_client(int client_fd);
    void remove_client(int client_fd);
    void handle_client_data(int client_fd);

    int port_;
    int server_fd_;
    std::atomic<bool> is_running_;
    
    std::vector<int> client_fds_;
    // [新增] 专门存放UI客户端的fd，用于发送心跳
    std::set<int> ui_client_fds_;
    mutable std::mutex client_mutex_;

    std::function<void(int, const std::string&)> on_message_received_;
    std::function<void(int)> on_disconnect_;
    std::map<int, std::string> client_buffers_;
};

#endif //CERBERUSD_UDS_SERVER_H
```



gradle.properties

# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true

gradlew

#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"


gradlew.bat

@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega


local.properties

## This file is automatically generated by Android Studio.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file should *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
sdk.dir=C\:\\Users\\zeaol\\AppData\\Local\\Android\\Sdk

project_context.txt

build.gradle.kts
```
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    // 正确引用在 toml 中定义的 compose 插件
    alias(libs.plugins.jetbrains.compose) apply false
}
```

settings.gradle.kts
```
// D:/project/Cerberus/settings.gradle.kts

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}

// 核心：这里是唯一且合并后的 dependencyResolutionManagement 块
dependencyResolutionManagement {
    // 仓库管理模式设置，保持不变
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)

    // 🇨🇳 把所有仓库都放在这一个 repositories 块里
    repositories {
        google()
        mavenCentral()
        // 🇨🇳 把 Xposed 的仓库也加到这里
        maven { url = uri("https://api.xposed.info/") }
    }
}

rootProject.name = "CRFzit" // 您可以修改为 "Cerberus"
include(":app")
```

gradle/libs.versions.toml
```
[versions]
# 版本号均保持不变
agp = "8.11.1"
kotlin = "2.2.0"
composeCompiler = "1.5.14"
coreKtx = "1.16.0"
activityCompose = "1.10.1"
composeBom = "2025.06.01"
lifecycleRuntimeKtx = "2.9.1"
lifecycleViewmodelCompose = "2.9.1"
lifecycleKtx = "2.9.1"
navigation = "2.9.1"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
annotation = "1.9.1"
gson = "2.13.1"
materialIconsCore = "1.7.8" # [核心优化] 新增版本号，用于核心图标库
androidxMaterial3 = "1.3.2"
accompanist = "0.34.0"

[libraries]
accompanist-swiperefresh = { group = "com.google.accompanist", name = "accompanist-swiperefresh", version.ref = "accompanist" }
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleKtx" }
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycleViewmodelCompose" }
androidx-annotation = { group = "androidx.annotation", name = "annotation", version.ref = "annotation" }
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigation" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended" }
# [核心优化] 新增 core 图标库的依赖引用
androidx-material-icons-core = { group = "androidx.compose.material", name = "material-icons-core", version.ref = "materialIconsCore" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", "name" = "ui-test-junit4" }
gson = { group = "com.google.code.gson", name = "gson", version.ref = "gson" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
jetbrains-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin"}
```

app/build.gradle.kts
```
// app/build.gradle.kts
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.jetbrains.compose)
}

android {
    namespace = "com.crfzit.crfzit"
    compileSdk = 36

    defaultConfig {
        applicationId = "com.crfzit.crfzit"
        minSdk = 30
        targetSdk = 36
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
        ndk {
            abiFilters.addAll(listOf("arm64-v8a", "armeabi-v7a"))
        }
        buildConfigField("long", "BUILD_TIME", "${System.currentTimeMillis()}L")
    }

    buildTypes {
        release {
            // [核心优化] 开启代码混淆和资源压缩，减小最终APK体积
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
            proguardFile("proguard-rules-disabler.pro")
            signingConfig = signingConfigs.getByName("debug")
        }
        debug {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    kotlin {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_1_8)
            allWarningsAsErrors.set(false)
        }
        jvmToolchain(17)
    }

    buildFeatures {
        compose = true
        buildConfig = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
    androidResources {
        localeFilters.addAll(listOf("en", "zh-rCN", "zh"))
    }
}
dependencies {
    implementation(libs.accompanist.swiperefresh)
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.lifecycle.viewmodel.ktx)

    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)

    // [核心优化] 移除完整的 extended 依赖，改为依赖更小的 core 核心库
    // implementation(libs.androidx.material.icons.extended)
    implementation(libs.androidx.material.icons.core)


    implementation(libs.androidx.lifecycle.viewmodel.compose)
    implementation(libs.androidx.annotation)
    implementation(libs.androidx.navigation.compose)

    implementation(libs.gson)
    implementation("io.coil-kt:coil-compose:2.7.0")

    // Xposed API 依赖保持不变
    compileOnly("de.robv.android.xposed:api:82")
    compileOnly("de.robv.android.xposed:api:82:sources")

    testImplementation(libs.junit)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
}
```

app/src/main/AndroidManifest.xml
```
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 核心修改：添加 INTERNET 权限，用于TCP通信 -->
    <uses-permission android:name="android.permission.INTERNET" />

    <!-- 声明查询所有应用的权限 -->
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission" />

    <!-- 架构重构：使用我们自定义的Application类 -->
    <application
        android:name=".CerberusApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Cerberus"
        tools:targetApi="36">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.Cerberus">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <meta-data
            android:name="xposedmodule"
            android:value="true" />
        <meta-data
            android:name="xposeddescription"
            android:value="Project Cerberus - UI &amp; System Probe" />
        <meta-data
            android:name="xposedminversion"
            android:value="82" />
        <meta-data
            android:name="xposedscope"
            android:resource="@array/xposed_scope" />

    </application>
</manifest>
```

app/src/main/java/com/crfzit/crfzit/CerberusApp.kt
```
// app/src/main/java/com/crfzit/crfzit/CerberusApp.kt
package com.crfzit.crfzit

import android.app.Application
import coil.ImageLoader
import coil.ImageLoaderFactory
import coil.request.CachePolicy
import com.crfzit.crfzit.coil.AppIcon
import com.crfzit.crfzit.coil.AppIconFetcher
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob

/**
 * [内存优化] 让我们的Application类实现ImageLoaderFactory接口，
 * 以便为整个应用提供一个自定义配置的Coil ImageLoader实例。
 */
class CerberusApp : Application(), ImageLoaderFactory {

    // 创建一个贯穿整个App生命周期的协程作用域
    val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)

    override fun onCreate() {
        super.onCreate()
        // 在App启动时，就初始化（预热）DaemonRepository单例
        DaemonRepository.getInstance(applicationScope)
    }

    /**
     * [内存优化] 实现ImageLoaderFactory的核心方法。
     * 在这里我们构建一个包含了自定义AppIconFetcher的ImageLoader。
     */
    override fun newImageLoader(): ImageLoader {
        return ImageLoader.Builder(this)
            // 添加我们的自定义Fetcher。Coil会按顺序检查组件。
            .components {
                add(AppIconFetcher.Factory())
            }
            // 开启内存缓存
            .memoryCachePolicy(CachePolicy.ENABLED)
            .memoryCache {
                // 配置内存缓存大小，例如，最大为可用内存的15%
                coil.memory.MemoryCache.Builder(this)
                    .maxSizePercent(0.15)
                    .build()
            }
            // 开启磁盘缓存
            .diskCachePolicy(CachePolicy.ENABLED)
            .diskCache {
                // 配置磁盘缓存
                coil.disk.DiskCache.Builder()
                    .directory(this.cacheDir.resolve("image_cache"))
                    .maxSizePercent(0.02) // 磁盘空间的2%
                    .build()
            }
            // 全局配置，所有请求默认都将交叉淡入效果
            .crossfade(true)
            .build()
    }
}
```

app/src/main/java/com/crfzit/crfzit/coil/AppIconFetcher.kt
```
// app/src/main/java/com/crfzit/crfzit/coil/AppIconFetcher.kt
package com.crfzit.crfzit.coil

import android.content.pm.PackageManager
import coil.ImageLoader
import coil.decode.DataSource
import coil.fetch.DrawableResult
import coil.fetch.FetchResult
import coil.fetch.Fetcher
import coil.request.Options

/**
 * [内存优化] 自定义数据类，用于向Coil清晰地表达“我想要加载一个应用图标”的意图。
 * @param packageName 要加载图标的应用包名。
 */
data class AppIcon(val packageName: String)

/**
 * [内存优化] Coil的自定义Fetcher，它知道如何处理 AppIcon 数据类。
 * 当Coil看到一个类型为AppIcon的请求时，它会使用这个Fetcher来执行加载逻辑。
 */
class AppIconFetcher(
    private val options: Options,
    private val data: AppIcon
) : Fetcher {

    override suspend fun fetch(): FetchResult {
        val context = options.context
        val packageManager = context.packageManager

        // 从PackageManager获取应用图标的Drawable
        val drawable = try {
            packageManager.getApplicationIcon(data.packageName)
        } catch (e: PackageManager.NameNotFoundException) {
            // 如果应用不存在，返回null，Coil会使用error占位符
            null
        }

        // 必须返回一个DrawableResult
        return DrawableResult(
            drawable = drawable ?: packageManager.defaultActivityIcon, // 如果找不到，使用系统默认图标
            isSampled = false, // 我们没有对它进行采样
            dataSource = DataSource.DISK // 图标来自设备存储，所以是DISK
        )
    }

    /**
     * Factory是必需的，它告诉Coil在何时使用我们的AppIconFetcher。
     */
    class Factory : Fetcher.Factory<AppIcon> {
        override fun create(data: AppIcon, options: Options, imageLoader: ImageLoader): Fetcher {
            return AppIconFetcher(options, data)
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/model/AppModels.kt
```
// app/src/main/java/com/crfzit/crfzit/data/model/AppModels.kt
package com.crfzit.crfzit.data.model

enum class Policy(val value: Int) {
    EXEMPTED(0),
    IMPORTANT(1),
    STANDARD(2),
    STRICT(3);

    companion object {
        fun fromInt(value: Int) = entries.find { it.value == value } ?: EXEMPTED
    }
}

data class AppInfo(
    val packageName: String,
    val appName: String,
    val isSystemApp: Boolean,
    val userId: Int = 0,

    var policy: Policy = Policy.EXEMPTED,
    var forcePlaybackExemption: Boolean = false,
    var forceNetworkExemption: Boolean = false
)

enum class LogLevel(val value: Int) {
    INFO(0),
    SUCCESS(1),
    WARN(2),
    ERROR(3),
    EVENT(4),
    DOZE(5),
    BATTERY(6),
    REPORT(7),
    ACTION_OPEN(8),
    ACTION_CLOSE(9),
    ACTION_FREEZE(10),
    ACTION_UNFREEZE(11),
    ACTION_DELAY(12),
    TIMER(13),
    BATCH_PARENT(14);

    companion object {
        fun fromInt(value: Int) = entries.find { it.value == value } ?: INFO
    }
}

data class LogEntry(
    val timestamp: Long,
    val level: LogLevel,
    val category: String,
    val message: String,
    val packageName: String?,
    val userId: Int = -1
)

data class MetricsRecord(
    val timestamp: Long,
    val totalCpuUsagePercent: Float, // [核心修改] 重命名
    val perCoreCpuUsagePercent: List<Float>, // [核心新增]
    val memTotalKb: Long,
    val memAvailableKb: Long,
    val swapTotalKb: Long,
    val swapFreeKb: Long,
    val batteryLevel: Int,
    val batteryTempCelsius: Float,
    val batteryPowerWatt: Float,
    val isCharging: Boolean,
    val isScreenOn: Boolean,
    val isAudioPlaying: Boolean,
    val isLocationActive: Boolean
)
```

app/src/main/java/com/crfzit/crfzit/data/model/IPCModels.kt
```
// app/src/main/java/com/crfzit/crfzit/data/model/IPCModels.kt
package com.crfzit.crfzit.data.model

import com.google.gson.annotations.SerializedName

data class CerberusMessage<T>(
    @SerializedName("v")
    val version: Int = 12,
    val type: String,
    @SerializedName("req_id")
    val requestId: String? = null,
    val payload: T
)

data class DashboardPayload(
    @SerializedName("global_stats")
    val globalStats: GlobalStats,
    @SerializedName("apps_runtime_state")
    val appsRuntimeState: List<AppRuntimeState>
)

data class GlobalStats(
    @SerializedName("total_cpu_usage_percent")
    val totalCpuUsagePercent: Float = 0f,
    @SerializedName("total_mem_kb")
    val totalMemKb: Long = 0L,
    @SerializedName("avail_mem_kb")
    val availMemKb: Long = 0L,
    @SerializedName("swap_total_kb")
    val swapTotalKb: Long = 0L,
    @SerializedName("swap_free_kb")
    val swapFreeKb: Long = 0L
)

data class AppRuntimeState(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("app_name")
    val appName: String,
    @SerializedName("user_id")
    val userId: Int = 0,
    @SerializedName("display_status")
    val displayStatus: String = "UNKNOWN",
    @SerializedName("mem_usage_kb")
    val memUsageKb: Long = 0L,
    @SerializedName("swap_usage_kb")
    val swapUsageKb: Long = 0L,
    @SerializedName("cpu_usage_percent")
    val cpuUsagePercent: Float = 0f,
    @SerializedName("is_whitelisted")
    val isWhitelisted: Boolean = false,
    @SerializedName("is_foreground")
    val isForeground: Boolean = false
)

// --- Probe -> Daemon 事件模型 ---
data class AppStateEventPayload(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("user_id")
    val userId: Int
)

// --- 配置模型 (UI -> Daemon -> Probe) ---
data class FullConfigPayload(
    @SerializedName("master_config")
    val masterConfig: MasterConfig,
    @SerializedName("exempt_config")
    val exemptConfig: ExemptConfig,
    @SerializedName("policies")
    val policies: List<AppPolicyPayload>,
    @SerializedName("frozen_uids")
    val frozenUids: List<Int>? = null
)

data class MasterConfig(
    @SerializedName("is_enabled")
    val isEnabled: Boolean = true,
    @SerializedName("freeze_on_screen_off")
    val freezeOnScreenOff: Boolean = true,
    @SerializedName("standard_timeout_sec")
    val standardTimeoutSec: Int = 90,
    @SerializedName("is_timed_unfreeze_enabled")
    val isTimedUnfreezeEnabled: Boolean = true,
    @SerializedName("timed_unfreeze_interval_sec")
    val timedUnfreezeIntervalSec: Int = 1800
)

data class ExemptConfig(
    @SerializedName("exempt_foreground_services")
    val exemptForegroundServices: Boolean = true
)

data class AppPolicyPayload(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("user_id")
    val userId: Int,
    val policy: Int // Corresponds to AppPolicy enum
)

data class AppInstanceKey(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("user_id")
    val userId: Int
)

data class LogEntryPayload(
    val timestamp: Long,
    val level: Int,
    val category: String,
    val message: String,
    @SerializedName("package_name") val packageName: String?,
    @SerializedName("user_id") val userId: Int?
)

data class MetricsRecordPayload(
    val timestamp: Long,
    @SerializedName("cpu_usage_percent") val totalCpuUsagePercent: Float, // [核心修改] 重命名
    @SerializedName("per_core_cpu_usage_percent") val perCoreCpuUsagePercent: List<Float>?, // [核心新增]
    @SerializedName("mem_total_kb") val memTotalKb: Long,
    @SerializedName("mem_available_kb") val memAvailableKb: Long,
    @SerializedName("swap_total_kb") val swapTotalKb: Long,
    @SerializedName("swap_free_kb") val swapFreeKb: Long,
    @SerializedName("battery_level") val batteryLevel: Int,
    @SerializedName("battery_temp_celsius") val batteryTempCelsius: Float,
    @SerializedName("battery_power_watt") val batteryPowerWatt: Float,
    @SerializedName("is_charging") val isCharging: Boolean,
    @SerializedName("is_screen_on") val isScreenOn: Boolean,
    @SerializedName("is_audio_playing") val isAudioPlaying: Boolean,
    @SerializedName("is_location_active") val isLocationActive: Boolean
)

data class GetLogsPayload(
    val since: Long? = null,
    val before: Long? = null,
    val limit: Int? = null
)
```

app/src/main/java/com/crfzit/crfzit/data/repository/AppInfoRepository.kt
```
// app/src/main/java/com/crfzit/crfzit/data/repository/AppInfoRepository.kt
package com.crfzit.crfzit.data.repository

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import com.crfzit.crfzit.data.model.AppInfo
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import java.util.concurrent.ConcurrentHashMap

class AppInfoRepository private constructor(private val context: Context) {

    private val packageManager: PackageManager = context.packageManager
    // 缓存只使用包名作为Key，因为此仓库只处理主用户的应用元数据
    private val appInfoCache: ConcurrentHashMap<String, AppInfo> = ConcurrentHashMap()
    private val cacheMutex = Mutex()

    suspend fun getAllApps(forceRefresh: Boolean = false): List<AppInfo> {
        cacheMutex.withLock {
            if (appInfoCache.isNotEmpty() && !forceRefresh) {
                return appInfoCache.values.toList()
            }
            loadAllInstalledApps()
            return appInfoCache.values.toList()
        }
    }

    suspend fun getAppInfo(packageName: String): AppInfo? {
        appInfoCache[packageName]?.let { return it }

        return cacheMutex.withLock {
            // 双重检查锁定
            appInfoCache[packageName]?.let { return@withLock it }

            val app = loadSingleApp(packageName)
            app?.let { appInfoCache[packageName] = it }
            app
        }
    }

    private suspend fun loadAllInstalledApps() {
        withContext(Dispatchers.IO) {
            appInfoCache.clear()
            val apps = packageManager.getInstalledApplications(PackageManager.GET_META_DATA)
                .filterNotNull()
                .mapNotNull { appInfo ->
                    try {
                        createAppInfoFrom(appInfo)
                    } catch (e: Exception) {
                        null
                    }
                }

            appInfoCache.putAll(apps.associateBy { it.packageName })
        }
    }

    private suspend fun loadSingleApp(packageName: String): AppInfo? = withContext(Dispatchers.IO) {
        try {
            val appInfo = packageManager.getApplicationInfo(packageName, PackageManager.GET_META_DATA)
            createAppInfoFrom(appInfo)
        } catch (e: PackageManager.NameNotFoundException) {
            null
        }
    }

    private fun createAppInfoFrom(appInfo: ApplicationInfo): AppInfo {
        return AppInfo(
            packageName = appInfo.packageName,
            appName = appInfo.loadLabel(packageManager).toString(),
            // [内存优化] 不再加载和存储Drawable对象
            // icon = appInfo.loadIcon(packageManager),
            isSystemApp = (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0,
            userId = 0 // 这个仓库获取的都是主用户空间的应用，因此userId固定为0
        )
    }

    companion object {
        @Volatile
        private var INSTANCE: AppInfoRepository? = null

        fun getInstance(context: Context): AppInfoRepository {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: AppInfoRepository(context.applicationContext).also { INSTANCE = it }
            }
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/repository/DaemonRepository.kt
```
// app/src/main/java/com/crfzit/crfzit/data/repository/DaemonRepository.kt
package com.crfzit.crfzit.data.repository

import android.util.Log
import com.crfzit.crfzit.data.model.*
import com.crfzit.crfzit.data.uds.TcpClient
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import java.util.*
import java.util.concurrent.ConcurrentHashMap

data class GetLogFilesPayload(val placeholder: Int = 0)
data class GetLogsByFilePayload(
    val filename: String?,
    val before: Long?,
    val since: Long?,
    val limit: Int?
)

class DaemonRepository private constructor(
    private val scope: CoroutineScope
) {
    private val tcpClient = TcpClient(scope)
    private val gson = Gson()
    private val pendingRequests = ConcurrentHashMap<String, CompletableDeferred<String>>()

    init {
        tcpClient.start()
        scope.launch(Dispatchers.IO) {
            tcpClient.incomingMessages.collect { jsonLine ->
                try {
                    val baseMsg = gson.fromJson(jsonLine, BaseMessage::class.java)
                    if ((baseMsg.type.startsWith("resp.") || baseMsg.type.startsWith("error.")) && baseMsg.requestId != null) {
                        pendingRequests.remove(baseMsg.requestId)?.complete(jsonLine)
                    }
                } catch (e: JsonSyntaxException) {
                    // Ignore, not a response message
                }
            }
        }
    }

    private fun mapPayloadToMetricsRecord(p: MetricsRecordPayload): MetricsRecord {
        return MetricsRecord(
            timestamp = p.timestamp,
            totalCpuUsagePercent = p.totalCpuUsagePercent, // [核心修改]
            perCoreCpuUsagePercent = p.perCoreCpuUsagePercent ?: emptyList(), // [核心新增]
            memTotalKb = p.memTotalKb,
            memAvailableKb = p.memAvailableKb,
            swapTotalKb = p.swapTotalKb,
            swapFreeKb = p.swapFreeKb,
            batteryLevel = p.batteryLevel,
            batteryTempCelsius = p.batteryTempCelsius,
            batteryPowerWatt = p.batteryPowerWatt,
            isCharging = p.isCharging,
            isScreenOn = p.isScreenOn,
            isAudioPlaying = p.isAudioPlaying,
            isLocationActive = p.isLocationActive
        )
    }

    fun getDashboardStream(): Flow<DashboardPayload> = tcpClient.incomingMessages
        .mapNotNull { jsonLine ->
            try {
                val type = object : TypeToken<CerberusMessage<DashboardPayload>>() {}.type
                val msg = gson.fromJson<CerberusMessage<DashboardPayload>>(jsonLine, type)
                if (msg?.type == "stream.dashboard_update") msg.payload else null
            } catch (e: Exception) {
                Log.w("DaemonRepository", "Failed to parse DashboardPayload: ${e.message}")
                null
            }
        }

    suspend fun getLogFiles(): List<String>? {
        return query("query.get_log_files", GetLogFilesPayload()) { responseJson ->
            val responseType = object : TypeToken<CerberusMessage<List<String>>>() {}.type
            val message = gson.fromJson<CerberusMessage<List<String>>>(responseJson, responseType)
            if (message?.type == "resp.get_log_files") {
                message.payload
            } else {
                null
            }
        }
    }

    suspend fun getLogs(
        filename: String,
        before: Long? = null,
        since: Long? = null,
        limit: Int? = null
    ): List<LogEntry>? {
        val payload = GetLogsByFilePayload(filename = filename, before = before, since = since, limit = limit)
        return query("query.get_logs", payload) { responseJson ->
            val responseType = object : TypeToken<CerberusMessage<List<LogEntryPayload>>>() {}.type
            val message = gson.fromJson<CerberusMessage<List<LogEntryPayload>>>(responseJson, responseType)
            if (message?.type == "resp.get_logs") {
                message.payload.map { p ->
                    LogEntry(p.timestamp, LogLevel.fromInt(p.level), p.category, p.message, p.packageName, p.userId ?: -1)
                }
            } else {
                Log.e("DaemonRepository", "Query 'get_logs' received unexpected response type '${message?.type}'")
                null
            }
        }
    }

    fun getStatsStream(): Flow<MetricsRecord> = tcpClient.incomingMessages
        .mapNotNull { jsonLine ->
            try {
                val type = object : TypeToken<CerberusMessage<MetricsRecordPayload>>() {}.type
                val msg = gson.fromJson<CerberusMessage<MetricsRecordPayload>>(jsonLine, type)
                if (msg?.type == "stream.new_stats_record") {
                    msg.payload?.let { mapPayloadToMetricsRecord(it) } // [核心修改]
                } else null
            } catch (e: Exception) {
                Log.w("DaemonRepository", "Failed to parse MetricsRecordPayload: ${e.message}")
                null
            }
        }

    suspend fun getHistoryStats(): List<MetricsRecord>? = query("query.get_history_stats", EmptyPayload) { responseJson ->
        val type = object : TypeToken<CerberusMessage<List<MetricsRecordPayload>>>() {}.type
        val message = gson.fromJson<CerberusMessage<List<MetricsRecordPayload>>>(responseJson, type)
        if (message?.type == "resp.history_stats") {
            message.payload.map { mapPayloadToMetricsRecord(it) } // [核心修改]
        } else {
            null
        }
    }

    private suspend fun <ReqT, RespT> query(
        queryType: String,
        payload: ReqT,
        responseParser: (String) -> RespT?
    ): RespT? {
        val reqId = UUID.randomUUID().toString()
        val deferred = CompletableDeferred<String>()
        pendingRequests[reqId] = deferred
        val requestMsg = CerberusMessage(type = queryType, requestId = reqId, payload = payload)
        tcpClient.sendMessage(gson.toJson(requestMsg))
        return try {
            withTimeout(5000) { deferred.await() }.let(responseParser)
        } catch (e: Exception) {
            Log.e("DaemonRepository", "Failed to query '$queryType': ${e.message}")
            pendingRequests.remove(reqId)
            null
        }
    }

    fun setPolicy(config: FullConfigPayload) {
        val message = CerberusMessage(type = "cmd.set_policy", payload = config)
        tcpClient.sendMessage(gson.toJson(message))
    }

    suspend fun getAllPolicies(): FullConfigPayload? {
        return query("query.get_all_policies", EmptyPayload) { responseJson ->
            val type = object : TypeToken<CerberusMessage<FullConfigPayload>>() {}.type
            val message = gson.fromJson<CerberusMessage<FullConfigPayload>>(responseJson, type)
            if (message?.type == "resp.all_policies") message.payload else null
        }
    }

    fun requestDashboardRefresh() {
        val message = CerberusMessage(type = "query.refresh_dashboard", payload = EmptyPayload)
        tcpClient.sendMessage(gson.toJson(message))
    }

    fun stop() {
        tcpClient.stop()
        pendingRequests.values.forEach { it.cancel("Repository is stopping.") }
        pendingRequests.clear()
    }

    fun setMasterConfig(payload: Map<String, Any>) {
        val message = CerberusMessage(type = "cmd.set_master_config", payload = payload)
        tcpClient.sendMessage(gson.toJson(message))
    }

    private data class BaseMessage(val type: String, @SerializedName("req_id") val requestId: String?)
    private object EmptyPayload

    companion object {
        @Volatile private var INSTANCE: DaemonRepository? = null
        fun getInstance(scope: CoroutineScope? = null): DaemonRepository {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: scope?.let {
                    DaemonRepository(it).also { INSTANCE = it }
                } ?: throw IllegalStateException("CoroutineScope must be provided for the first initialization")
            }
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/system/NetworkMonitor.kt
```
// app/src/main/java/com/crfzit/crfzit/data/system/NetworkMonitor.kt
package com.crfzit.crfzit.data.system

import android.net.TrafficStats
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

data class NetworkSpeed(
    val downloadSpeedBps: Long = 0,
    val uploadSpeedBps: Long = 0
)

class NetworkMonitor {

    private var lastTotalRxBytes: Long = 0
    private var lastTotalTxBytes: Long = 0
    private var lastTimestamp: Long = 0

    init {
        // 初始化时获取一次基准值
        lastTotalRxBytes = TrafficStats.getTotalRxBytes()
        lastTotalTxBytes = TrafficStats.getTotalTxBytes()
        lastTimestamp = System.currentTimeMillis()
    }

    fun getSpeedStream(): Flow<NetworkSpeed> = flow {
        while (true) {
            val currentRxBytes = TrafficStats.getTotalRxBytes()
            val currentTxBytes = TrafficStats.getTotalTxBytes()
            val currentTimestamp = System.currentTimeMillis()

            val durationMs = currentTimestamp - lastTimestamp
            // 确保持续时间大于0，且初始值有效
            if (durationMs > 0 && lastTotalRxBytes != TrafficStats.UNSUPPORTED.toLong()) {
                val deltaRx = currentRxBytes - lastTotalRxBytes
                val deltaTx = currentTxBytes - lastTotalTxBytes

                // 每秒比特数 = (字节差 * 1000 / 毫秒差) * 8
                val downSpeed = if (deltaRx >= 0) (deltaRx * 1000 / durationMs) * 8 else 0
                val upSpeed = if (deltaTx >= 0) (deltaTx * 1000 / durationMs) * 8 else 0

                emit(NetworkSpeed(downloadSpeedBps = downSpeed, uploadSpeedBps = upSpeed))
            } else {
                 emit(NetworkSpeed(0, 0))
            }

            // 更新基准值
            lastTotalRxBytes = currentRxBytes
            lastTotalTxBytes = currentTxBytes
            lastTimestamp = currentTimestamp

            // [FIX] 刷新间隔改为5秒
            delay(5000)
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/uds/TcpClient.kt
```
// app/src/main/java/com/crfzit/crfzit/data/uds/TcpClient.kt
package com.crfzit.crfzit.data.uds

import android.util.Log
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import java.io.IOException
import java.io.OutputStream
import java.net.Socket
import java.net.SocketTimeoutException
import java.nio.charset.StandardCharsets

class TcpClient(private val scope: CoroutineScope) {

    private enum class ConnectionState { DISCONNECTED, CONNECTING, CONNECTED }

    @Volatile
    private var socket: Socket? = null
    @Volatile
    private var outputStream: OutputStream? = null

    private var connectionJob: Job? = null

    // [修改] 将 incomingMessages 的 replay 缓存增加，以防UI重建时丢失少量数据
    private val _incomingMessages = MutableSharedFlow<String>(replay = 20, extraBufferCapacity = 64)
    val incomingMessages = _incomingMessages.asSharedFlow()

    // [新增] 暴露连接状态给外部
    private val _isConnected = MutableStateFlow(false)
    val isConnected = _isConnected.asStateFlow()

    companion object {
        private const val TAG = "CerberusTcpClient"
        private const val HOST = "127.0.0.1"
        private const val PORT = 28900
        private const val RECONNECT_DELAY_MS = 3000L
        private const val READ_TIMEOUT_MS = 30_000 // 30秒读超时
    }

    fun start() {
        if (connectionJob?.isActive == true) {
            Log.d(TAG, "TCP client is already running.")
            return
        }
        Log.i(TAG, "TCP client start() called.")

        connectionJob = scope.launch(Dispatchers.IO) {
            // [核心重构] 使用无限循环来维持连接
            while (isActive) {
                var currentState = ConnectionState.DISCONNECTED
                try {
                    // 状态: DISCONNECTED -> CONNECTING
                    currentState = ConnectionState.CONNECTING
                    _isConnected.value = false
                    Log.i(TAG, "Attempting to connect to TCP server: $HOST:$PORT...")
                    
                    val newSocket = Socket(HOST, PORT)
                    newSocket.soTimeout = READ_TIMEOUT_MS // 设置读超时

                    socket = newSocket
                    outputStream = newSocket.outputStream

                    // 状态: CONNECTING -> CONNECTED
                    currentState = ConnectionState.CONNECTED
                    _isConnected.value = true
                    Log.i(TAG, "Successfully connected to daemon via TCP.")

                    // [新增] 发送一个 "hello" 消息，让后端识别我们是UI客户端
                    sendMessage("{\"type\":\"hello.ui\"}")

                    listenForMessages()

                } catch (e: Exception) {
                    when (e) {
                        is SocketTimeoutException -> {
                            Log.w(TAG, "Connection timed out (no heartbeat from daemon). Reconnecting...")
                        }
                        is IOException -> {
                            Log.w(TAG, "Connection failed or lost: ${e.message}. Retrying in ${RECONNECT_DELAY_MS}ms...")
                        }
                        else -> {
                            Log.e(TAG, "Unhandled exception in connection loop: ${e.message}", e)
                        }
                    }
                } finally {
                    // 确保无论如何都清理资源并进入重试等待
                    cleanupSocket()
                    _isConnected.value = false
                    if (isActive) {
                        delay(RECONNECT_DELAY_MS)
                    }
                }
            }
        }
    }
    
    fun sendMessage(message: String) {
        // sendMessage 逻辑保持不变，但现在更健壮，因为连接层会自动恢复
        scope.launch(Dispatchers.IO) {
            val stream = outputStream
            if (stream == null || socket?.isConnected != true) {
                Log.w(TAG, "Cannot send message, socket is not connected.")
                return@launch
            }
            try {
                // 加锁以防止多线程写竞争，虽然当前场景不明显，但这是个好习惯
                synchronized(this) {
                    stream.write((message + "\n").toByteArray(StandardCharsets.UTF_8))
                    stream.flush()
                }
                Log.d(TAG, "Sent: $message")
            } catch (e: IOException) {
                Log.e(TAG, "Failed to send message: ${e.message}")
                // 触发连接断开
                cleanupSocket()
            }
        }
    }

    private suspend fun listenForMessages() {
        // 这个函数现在只负责在已连接的状态下读取数据
        val currentSocket = socket ?: return
        Log.d(TAG, "Starting to listen for messages...")
        currentSocket.getInputStream().bufferedReader(StandardCharsets.UTF_8).use { reader ->
            while (currentSocket.isConnected && scope.isActive) {
                // readLine() 会遵守 soTimeout 设置
                val line = reader.readLine() ?: break // 如果流关闭，readLine返回null
                if (line.isNotBlank()) {
                     Log.d(TAG, "Rcvd: $line")
                    _incomingMessages.emit(line)
                }
            }
        }
    }

    fun stop() {
        connectionJob?.cancel()
        connectionJob = null
        cleanupSocket()
        Log.i(TAG, "TCP client stopped.")
    }

    private fun cleanupSocket() {
        try { outputStream?.close() } catch (_: IOException) {}
        try { socket?.close() } catch (_: IOException) {}
        socket = null
        outputStream = null
    }
}
```

app/src/main/java/com/crfzit/crfzit/lsp/ProbeHook.kt
```
// app/src/main/java/com/crfzit/crfzit/lsp/ProbeHook.kt
package com.crfzit.crfzit.lsp

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.ResolveInfo
import android.os.Process
import com.crfzit.crfzit.data.model.CerberusMessage
import com.google.gson.Gson
import com.google.gson.JsonParser
import de.robv.android.xposed.IXposedHookLoadPackage
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XC_MethodReplacement
import de.robv.android.xposed.XposedBridge
import de.robv.android.xposed.XposedHelpers
import de.robv.android.xposed.callbacks.XC_LoadPackage
import java.io.IOException
import java.io.OutputStreamWriter
import java.net.Socket
import java.nio.charset.StandardCharsets

class ProbeHook : IXposedHookLoadPackage {

    private val gson = Gson()
    @Volatile private var nmsInstance: Any? = null
    @Volatile private var packageManager: PackageManager? = null

    companion object {
        // [核心修改] 更新TAG，版本号+1
        private const val TAG = "CerberusProbe_v40_DynamicBqHook"
        const val FLAG_INCLUDE_STOPPED_PACKAGES = 32
        private const val DAEMON_HOST = "127.0.0.1"
        private const val DAEMON_PORT = 28900
        private const val USAGE_EVENT_ACTIVITY_RESUMED = 1
        private const val USAGE_EVENT_ACTIVITY_PAUSED = 2
    }

    private enum class WakeupType(val value: Int) {
        GENERIC_NOTIFICATION(0),
        FCM_PUSH(1),
        PROACTIVE_START(2),
        OTHER(3)
    }

    override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam) {
        if (lpparam.packageName != "android") return
        log("Loading into system_server (PID: ${Process.myPid()}). HookSet active: $TAG")
        sendEventToDaemon("event.probe_hello", mapOf("pid" to Process.myPid(), "version" to TAG))

        try {
            val classLoader = lpparam.classLoader
            // [核心修改] hookAmsLifecycle 的职责改变了
            hookAmsLifecycle(classLoader)
            hookNmsConstructor(classLoader)
            hookActivitySwitchEvents(classLoader)
            hookTaskTrimming(classLoader)
            hookSystemFreezer(classLoader)
            hookAnrHelper(classLoader)
            hookWakelocksAndAlarms(classLoader)
            hookActivityStarter(classLoader)
            hookNotificationService(classLoader)
            hookServices(classLoader)
        } catch (t: Throwable) {
            logError("CRITICAL: Failed during hook placement: $t")
        }
    }

    // [核心重构] hookAmsLifecycle 的新职责：动态拦截广播队列
    private fun hookAmsLifecycle(classLoader: ClassLoader) {
        try {
            val amsClass = XposedHelpers.findClass("com.android.server.am.ActivityManagerService", classLoader)

            // 找到 broadcastIntentLocked 或类似方法作为入口点
            val broadcastIntentMethod = amsClass.declaredMethods.find {
                it.name == "broadcastIntentLocked" || it.name == "broadcastIntent"
            }
            if (broadcastIntentMethod == null) {
                logError("FATAL: Could not find AMS#broadcastIntentLocked method.")
                return
            }

            XposedBridge.hookMethod(broadcastIntentMethod, object : XC_MethodHook() {
                // 我们在方法执行前Hook，确保只Hook一次
                override fun beforeHookedMethod(param: MethodHookParam) {
                    if (ConfigManager.isBqHooked) return

                    val amsInstance = param.thisObject
                    val bqFieldNames = listOf("mFgBroadcastQueue", "mBgBroadcastQueue", "mBroadcastQueues")
                    var bqObject: Any? = null

                    // 再次尝试查找字段，因为此时它们很可能已经被初始化了
                    for (fieldName in bqFieldNames) {
                        try {
                            val field = XposedHelpers.findFieldIfExists(amsClass, fieldName) ?: continue
                            val value = field.get(amsInstance) ?: continue
                            val candidate = if (value is List<*> && value.isNotEmpty()) value.first() else value
                            if (candidate != null && candidate !is List<*>) {
                                bqObject = candidate
                                log("Found BroadcastQueue object in field on-demand: $fieldName")
                                break
                            }
                        } catch (t: Throwable) { /* ignore */ }
                    }

                    if (bqObject == null) {
                        // 如果还是找不到，打印一个警告，但这次不是致命错误，因为通知唤醒仍然可以工作
                        logError("WARN: Could not find BroadcastQueue instance on-demand. FCM wakeup might be affected.")
                        // 标记为已尝试，避免重复执行
                        ConfigManager.isBqHooked = true
                        return
                    }

                    val concreteBqClass = bqObject.javaClass
                    log("Dynamically found BroadcastQueue class: ${concreteBqClass.name}")
                    findAndHookBroadcastMethod(concreteBqClass)
                    // 标记为成功，这个beforeHookedMethod将不再执行查找逻辑
                    ConfigManager.isBqHooked = true
                }
            })
            log("SUCCESS: Placed dynamic hook on AMS#broadcastIntent for on-demand BQ hooking.")
        } catch (t: Throwable) {
            logError("Could not hook AMS lifecycle for dynamic BQ hooking: ${t.message}")
        }
    }

    // findAndHookBroadcastMethod 保持不变，它的逻辑是正确的
    private fun findAndHookBroadcastMethod(concreteBqClass: Class<*>) {
        val classLoader = concreteBqClass.classLoader ?: run {
            logError("FATAL: ClassLoader for ${concreteBqClass.name} is null!")
            return
        }
        val brClass = findClass("com.android.server.am.BroadcastRecord", classLoader) ?: run {
            logError("FATAL: Could not find BroadcastRecord class!")
            return
        }

        val hook = object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam) {
                try {
                    val record = param.args.firstOrNull { it != null && brClass.isInstance(it) } ?: return
                    val intent = XposedHelpers.getObjectField(record, "intent") as? Intent ?: return

                    if (isGcmOrFcmIntent(intent)) {
                        intent.flags = intent.flags or FLAG_INCLUDE_STOPPED_PACKAGES
                        (XposedHelpers.getObjectField(record, "receivers") as? List<*>)?.forEach { receiver ->
                            try {
                                val uid = (XposedHelpers.getObjectField(receiver, "app") as? Any)?.let { XposedHelpers.getIntField(it, "uid") }
                                    ?: (receiver as? ResolveInfo)?.activityInfo?.applicationInfo?.uid
                                uid?.let { requestWakeupForUid(it, WakeupType.FCM_PUSH) }
                            } catch (ignored: Throwable) {}
                        }
                    }
                } catch (t: Throwable) { logError("Error in BroadcastQueue hook: ${t.message}") }
            }
        }

        // 尝试的方法名列表保持不变
        val potentialMethodNames = listOf("processNextBroadcast", "processNextBroadcastLocked", "scheduleReceiverLocked", "scheduleReceiverColdLocked")
        var hookedCount = 0
        for (methodName in potentialMethodNames) {
            concreteBqClass.declaredMethods.filter { it.name == methodName }.forEach {
                try {
                    XposedBridge.hookMethod(it, hook)
                    log("SUCCESS: Hooked ${concreteBqClass.simpleName}#${it.name} for robust FCM capture.")
                    hookedCount++
                } catch (t: Throwable) {
                    log("WARN: Failed to hook ${concreteBqClass.simpleName}#${it.name}: ${t.message}")
                }
            }
        }

        if (hookedCount == 0) {
            logError("FATAL: Could not hook any broadcast processing method in ${concreteBqClass.name}.")
        }
    }


    // --- 其他所有方法保持不变 ---
    // (此处省略了所有未改动的函数，以保持简洁，实际使用时请保留它们)

    private fun hookNmsConstructor(classLoader: ClassLoader) {
        try {
            val nmsClass = XposedHelpers.findClass("com.android.server.notification.NotificationManagerService", classLoader)
            XposedBridge.hookAllConstructors(nmsClass, object : XC_MethodHook() {
                override fun afterHookedMethod(param: MethodHookParam) {
                    if (nmsInstance == null) {
                        nmsInstance = param.thisObject
                        try {
                            val context = XposedHelpers.callMethod(nmsInstance, "getContext") as Context
                            packageManager = context.packageManager
                            log("SUCCESS: Captured NotificationManagerService instance and PackageManager.")
                        } catch (t: Throwable) {
                            logError("Failed to get Context or PackageManager from NMS instance: $t")
                        }
                    }
                }
            })
        } catch (t: Throwable) { logError("Could not hook NMS constructor: ${t.message}") }
    }

    private fun hookNotificationService(classLoader: ClassLoader) {
        val nmsClass = findClass("com.android.server.notification.NotificationManagerService", classLoader) ?: run {
            logError("FATAL: Could not find NotificationManagerService class!")
            return
        }

        val hook = object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam) {
                val pm = packageManager ?: return
                try {
                    val pkg = param.args.firstOrNull { it is String } as? String ?: return
                    val notification = param.args.find { it is Notification } as? Notification ?: return

                    val targetUid: Int
                    try {
                        targetUid = pm.getApplicationInfo(pkg, 0).uid
                    } catch (e: PackageManager.NameNotFoundException) { return }
                    catch (t: Throwable) {
                        logError("Unexpected error while getting UID for package '$pkg': ${t.message}")
                        return
                    }

                    if (ConfigManager.isUidFrozen(targetUid)) {
                        val channel = try {
                            nmsInstance?.let { XposedHelpers.callMethod(it, "getNotificationChannelForPackage", pkg, targetUid, notification.channelId, false) as? NotificationChannel }
                        } catch (t: Throwable) { null }

                        if (channel != null && channel.importance < NotificationManager.IMPORTANCE_DEFAULT) {
                            log("Ignoring low-importance notification for frozen UID $targetUid")
                            return
                        }

                        requestWakeupForUid(targetUid, WakeupType.GENERIC_NOTIFICATION)
                    }
                } catch (t: Throwable) { logError("CRITICAL Error in NMS hook: ${t.javaClass.simpleName} - ${t.message}") }
            }
        }

        var hookCount = 0
        nmsClass.declaredMethods.filter { it.name == "enqueueNotificationInternal" }.forEach {
            try { XposedBridge.hookMethod(it, hook); hookCount++ }
            catch (t: Throwable) { logError("Failed to hook a variant of enqueueNotificationInternal: $t") }
        }

        if (hookCount > 0) log("SUCCESS: Hooked $hookCount NMS#enqueueNotificationInternal methods.")
        else logError("FATAL: No NMS#enqueueNotificationInternal methods were hooked.")
    }

    private fun requestWakeupForUid(uid: Int, type: WakeupType) {
        if (uid >= Process.FIRST_APPLICATION_UID && ConfigManager.isUidFrozen(uid)) {
            val reason = when(type) {
                WakeupType.FCM_PUSH -> "FCM"
                WakeupType.GENERIC_NOTIFICATION -> "Notification"
                else -> "Wakeup"
            }
            log("WAKEUP: Requesting temporary unfreeze for UID $uid, Reason: $reason")
            sendEventToDaemon("event.app_wakeup_request_v2", mapOf("uid" to uid, "type_int" to type.value))
        }
    }

    private fun sendEventToDaemon(type: String, payload: Any) {
        Thread {
            val message = CerberusMessage(type = type, payload = payload)
            val jsonMessage = gson.toJson(message)
            try {
                Socket(DAEMON_HOST, DAEMON_PORT).use { socket ->
                    socket.soTimeout = 2000
                    OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8).use { writer ->
                        writer.write(jsonMessage + "\n"); writer.flush()
                        if (type == "event.probe_hello") {
                            try {
                                socket.getInputStream().bufferedReader(StandardCharsets.UTF_8).readLine()?.let {
                                    ConfigManager.updateConfig(it)
                                }
                            } catch (e: Exception) { logError("Failed to read config response after hello: $e") }
                        }
                    }
                }
            } catch (e: IOException) {
                if (e.message?.contains("ECONNREFUSED") != true) { logError("Daemon short-conn send error for $type: ${e.message}") }
            } catch (e: Exception) { logError("Unexpected error during short-conn send for $type: $e") }
        }.start()
    }

    private object ConfigManager {
        @Volatile var isBqHooked = false
        @Volatile private var frozenUids = emptySet<Int>()
        fun updateConfig(jsonString: String) {
            try {
                val payload = JsonParser.parseString(jsonString).asJsonObject.getAsJsonObject("payload")
                if (payload.has("frozen_uids")) {
                    frozenUids = payload.getAsJsonArray("frozen_uids").map { it.asInt }.toSet()
                }
                if (frozenUids.isNotEmpty()) XposedBridge.log("[$TAG]: Config updated. Tracking ${frozenUids.size} UIDs.")
            } catch (e: Exception) { XposedBridge.log("[$TAG]: [ERROR] Failed to parse probe config: $e") }
        }
        fun isUidFrozen(uid: Int): Boolean = frozenUids.contains(uid)
    }

    private fun log(message: String) = XposedBridge.log("[$TAG] $message")
    private fun logError(message: String) = XposedBridge.log("[$TAG] [ERROR] $message")
    private fun findClass(className: String, classLoader: ClassLoader): Class<*>? = XposedHelpers.findClassIfExists(className, classLoader)
    private fun hookActivitySwitchEvents(classLoader: ClassLoader) {
        findClass("com.android.server.am.ActivityManagerService", classLoader)?.let { clazz ->
            val hook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    try {
                        val componentName = param.args[0] as? ComponentName ?: return
                        val userId = param.args[1] as Int
                        val event = param.args[2] as Int
                        sendEventToDaemon(
                            if (event == USAGE_EVENT_ACTIVITY_RESUMED) "event.app_foreground" else "event.app_background",
                            AppInstanceKey(componentName.packageName, userId)
                        )
                    } catch (t: Throwable) { logError("Error in hookActivitySwitchEvents: ${t.message}") }
                }
            }
            clazz.declaredMethods.find { it.name == "updateActivityUsageStats" && it.parameterCount >= 3 }
                ?.let { XposedBridge.hookMethod(it, hook); log("SUCCESS: Hooked ActivityManagerService#updateActivityUsageStats.") }
                ?: logError("FATAL: Could not find ActivityManagerService#updateActivityUsageStats method!")
        } ?: logError("FATAL: Could not find com.android.server.am.ActivityManagerService class!")
    }
    private fun hookTaskTrimming(classLoader: ClassLoader) {
        findClass("com.android.server.wm.RecentTasks", classLoader)?.let {
            XposedBridge.hookAllMethods(it, "trimInactiveRecentTasks", XC_MethodReplacement.DO_NOTHING)
            log("SUCCESS: Hooked and disabled RecentTasks#trimInactiveRecentTasks.")
        } ?: logError("WARN: Could not find com.android.server.wm.RecentTasks class.")
    }
    private fun hookSystemFreezer(classLoader: ClassLoader) {
        findClass("com.android.server.am.CachedAppOptimizer", classLoader)?.let {
            XposedBridge.hookAllMethods(it, "useFreezer", XC_MethodReplacement.returnConstant(false))
            log("SUCCESS: Hooked and disabled system's CachedAppOptimizer freezer.")
        } ?: log("INFO: Did not find com.android.server.am.CachedAppOptimizer (normal on older Android).")
    }
    private fun hookAnrHelper(classLoader: ClassLoader) {
        findClass("com.android.server.am.AnrHelper", classLoader)?.let { clazz ->
            val anrHook = object: XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val processRecord = param.args.find { it != null && it.javaClass.name.endsWith("ProcessRecord") } ?: return
                    if (ConfigManager.isUidFrozen(XposedHelpers.getIntField(processRecord, "uid"))) {
                        log("PROTECT: Suppressing ANR for frozen UID: ${XposedHelpers.getIntField(processRecord, "uid")}")
                        param.result = null
                    }
                }
            }
            clazz.declaredMethods.filter { it.name.contains("appNotResponding") }.forEach { XposedBridge.hookMethod(it, anrHook) }
            log("SUCCESS: Hooked all ANR methods in AnrHelper.")
        }
    }
    private fun hookWakelocksAndAlarms(classLoader: ClassLoader) {
        findClass("com.android.server.power.PowerManagerService", classLoader)?.let { pmsClass ->
            val wlHook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val uidArg = param.args.find { it is Int && it >= Process.FIRST_APPLICATION_UID } as? Int
                    if (uidArg != null && ConfigManager.isUidFrozen(uidArg)) {
                        log("DEFENSE: Blocked acquireWakeLock for frozen uid: $uidArg")
                        param.result = null
                    }
                }
            }
            pmsClass.declaredMethods.filter { it.name.startsWith("acquireWakeLock") }.forEach { XposedBridge.hookMethod(it, wlHook) }
            log("SUCCESS: Hooked PowerManagerService wakelock acquisition methods.")
        }
        findClass("com.android.server.alarm.AlarmManagerService", classLoader)?.let { amsClass ->
            val alarmHook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    (param.args.firstOrNull { it is ArrayList<*> } as? ArrayList<*>)?.removeIf { alarm ->
                        ConfigManager.isUidFrozen(XposedHelpers.getIntField(alarm!!, "uid")).also {
                            if (it) log("DEFENSE: Blocked alarm for frozen UID: ${XposedHelpers.getIntField(alarm, "uid")}")
                        }
                    }
                }
            }
            amsClass.declaredMethods.filter { it.name.contains("triggerAlarms") }.forEach { XposedBridge.hookMethod(it, alarmHook) }
            log("SUCCESS: Hooked AlarmManagerService alarm trigger methods.")
        }
    }
    private fun hookActivityStarter(classLoader: ClassLoader) {
        findClass("com.android.server.wm.ActivityStarter", classLoader)?.let { clazz ->
            val executeHook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    try {
                        val request = param.args.find { it != null && it.javaClass.name == "com.android.server.wm.ActivityStarter\$Request" } ?: return
                        if (XposedHelpers.getIntField(request, "callingUid") >= Process.FIRST_APPLICATION_UID) {
                            (XposedHelpers.getObjectField(request, "intent") as? Intent)?.component?.packageName?.let { pkg ->
                                val userId = XposedHelpers.getIntField(request, "userId")
                                log("PROACTIVE: Activity start for $pkg (user $userId). Requesting unfreeze.")
                                sendEventToDaemon("cmd.proactive_unfreeze", AppInstanceKey(pkg, userId))
                            }
                        }
                    } catch (t: Throwable) { logError("Error in ActivityStarter#execute hook: $t") }
                }
            }
            XposedBridge.hookAllMethods(clazz, "execute", executeHook)
            log("SUCCESS: Hooked ActivityStarter#execute for proactive unfreezing.")
        } ?: logError("FATAL: Could not find ActivityStarter class!")
    }
    private fun hookServices(classLoader: ClassLoader) {
        findClass("com.android.server.am.ActiveServices", classLoader)?.let { clazz ->
            val hook = object: XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val serviceRecord = param.args.find { it != null && it.javaClass.name.endsWith("ServiceRecord") } ?: return
                    val appInfo = XposedHelpers.getObjectField(serviceRecord, "appInfo") as? ApplicationInfo ?: return
                    if (ConfigManager.isUidFrozen(appInfo.uid)) {
                        log("DEFENSE: Blocked service startup for frozen app: ${appInfo.packageName}")
                        param.result = null
                    }
                }
            }
            clazz.declaredMethods.filter { it.name.contains("bringUpService") }.forEach { XposedBridge.hookMethod(it, hook) }
            log("SUCCESS: Hooked ActiveServices service startup methods.")
        }
    }
    private fun isGcmOrFcmIntent(intent: Intent): Boolean {
        return intent.action?.let { it == "com.google.android.c2dm.intent.RECEIVE" || it == "com.google.firebase.MESSAGING_EVENT" } ?: false
    }
    private data class AppInstanceKey(val package_name: String, val user_id: Int)
}
```

app/src/main/java/com/crfzit/crfzit/MainActivity.kt
```
// app/src/main/java/com/crfzit/crfzit/MainActivity.kt
package com.crfzit.crfzit

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import com.crfzit.crfzit.ui.theme.CRFzitTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            CRFzitTheme {
               Surface(
                   modifier = Modifier.fillMaxSize(),
                   color = MaterialTheme.colorScheme.background
               ) {
                   MainScreen()
               }
            }
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/MainScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/MainScreen.kt
package com.crfzit.crfzit

import androidx.compose.foundation.layout.padding
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import com.crfzit.crfzit.navigation.Screen
import com.crfzit.crfzit.ui.configuration.ConfigurationScreen
import com.crfzit.crfzit.ui.configuration.ConfigurationViewModel
import com.crfzit.crfzit.ui.dashboard.DashboardScreen
import com.crfzit.crfzit.ui.dashboard.DashboardViewModel
import com.crfzit.crfzit.ui.logs.LogsScreen
import com.crfzit.crfzit.ui.settings.SettingsScreen
import com.crfzit.crfzit.ui.settings.SettingsViewModel

@Composable
fun MainScreen() {
    val navController = rememberNavController()
    val screens = listOf(
        Screen.Dashboard,
        Screen.Configuration,
        Screen.Logs,
        Screen.Settings
    )

    Scaffold(
        bottomBar = {
            NavigationBar {
                val navBackStackEntry by navController.currentBackStackEntryAsState()
                val currentDestination = navBackStackEntry?.destination

                screens.forEach { screen ->
                    NavigationBarItem(
                        icon = { Icon(screen.icon, contentDescription = screen.label) },
                        label = { Text(screen.label) },
                        selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,
                        onClick = {
                            navController.navigate(screen.route) {
                                popUpTo(navController.graph.findStartDestination().id) {
                                    saveState = true
                                }
                                launchSingleTop = true
                                restoreState = true
                            }
                        }
                    )
                }
            }
        }
    ) { innerPadding ->
        NavHost(
            navController = navController,
            startDestination = Screen.Dashboard.route,
            modifier = Modifier.padding(innerPadding)
        ) {
            composable(Screen.Dashboard.route) {
                // ViewModel 在此级别创建，可以实现跨屏幕共享
                val dashboardViewModel: DashboardViewModel = viewModel()
                DashboardScreen(viewModel = dashboardViewModel)
            }
            composable(Screen.Configuration.route) {
                val configViewModel: ConfigurationViewModel = viewModel()
                ConfigurationScreen(navController = navController, viewModel = configViewModel)
            }
            composable(Screen.Logs.route) { LogsScreen() }
            composable(Screen.Settings.route) { 
                val settingsViewModel: SettingsViewModel = viewModel()
                SettingsScreen(viewModel = settingsViewModel)
             }
            // composable(Screen.ProfileManagement.route) { ... } // 未来实现
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/navigation/Screen.kt
```
// app/src/main/java/com/crfzit/crfzit/navigation/Screen.kt
package com.crfzit.crfzit.navigation

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Settings
import androidx.compose.ui.graphics.vector.ImageVector
import com.crfzit.crfzit.ui.icons.AppIcons

sealed class Screen(val route: String, val label: String, val icon: ImageVector) {
    data object Dashboard : Screen("dashboard", "主页", AppIcons.Dashboard)
    data object Configuration : Screen("configuration", "配置", AppIcons.Tune)
    data object Logs : Screen("logs", "日志", AppIcons.ListAlt)
    data object Settings : Screen("settings", "设置", Icons.Default.Settings)
    // [FIX] Correctly refer to the icon defined in AppIcons
    data object ProfileManagement : Screen("profile_management", "情景模式", AppIcons.Style)
}
```

app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationScreen.kt
package com.crfzit.crfzit.ui.configuration

import android.graphics.Bitmap
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import com.crfzit.crfzit.R
import com.crfzit.crfzit.coil.AppIcon
import com.crfzit.crfzit.data.model.AppInfo
import com.crfzit.crfzit.data.model.AppInstanceKey
import com.crfzit.crfzit.data.model.AppPolicyPayload

enum class Policy(val value: Int, val displayName: String) {
    EXEMPTED(0, "豁免"),
    STANDARD(2, "智能"),
    STRICT(3, "严格");

    companion object {
        fun fromInt(value: Int) = entries.find { it.value == value } ?: EXEMPTED
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ConfigurationScreen(
    navController: NavController,
    viewModel: ConfigurationViewModel
) {
    val uiState by viewModel.uiState.collectAsState()

    val filteredApps = remember(uiState.searchQuery, uiState.showSystemApps, uiState.policies) {
        viewModel.getFilteredAndSortedApps()
    }

    Scaffold(
        topBar = { TopAppBar(title = { Text("应用配置") }) }
    ) { padding ->
        Column(Modifier.padding(padding)) {
            OutlinedTextField(
                value = uiState.searchQuery,
                onValueChange = viewModel::onSearchQueryChanged,
                modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp),
                label = { Text("搜索应用或包名") },
                leadingIcon = { Icon(Icons.Default.Search, null) },
                singleLine = true
            )

            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
                    .clickable { viewModel.onShowSystemAppsChanged(!uiState.showSystemApps) },
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text("显示系统应用", modifier = Modifier.weight(1f))
                Switch(
                    checked = uiState.showSystemApps,
                    onCheckedChange = viewModel::onShowSystemAppsChanged
                )
            }

            if (uiState.isLoading) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                }
            } else {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(filteredApps, key = { "${it.packageName}-${it.userId}" }) { appInfo ->
                        val key = AppInstanceKey(appInfo.packageName, appInfo.userId)
                        val policyPayload = uiState.policies[key]
                            ?: AppPolicyPayload(appInfo.packageName, appInfo.userId, Policy.EXEMPTED.value)

                        AppPolicyItem(
                            appInfo = appInfo,
                            policy = Policy.fromInt(policyPayload.policy),
                            onPolicyChange = { newPolicy ->
                                viewModel.setAppPolicy(appInfo.packageName, appInfo.userId, newPolicy.value)
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun AppPolicyItem(
    appInfo: AppInfo,
    policy: Policy,
    onPolicyChange: (Policy) -> Unit
) {
    var showMenu by remember { mutableStateOf(false) }
    val itemAlpha = if (policy == Policy.EXEMPTED) 0.7f else 1.0f

    Card(modifier = Modifier.fillMaxWidth().alpha(itemAlpha)) {
        Row(
            modifier = Modifier
                .padding(16.dp)
                .clickable { showMenu = true },
            verticalAlignment = Alignment.CenterVertically
        ) {
            Image(
                // [内存优化] 与DashboardScreen同样的核心改动，使用Coil按需加载
                painter = rememberAsyncImagePainter(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(AppIcon(appInfo.packageName))
                        .size(73)
                        .bitmapConfig(Bitmap.Config.RGB_565)
                        .placeholder(R.drawable.ic_launcher_foreground)
                        .error(R.drawable.ic_launcher_foreground)
                        .build()
                ),
                contentDescription = appInfo.appName,
                modifier = Modifier.size(40.dp)
            )
            Column(Modifier.weight(1f).padding(start = 16.dp)) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(appInfo.appName, fontWeight = FontWeight.Bold)
                    if (appInfo.userId != 0) {
                        Spacer(Modifier.width(4.dp))
                        Icon(
                            painter = painterResource(id = R.drawable.ic_clone),
                            contentDescription = "分身应用 (User ${appInfo.userId})",
                            modifier = Modifier.size(16.dp),
                            tint = MaterialTheme.colorScheme.secondary
                        )
                    }
                }
                Text(appInfo.packageName, style = MaterialTheme.typography.bodySmall)
            }

            Box {
                val (label, icon) = getPolicyLabelAndIcon(policy)
                Text(
                    text = "$icon $label",
                    color = if (policy == Policy.EXEMPTED) MaterialTheme.colorScheme.onSurfaceVariant else MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )

                DropdownMenu(
                    expanded = showMenu,
                    onDismissRequest = { showMenu = false }
                ) {
                    listOf(Policy.EXEMPTED, Policy.STANDARD, Policy.STRICT).forEach { p ->
                        DropdownMenuItem(
                            text = {
                                val (policyLabel, policyIcon) = getPolicyLabelAndIcon(p)
                                Text("$policyIcon $policyLabel")
                            },
                            onClick = {
                                onPolicyChange(p)
                                showMenu = false
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun getPolicyLabelAndIcon(policy: Policy): Pair<String, String> {
    return when (policy) {
        Policy.EXEMPTED -> policy.displayName to "🛡️"
        Policy.STANDARD -> policy.displayName to "⚙️"
        Policy.STRICT -> policy.displayName to "🧊"
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationViewModel.kt
package com.crfzit.crfzit.ui.configuration

import android.app.Application
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.*
import com.crfzit.crfzit.data.repository.AppInfoRepository
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

data class ConfigurationUiState(
    val isLoading: Boolean = true,
    // [内存优化] allInstalledApps 列表现在非常轻量，因为它不包含图标
    val allInstalledApps: List<AppInfo> = emptyList(),
    val policies: Map<AppInstanceKey, AppPolicyPayload> = emptyMap(),
    val fullConfig: FullConfigPayload? = null,
    val searchQuery: String = "",
    val showSystemApps: Boolean = false
)

class ConfigurationViewModel(application: Application) : AndroidViewModel(application) {

    private val daemonRepository = DaemonRepository.getInstance()
    private val appInfoRepository = AppInfoRepository.getInstance(application)
    private val packageManager: PackageManager = application.packageManager

    private val _uiState = MutableStateFlow(ConfigurationUiState())
    val uiState: StateFlow<ConfigurationUiState> = _uiState.asStateFlow()

    init {
        loadConfiguration()
    }

    fun getFilteredAndSortedApps(): List<AppInfo> {
        val state = _uiState.value
        return state.allInstalledApps
            .filter { appInfo ->
                (state.showSystemApps || !appInfo.isSystemApp) &&
                        (appInfo.appName.contains(state.searchQuery, ignoreCase = true) ||
                                appInfo.packageName.contains(state.searchQuery, ignoreCase = true))
            }
            .sortedWith(
                compareByDescending<AppInfo> {
                    val key = AppInstanceKey(it.packageName, it.userId)
                    state.policies[key]?.policy ?: 0
                }.thenBy { it.appName.lowercase() }
            )
    }

    fun loadConfiguration() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }

            // [内存优化] 这两个调用现在都非常快且内存占用低
            val launchableApps = getAllLaunchableApps()
            val configPayload = daemonRepository.getAllPolicies()
            val daemonPolicyMap = configPayload?.policies?.associateBy {
                AppInstanceKey(it.packageName, it.userId)
            } ?: emptyMap()

            val finalAppMap = launchableApps.associateBy {
                AppInstanceKey(it.packageName, it.userId)
            }.toMutableMap()

            daemonPolicyMap.values.forEach { policy ->
                val key = AppInstanceKey(policy.packageName, policy.userId)
                if (!finalAppMap.containsKey(key) && policy.userId != 0) {
                    val baseAppInfo = appInfoRepository.getAppInfo(policy.packageName)
                    finalAppMap[key] = AppInfo(
                        packageName = policy.packageName,
                        appName = baseAppInfo?.appName ?: policy.packageName,
                        // [内存优化] 不再加载和存储Drawable对象
                        isSystemApp = baseAppInfo?.isSystemApp ?: false,
                        userId = policy.userId
                    )
                }
            }

            _uiState.update {
                it.copy(
                    isLoading = false,
                    allInstalledApps = finalAppMap.values.toList(),
                    policies = daemonPolicyMap,
                    fullConfig = configPayload
                )
            }
        }
    }

    private suspend fun getAllLaunchableApps(): List<AppInfo> = withContext(Dispatchers.IO) {
        val intent = Intent(Intent.ACTION_MAIN, null).apply {
            addCategory(Intent.CATEGORY_LAUNCHER)
        }
        packageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL)
            .mapNotNull { resolveInfo ->
                try {
                    val appInfo: ApplicationInfo = resolveInfo.activityInfo.applicationInfo
                    AppInfo(
                        packageName = appInfo.packageName,
                        appName = appInfo.loadLabel(packageManager).toString(),
                        isSystemApp = (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0,
                        userId = 0
                    )
                } catch (e: Exception) {
                    null
                }
            }
    }

    fun setAppPolicy(packageName: String, userId: Int, newPolicyValue: Int) {
        val currentConfig = _uiState.value.fullConfig ?: return

        val newPolicies = currentConfig.policies.toMutableList()
        val existingPolicyIndex = newPolicies.indexOfFirst { it.packageName == packageName && it.userId == userId }

        if (existingPolicyIndex != -1) {
            newPolicies[existingPolicyIndex] = newPolicies[existingPolicyIndex].copy(policy = newPolicyValue)
        } else {
            newPolicies.add(AppPolicyPayload(packageName, userId, newPolicyValue))
        }

        val newConfig = currentConfig.copy(policies = newPolicies)
        _uiState.update {
            it.copy(
                policies = newPolicies.associateBy { p -> AppInstanceKey(p.packageName, p.userId) },
                fullConfig = newConfig
            )
        }
        daemonRepository.setPolicy(newConfig)
    }

    fun onSearchQueryChanged(query: String) {
        _uiState.update { it.copy(searchQuery = query) }
    }

    fun onShowSystemAppsChanged(show: Boolean) {
        _uiState.update { it.copy(showSystemApps = show) }
    }

    override fun onCleared() {
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardScreen.kt
package com.crfzit.crfzit.ui.dashboard

import android.graphics.Bitmap
import androidx.compose.animation.Crossfade
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import com.crfzit.crfzit.R
import com.crfzit.crfzit.coil.AppIcon
import com.crfzit.crfzit.data.model.AppRuntimeState
import com.crfzit.crfzit.data.model.GlobalStats
import com.crfzit.crfzit.data.system.NetworkSpeed
import com.crfzit.crfzit.ui.icons.AppIcons
import com.crfzit.crfzit.ui.theme.CRFzitTheme
import com.google.accompanist.swiperefresh.SwipeRefresh
import com.google.accompanist.swiperefresh.rememberSwipeRefreshState
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardScreen(viewModel: DashboardViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    var showMenu by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("主页") },
                actions = {
                    IconButton(onClick = { showMenu = true }) {
                        Icon(Icons.Default.MoreVert, contentDescription = "更多")
                    }
                    DropdownMenu(
                        expanded = showMenu,
                        onDismissRequest = { showMenu = false }
                    ) {
                        DropdownMenuItem(
                            text = { Text(if (uiState.showSystemApps) "隐藏系统应用" else "显示系统应用") },
                            onClick = {
                                viewModel.onShowSystemAppsChanged(!uiState.showSystemApps)
                                showMenu = false
                            }
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        Crossfade(
            targetState = uiState.isConnected,
            modifier = Modifier.padding(paddingValues),
            label = "ConnectionState"
        ) { isConnected ->
            if (isConnected) {
                SwipeRefresh(
                    state = rememberSwipeRefreshState(isRefreshing = uiState.isRefreshing),
                    onRefresh = { viewModel.refresh() }
                ) {
                    DashboardContent(
                        globalStats = uiState.globalStats,
                        networkSpeed = uiState.networkSpeed,
                        apps = uiState.apps
                    )
                }
            } else {
                ConnectionLoadingIndicator()
            }
        }
    }
}


@Composable
fun DashboardContent(
    globalStats: GlobalStats,
    networkSpeed: NetworkSpeed,
    apps: List<UiAppRuntime>
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        item {
            GlobalStatusArea(stats = globalStats, speed = networkSpeed)
        }
        item {
            Text(
                text = "运行状态列表",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(top = 8.dp, bottom = 4.dp)
            )
        }
        items(apps, key = { "${it.runtimeState.packageName}-${it.runtimeState.userId}" }) { app ->
            AppRuntimeCard(app = app)
        }
    }
}

@Composable
fun AppRuntimeCard(app: UiAppRuntime) {
    val state = app.runtimeState
    Card {
        Row(
            modifier = Modifier.padding(12.dp).fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Image(
                // [内存优化] 这里是核心改动。我们不再直接使用Drawable，
                // 而是让Coil通过我们自定义的AppIcon数据类和Fetcher来加载图标。
                // 这实现了按需加载、缓存、分辨率和色深控制等所有优化。
                painter = rememberAsyncImagePainter(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(AppIcon(state.packageName)) // 使用自定义数据类作为请求模型
                        .size(73) // 限制图片加载的最大尺寸为73x73像素
                        .bitmapConfig(Bitmap.Config.RGB_565)
                        .placeholder(R.drawable.ic_launcher_foreground) // 使用一个轻量级占位符
                        .error(R.drawable.ic_launcher_foreground)
                        .build()
                ),
                contentDescription = app.appName,
                modifier = Modifier.size(48.dp)
            )
            
            Column(
                modifier = Modifier.weight(1f).padding(horizontal = 12.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(
                        text = app.appName,
                        fontWeight = FontWeight.Bold,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis,
                        modifier = Modifier.weight(1f, fill = false)
                    )
                    if (app.userId != 0) {
                        Spacer(Modifier.width(4.dp))
                        Icon(
                            painter = painterResource(id = R.drawable.ic_clone),
                            contentDescription = "分身应用 (User ${app.userId})",
                            modifier = Modifier.size(16.dp),
                            tint = MaterialTheme.colorScheme.secondary
                        )
                    }
                    Spacer(Modifier.weight(1f))
                    AppStatusIcons(state = state)
                }
                
                val resourceText = buildAnnotatedString {
                    append("MEM: ${formatMemory(state.memUsageKb)}")
                    if (state.swapUsageKb > 1024) {
                        withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f))) {
                            append(" (+${formatMemory(state.swapUsageKb)} S)")
                        }
                    }
                    append(" | CPU: ${"%.1f".format(state.cpuUsagePercent)}%")
                }

                Text(
                    text = resourceText,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                Text(
                    text = "状态：${formatStatus(state)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
fun GlobalStatusArea(stats: GlobalStats, speed: NetworkSpeed) {
    val memUsedPercent = if (stats.totalMemKb > 0) {
        (stats.totalMemKb - stats.availMemKb).toFloat() / stats.totalMemKb
    } else 0f
    
    val swapUsedPercent = if (stats.swapTotalKb > 0) {
        (stats.swapTotalKb - stats.swapFreeKb).toFloat() / stats.swapTotalKb
    } else 0f
    
    val cpuUsedPercent = stats.totalCpuUsagePercent / 100f
    
    val downSpeed = formatSpeed(speed.downloadSpeedBps)
    val upSpeed = formatSpeed(speed.uploadSpeedBps)

    Column(modifier = Modifier.padding(bottom = 8.dp)) {
        Text(
            text = "系统状态",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold,
            modifier = Modifier
                .align(Alignment.CenterHorizontally)
                .padding(bottom = 12.dp)
        )
        
        LazyVerticalGrid(
            columns = GridCells.Fixed(2),
            modifier = Modifier.height(180.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            userScrollEnabled = false
        ) {
            item {
                StatusGridItem(
                    label = "CPU",
                    value = "%.1f".format(Locale.US, stats.totalCpuUsagePercent) + "%",
                    progress = cpuUsedPercent,
                    icon = AppIcons.Memory
                )
            }
            item {
                StatusGridItem(
                    label = "内存 (MEM)",
                    value = formatMemory(stats.totalMemKb - stats.availMemKb),
                    progress = memUsedPercent,
                    icon = AppIcons.SdStorage
                )
            }
            item {
                 StatusGridItem(
                    label = "交换 (SWAP)",
                    value = formatMemory(stats.swapTotalKb - stats.swapFreeKb),
                    progress = swapUsedPercent,
                    icon = AppIcons.SwapHoriz
                )
            }
            item {
                StatusGridItem(
                    label = "网络",
                    value = "↓${downSpeed.first} | ↑${upSpeed.first}",
                    subValue = "${downSpeed.second} / ${upSpeed.second}",
                    icon = AppIcons.Wifi
                )
            }
        }
    }
}

@Composable
fun StatusGridItem(
    label: String,
    value: String,
    subValue: String? = null,
    progress: Float? = null,
    icon: ImageVector
) {
    Card(
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant),
        shape = MaterialTheme.shapes.large
    ) {
        Column(Modifier.padding(12.dp).fillMaxSize()) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(icon, contentDescription = label, modifier = Modifier.size(18.dp))
                Spacer(Modifier.width(8.dp))
                Text(label, style = MaterialTheme.typography.labelLarge)
            }
            Spacer(Modifier.weight(1f))
            if (subValue != null) {
                 Text(value, style = MaterialTheme.typography.titleMedium)
                 Text(subValue, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)
            } else {
                Text(value, style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.SemiBold)
            }
            if (progress != null) {
                Spacer(Modifier.height(4.dp))
                LinearProgressIndicator(
                    progress = { progress ?: 0f },
                    modifier = Modifier.fillMaxWidth().height(6.dp).clip(CircleShape)
                )
            }
        }
    }
}

@Composable
fun AppStatusIcons(state: AppRuntimeState) {
    Row {
        val iconModifier = Modifier.padding(horizontal = 2.dp)
        if (state.isForeground) Text("▶️", iconModifier)
        if (state.isWhitelisted) Text("🛡️", iconModifier)
        if (state.displayStatus.uppercase() == "FROZEN") {
            Text("❄️", iconModifier)
        }
    }
}

@Composable
fun ConnectionLoadingIndicator() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            CircularProgressIndicator()
            Spacer(Modifier.height(16.dp))
            Text("正在连接到守护进程...")
        }
    }
}

private fun formatMemory(kb: Long): String {
    if (kb <= 0) return "0 KB"
    val mb = kb / 1024.0
    val gb = mb / 1024.0
    return when {
        gb >= 1 -> "%.1f GB".format(Locale.US, gb)
        mb >= 1 -> "%.1f MB".format(Locale.US, mb)
        else -> "$kb KB"
    }
}

private fun formatSpeed(bitsPerSecond: Long): Pair<String, String> {
    if (bitsPerSecond < 50000) return Pair("0.0", "Kbps")
    return when {
        bitsPerSecond < 1_000_000 -> Pair("%.1f".format(Locale.US, bitsPerSecond / 1000.0), "Kbps")
        else -> Pair("%.1f".format(Locale.US, bitsPerSecond / 1_000_000.0), "Mbps")
    }
}

private fun formatStatus(state: AppRuntimeState): String {
    val status = state.displayStatus.uppercase()
    return when {
        status.startsWith("PENDING_FREEZE") -> {
            val time = status.substringAfter("(").substringBefore("s")
            "等待冻结 (${time}s)"
        }
        status.startsWith("OBSERVING") -> {
            val time = status.substringAfter("(").substringBefore("s")
            "后台观察中 (${time}s)"
        }
        status == "STOPPED" -> "未运行"
        status == "FROZEN" -> "已冻结"
        status == "FOREGROUND" -> "前台运行"
        status == "EXEMPTED_BACKGROUND" -> "后台运行 (已豁免)"
        status == "BACKGROUND" -> "后台运行"
        else -> state.displayStatus
    }
}

@Preview(showBackground = true)
@Composable
fun DashboardPreview() {
    CRFzitTheme {
        DashboardContent(
            globalStats = GlobalStats(),
            networkSpeed = NetworkSpeed(),
            apps = emptyList()
        )
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardViewModel.kt
package com.crfzit.crfzit.ui.dashboard

import android.app.Application
// [内存优化] 不再需要Drawable
// import android.graphics.drawable.Drawable
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.AppRuntimeState
import com.crfzit.crfzit.data.model.GlobalStats
import com.crfzit.crfzit.data.repository.AppInfoRepository
import com.crfzit.crfzit.data.repository.DaemonRepository
import com.crfzit.crfzit.data.system.NetworkMonitor
import com.crfzit.crfzit.data.system.NetworkSpeed
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class UiAppRuntime(
    val runtimeState: AppRuntimeState,
    val appName: String,
    // [内存优化] 移除 icon 字段
    // val icon: Drawable?,
    val isSystem: Boolean,
    val userId: Int
)

data class DashboardUiState(
    val isConnected: Boolean = false,
    val isRefreshing: Boolean = false,
    val globalStats: GlobalStats = GlobalStats(),
    val networkSpeed: NetworkSpeed = NetworkSpeed(),
    val apps: List<UiAppRuntime> = emptyList(),
    val showSystemApps: Boolean = false
)

class DashboardViewModel(application: Application) : AndroidViewModel(application) {

    private val daemonRepository = DaemonRepository.getInstance()
    private val appInfoRepository = AppInfoRepository.getInstance(application)
    private val networkMonitor = NetworkMonitor()

    private val _uiState = MutableStateFlow(DashboardUiState())
    val uiState: StateFlow<DashboardUiState> = _uiState.asStateFlow()

    init {
        viewModelScope.launch {
            // 预热应用信息缓存，但不加载图标
            appInfoRepository.getAllApps(forceRefresh = true)

            combine(
                daemonRepository.getDashboardStream(),
                networkMonitor.getSpeedStream(),
                _uiState.map { it.showSystemApps }.distinctUntilChanged()
            ) { dashboardPayload, speed, showSystem ->
                
                val uiAppRuntimes = dashboardPayload.appsRuntimeState
                    .mapNotNull { runtimeState ->
                        // appInfoRepository 现在返回不含图标的轻量级对象
                        val appInfo = appInfoRepository.getAppInfo(runtimeState.packageName)
                        appInfo?.let {
                            UiAppRuntime(
                                runtimeState = runtimeState,
                                appName = it.appName,
                                // [内存优化] 不再传递 icon
                                // icon = it.icon,
                                isSystem = it.isSystemApp,
                                userId = runtimeState.userId
                            )
                        }
                    }
                    .filter { showSystem || !it.isSystem }
                    .sortedWith(
                        compareBy<UiAppRuntime> { !it.runtimeState.isForeground }
                            .thenByDescending { it.runtimeState.memUsageKb }
                    )

                _uiState.value.copy(
                    isConnected = true,
                    isRefreshing = false,
                    globalStats = dashboardPayload.globalStats,
                    networkSpeed = speed,
                    apps = uiAppRuntimes,
                    showSystemApps = showSystem
                )
            }
                .onStart { _uiState.update { it.copy(isConnected = false) } }
                .catch { emit(_uiState.value.copy(isConnected = false)) }
                .collect { newState ->
                    _uiState.value = newState
                }
        }
    }

    fun refresh() {
        viewModelScope.launch {
            _uiState.update { it.copy(isRefreshing = true) }
            daemonRepository.requestDashboardRefresh()
        }
    }

    fun onShowSystemAppsChanged(show: Boolean) {
        _uiState.update { it.copy(showSystemApps = show) }
    }

    override fun onCleared() {
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/icons/AppIcons.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/icons/AppIcons.kt
package com.crfzit.crfzit.ui.icons

import androidx.compose.material.icons.materialIcon
import androidx.compose.material.icons.materialPath
import androidx.compose.ui.graphics.vector.ImageVector

/**
 * 单例对象，用于存放所有手动提取的 Material Design 图标。
 * 这样做可以避免对 material-icons-extended 库的依赖，确保编译稳定性和UI一致性。
 */
object AppIcons {

    val Dashboard: ImageVector by lazy { materialIcon("Filled.Dashboard") {
        materialPath {
            moveTo(3.0f, 13.0f); horizontalLineToRelative(8.0f); lineTo(11.0f, 3.0f); lineTo(3.0f, 3.0f); verticalLineToRelative(10.0f); close()
            moveTo(3.0f, 21.0f); horizontalLineToRelative(8.0f); verticalLineToRelative(-6.0f); lineTo(3.0f, 15.0f); verticalLineToRelative(6.0f); close()
            moveTo(13.0f, 21.0f); horizontalLineToRelative(8.0f); lineTo(21.0f, 11.0f); horizontalLineToRelative(-8.0f); verticalLineToRelative(10.0f); close()
            moveTo(13.0f, 3.0f); verticalLineToRelative(6.0f); horizontalLineToRelative(8.0f); lineTo(21.0f, 3.0f); horizontalLineToRelative(-8.0f); close()
        }
    } }

    val Tune: ImageVector by lazy { materialIcon("Filled.Tune") {
        materialPath {
            moveTo(3.0f, 17.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(6.0f); verticalLineToRelative(-2.0f); lineTo(3.0f, 17.0f); close()
            moveTo(3.0f, 5.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(10.0f); lineTo(13.0f, 5.0f); lineTo(3.0f, 5.0f); close()
            moveTo(13.0f, 21.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(8.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(-8.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(-2.0f); verticalLineToRelative(6.0f); horizontalLineToRelative(2.0f); close()
            moveTo(7.0f, 9.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(-4.0f); lineTo(3.0f, 9.0f); lineTo(7.0f, 9.0f); close()
            moveTo(21.0f, 13.0f); verticalLineToRelative(-2.0f); lineTo(11.0f, 11.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(10.0f); close()
            moveTo(15.0f, 9.0f); horizontalLineToRelative(6.0f); lineTo(21.0f, 7.0f); horizontalLineToRelative(-6.0f); verticalLineToRelative(2.0f); close()
        }
    } }

    val ListAlt: ImageVector by lazy { materialIcon("AutoMirrored.Filled.ListAlt") {
        materialPath {
            moveTo(19.0f, 5.0f); verticalLineTo(3.0f); horizontalLineTo(5.0f); curveTo(3.9f, 3.0f, 3.0f, 3.9f, 3.0f, 5.0f); verticalLineToRelative(14.0f); curveToRelative(0.0f, 1.1f, 0.9f, 2.0f, 2.0f, 2.0f); horizontalLineToRelative(14.0f); curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f); verticalLineTo(5.0f); horizontalLineTo(19.0f); close()
            moveTo(11.0f, 17.0f); horizontalLineTo(7.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(11.0f, 13.0f); horizontalLineTo(7.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(11.0f, 9.0f); horizontalLineTo(7.0f); verticalLineTo(7.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(17.0f, 17.0f); horizontalLineToRelative(-4.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(17.0f, 13.0f); horizontalLineToRelative(-4.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(17.0f, 9.0f); horizontalLineToRelative(-4.0f); verticalLineTo(7.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
        }
    } }

    val Style: ImageVector by lazy { materialIcon("Filled.Style") {
        materialPath {
            moveTo(2.53f, 19.65f); lineToRelative(1.34f, -1.34f); curveTo(4.96f, 17.7f, 6.0f, 17.21f, 7.0f, 17.21f); curveToRelative(0.53f, 0.0f, 1.04f, 0.11f, 1.5f, 0.31f); lineTo(12.0f, 14.0f); lineTo(3.0f, 5.0f); verticalLineTo(2.0f); horizontalLineToRelative(3.0f); lineToRelative(1.5f, 1.5f); curveTo(8.66f, 2.34f, 10.27f, 2.0f, 12.0f, 2.0f); curveToRelative(2.21f, 0.0f, 4.0f, 1.79f, 4.0f, 4.0f); curveToRelative(0.0f, 1.19f, -0.52f, 2.25f, -1.33f, 3.0f); lineToRelative(2.45f, 2.45f); curveTo(17.63f, 11.23f, 18.0f, 10.64f, 18.0f, 10.0f); curveToRelative(0.0f, -0.12f, -0.01f, -0.23f, -0.02f, -0.34f); curveToRelative(0.42f, -0.23f, 0.81f, -0.53f, 1.15f, -0.89f); lineToRelative(1.34f, 1.34f); curveToRelative(-0.56f, 0.56f, -1.24f, 1.0f, -1.97f, 1.29f); curveToRelative(0.01f, 0.12f, 0.01f, 0.24f, 0.01f, 0.36f); curveToRelative(0.0f, 1.3f, -0.83f, 2.4f, -2.0f, 2.83f); verticalLineTo(23.0f); horizontalLineToRelative(-3.0f); verticalLineTo(15.0f); horizontalLineToRelative(1.0f); curveToRelative(0.55f, 0.0f, 1.0f, -0.45f, 1.0f, -1.0f); reflectiveCurveToRelative(-0.45f, -1.0f, -1.0f, -1.0f); horizontalLineTo(9.41f); lineTo(7.91f, 14.5f); curveToRelative(-0.2f, 0.45f, -0.31f, 0.96f, -0.31f, 1.5f); curveToRelative(0.0f, 1.0f, 0.3f, 1.96f, 0.84f, 2.79f); lineToRelative(-1.34f, 1.34f); curveTo(6.01f, 19.06f, 5.76f, 18.15f, 5.76f, 17.21f); curveToRelative(0.0f, -1.08f, 0.33f, -2.09f, 0.89f, -2.93f); lineTo(2.53f, 10.15f); curveToRelative(-0.56f, 0.84f, -0.89f, 1.85f, -0.89f, 2.93f); curveToRelative(0.0f, 0.94f, 0.25f, 1.85f, 0.71f, 2.65f); lineTo(2.53f, 19.65f); close()
            moveTo(12.0f, 8.0f); curveToRelative(-1.1f, 0.0f, -2.0f, -0.9f, -2.0f, -2.0f); reflectiveCurveToRelative(0.9f, -2.0f, 2.0f, -2.0f); reflectiveCurveToRelative(2.0f, 0.9f, 2.0f, 2.0f); reflectiveCurveToRelative(-0.9f, 2.0f, -2.0f, 2.0f); close()
        }
    } }

    val Memory: ImageVector by lazy { materialIcon(name = "Filled.Memory") {
        materialPath {
            moveTo(15.0f, 9.0f); lineTo(9.0f, 9.0f); verticalLineToRelative(6.0f); horizontalLineToRelative(6.0f); lineTo(15.0f, 9.0f); close()
            moveTo(21.0f, 11.0f); lineTo(21.0f, 9.0f); horizontalLineToRelative(-2.0f); lineTo(19.0f, 7.0f); curveToRelative(0.0f, -1.1f, -0.9f, -2.0f, -2.0f, -2.0f); horizontalLineToRelative(-2.0f); lineTo(15.0f, 3.0f); horizontalLineToRelative(-2.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(-2.0f); lineTo(11.0f, 3.0f); lineTo(9.0f, 3.0f); verticalLineToRelative(2.0f); lineTo(7.0f, 5.0f); curveToRelative(-1.1f, 0.0f, -2.0f, 0.9f, -2.0f, 2.0f); verticalLineToRelative(2.0f); lineTo(3.0f, 9.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); lineTo(3.0f, 13.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); curveToRelative(0.0f, 1.1f, 0.9f, 2.0f, 2.0f, 2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(-2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); close()
            moveTo(17.0f, 17.0f); lineTo(7.0f, 17.0f); lineTo(7.0f, 7.0f); horizontalLineToRelative(10.0f); verticalLineToRelative(10.0f); close()
        }
    } }
    val SdStorage: ImageVector by lazy { materialIcon(name = "Filled.SdStorage") {
        materialPath {
            moveTo(18.0f, 2.0f); lineTo(10.0f, 2.0f); lineTo(4.0f, 8.0f); verticalLineToRelative(12.0f); curveToRelative(0.0f, 1.1f, 0.9f, 2.0f, 2.0f, 2.0f); horizontalLineToRelative(12.0f); curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f); lineTo(20.0f, 4.0f); curveToRelative(0.0f, -1.1f, -0.9f, -2.0f, -2.0f, -2.0f); close()
            moveTo(12.0f, 4.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(4.0f); horizontalLineToRelative(-4.0f); lineTo(12.0f, 4.0f); close()
        }
    } }
    val SwapHoriz: ImageVector by lazy { materialIcon(name = "Filled.SwapHoriz") {
        materialPath {
            moveTo(6.99f, 11.0f); lineTo(3.0f, 15.0f); lineToRelative(3.99f, 4.0f); verticalLineToRelative(-3.0f); horizontalLineTo(14.0f); verticalLineToRelative(-2.0f); horizontalLineTo(6.99f); verticalLineToRelative(-3.0f); close()
            moveTo(21.0f, 9.0f); lineToRelative(-3.99f, -4.0f); verticalLineToRelative(3.0f); horizontalLineTo(10.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(7.01f); verticalLineToRelative(3.0f); lineTo(21.0f, 9.0f); close()
        }
    } }
    val Wifi: ImageVector by lazy { materialIcon(name = "Filled.Wifi") {
        materialPath {
            moveTo(1.0f, 9.0f); lineToRelative(2.0f, 2.0f); curveToRelative(4.97f, -4.97f, 13.03f, -4.97f, 18.0f, 0.0f); lineToRelative(2.0f, -2.0f); curveTo(16.93f, 2.93f, 7.07f, 2.93f, 1.0f, 9.0f); close()
            moveTo(9.0f, 17.0f); lineToRelative(3.0f, 3.0f); lineToRelative(3.0f, -3.0f); curveToRelative(-1.65f, -1.66f, -4.34f, -1.66f, -6.0f, 0.0f); close()
            moveTo(5.0f, 13.0f); lineToRelative(2.0f, 2.0f); curveToRelative(2.76f, -2.76f, 7.24f, -2.76f, 10.0f, 0.0f); lineToRelative(2.0f, -2.0f); curveTo(15.14f, 9.14f, 8.86f, 9.14f, 5.0f, 13.0f); close()
        }
    } }
    val GitHub: ImageVector by lazy { materialIcon(name = "Custom.GitHub") {
        materialPath {
            moveTo(12f, 2f)
            curveTo(6.48f, 2f, 2f, 6.48f, 2f, 12f)
            curveToRelative(0f, 4.42f, 2.87f, 8.17f, 6.84f, 9.5f)
            curveToRelative(0.5f, 0.09f, 0.68f, -0.22f, 0.68f, -0.48f)
            curveToRelative(0f, -0.24f, -0.01f, -0.82f, -0.01f, -1.6f)
            curveToRelative(-2.78f, 0.6f, -3.37f, -1.34f, -3.37f, -1.34f)
            curveToRelative(-0.45f, -1.16f, -1.11f, -1.47f, -1.11f, -1.47f)
            curveToRelative(-0.91f, -0.62f, 0.07f, -0.61f, 0.07f, -0.61f)
            curveToRelative(1f, 0.07f, 1.53f, 1.03f, 1.53f, 1.03f)
            curveToRelative(0.9f, 1.52f, 2.34f, 1.08f, 2.91f, 0.83f)
            curveToRelative(0.09f, -0.65f, 0.35f, -1.08f, 0.63f, -1.33f)
            curveToRelative(-2.22f, -0.25f, -4.55f, -1.11f, -4.55f, -4.94f)
            curveToRelative(0f, -1.1f, 0.39f, -1.99f, 1.03f, -2.69f)
            curveToRelative(-0.1f, -0.25f, -0.45f, -1.27f, 0.1f, -2.65f)
            curveToRelative(0f, 0f, 0.84f, -0.27f, 2.75f, 1.02f)
            curveToRelative(0.8f, -0.22f, 1.65f, -0.33f, 2.5f, -0.33f)
            curveToRelative(0.85f, 0f, 1.7f, 0.11f, 2.5f, 0.33f)
            curveToRelative(1.91f, -1.29f, 2.75f, -1.02f, 2.75f, -1.02f)
            curveToRelative(0.55f, 1.38f, 0.2f, 2.4f, 0.1f, 2.65f)
            curveToRelative(0.64f, 0.7f, 1.03f, 1.6f, 1.03f, 2.69f)
            curveToRelative(0f, 3.84f, -2.34f, 4.68f, -4.57f, 4.93f)
            curveToRelative(0.36f, 0.31f, 0.68f, 0.92f, 0.68f, 1.85f)
            curveToRelative(0f, 1.34f, -0.01f, 2.42f, -0.01f, 2.75f)
            curveToRelative(0f, 0.27f, 0.18f, 0.58f, 0.69f, 0.48f)
            curveTo(19.13f, 20.17f, 22f, 16.42f, 22f, 12f)
            curveTo(22f, 6.48f, 17.52f, 2f, 12f, 2f)
            close()
        }
    } }
}
```

app/src/main/java/com/crfzit/crfzit/ui/logs/LogsScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/logs/LogsScreen.kt
package com.crfzit.crfzit.ui.logs

import android.graphics.RenderEffect
import android.graphics.Shader
import android.os.Build
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.PathEffect
import androidx.compose.ui.graphics.asComposeRenderEffect
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.crfzit.crfzit.data.model.LogLevel
import com.crfzit.crfzit.ui.stats.StatisticsScreen
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LogsScreen(viewModel: LogsViewModel = viewModel()) {
    var selectedTab by remember { mutableIntStateOf(0) }
    val tabs = listOf("事件时间线", "资源统计")

    Scaffold(topBar = { TopAppBar(title = { Text("日志与统计") }) }) { padding ->
        Column(Modifier.padding(padding)) {
            PrimaryTabRow(selectedTabIndex = selectedTab) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = selectedTab == index,
                        onClick = { selectedTab = index },
                        text = { Text(title) }
                    )
                }
            }
            when (selectedTab) {
                0 -> EventTimelineTab(viewModel)
                1 -> StatisticsScreen()
            }
        }
    }
}

@Composable
fun EventTimelineTab(viewModel: LogsViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    val listState = rememberLazyListState()

    // [核心修复] 2. 修正自动滚动逻辑，防止干扰用户操作
    LaunchedEffect(viewModel, listState) {
        snapshotFlow { uiState.timelineItems.firstOrNull()?.id }
            .distinctUntilChanged()
            .collect { newId ->
                // 只有当新日志到来，且用户当前完全在列表顶部时，才自动滚动
                if (newId != null && listState.firstVisibleItemIndex == 0) {
                    listState.animateScrollToItem(0)
                }
            }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        MaterialTheme.colorScheme.surface,
                        MaterialTheme.colorScheme.surfaceContainerLow
                    )
                )
            )
    ) {
        if (uiState.isLoading && uiState.timelineItems.isEmpty()) {
            CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
        } else {
            LazyColumn(
                state = listState,
                modifier = Modifier.fillMaxSize(),
                contentPadding = PaddingValues(horizontal = 12.dp, vertical = 8.dp),
                verticalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                items(items = uiState.timelineItems, key = { it.id }) { item ->
                    when (item) {
                        is SingleLogItem -> LogCard(item.log)
                        is LogGroupItem -> ReportGroupCard(item)
                    }
                }
                if (uiState.isLoadingMore) {
                    item {
                        Row(modifier = Modifier.fillMaxWidth().padding(8.dp), horizontalArrangement = Arrangement.Center) {
                            CircularProgressIndicator()
                        }
                    }
                }
            }

            val shouldLoadMore by remember {
                derivedStateOf {
                    val li = listState.layoutInfo
                    val isAtBottom = li.visibleItemsInfo.lastOrNull()?.index == li.totalItemsCount - 1
                    isAtBottom && !uiState.isLoadingMore && !uiState.hasReachedEnd
                }
            }
            LaunchedEffect(shouldLoadMore) {
                if (shouldLoadMore) {
                    viewModel.loadMoreLogs()
                }
            }
        }
    }
}

// 正确实现高斯模糊毛玻璃效果的基类
@Composable
fun GlassmorphicCard(
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit
) {
    val shape = RoundedCornerShape(16.dp)
    Box(modifier = modifier.clip(shape)) {
        Box(
            modifier = Modifier
                .matchParentSize()
                .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f))
                .then(
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                        Modifier.graphicsLayer(
                            renderEffect = RenderEffect
                                .createBlurEffect(25f, 25f, Shader.TileMode.DECAL)
                                .asComposeRenderEffect()
                        )
                    } else {
                        Modifier
                    }
                )
        )
        content()
    }
}

// 普通日志卡片
@Composable
fun LogCard(log: UiLogEntry) {
    GlassmorphicCard {
        LogItemContent(log = log)
    }
}

// [核心修复] 1. 实现了统一报告在一个卡片中的布局
@Composable
fun ReportGroupCard(group: LogGroupItem) {
    GlassmorphicCard {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            ReportHeader(log = group.parentLog)
            HorizontalDivider(
                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
                color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.2f)
            )
            Column(
                verticalArrangement = Arrangement.spacedBy(8.dp),
                modifier = Modifier.padding(bottom = 8.dp)
            ) {
                group.childLogs.forEach { childLog ->
                    LogItemContent(log = childLog)
                }
            }
        }
    }
}

@Composable
private fun ReportHeader(log: UiLogEntry) {
    val (icon, color) = getLogAppearance(log.originalLog.level)
    val formatter = remember { SimpleDateFormat("HH:mm:ss", Locale.getDefault()) }
    Column(
        modifier = Modifier.padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = icon,
            fontSize = 28.sp,
            color = color.takeIf { it != Color.Unspecified } ?: MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(4.dp))
        Text(
            text = log.originalLog.message,
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(Modifier.height(4.dp))
        Text(
            text = formatter.format(Date(log.originalLog.timestamp)),
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

@Composable
fun DashedVerticalDivider() {
    val pathEffect = PathEffect.dashPathEffect(floatArrayOf(10f, 10f), 0f)
    val color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.4f)
    Canvas(Modifier.fillMaxHeight().width(1.dp)) {
        drawLine(
            color = color,
            start = Offset(0f, 0f),
            end = Offset(0f, size.height),
            pathEffect = pathEffect
        )
    }
}

@Composable
fun LogItemContent(log: UiLogEntry) {
    val originalLog = log.originalLog
    val formatter = remember { SimpleDateFormat("HH:mm:ss", Locale.getDefault()) }
    val (icon, color) = getLogAppearance(originalLog.level)

    val annotatedString = buildAnnotatedString {
        if (originalLog.level == LogLevel.REPORT) {
            val messageParts = originalLog.message.split('\n')
            val title = log.appName ?: messageParts.firstOrNull() ?: ""
            val details = messageParts.drop(1).joinToString("\n")
            withStyle(style = SpanStyle(fontWeight = FontWeight.SemiBold, color = MaterialTheme.colorScheme.primary)) { append(title) }
            if (details.isNotEmpty()) {
                withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onSurfaceVariant, fontSize = 13.sp)) { append("\n$details") }
            }
        } else if (originalLog.category != "报告" && !log.appName.isNullOrEmpty()) {
            append("应用 ‘")
            withStyle(style = SpanStyle(fontWeight = FontWeight.SemiBold, color = MaterialTheme.colorScheme.primary)) { append(log.appName) }
            append("’ "); append(originalLog.message)
        } else {
            append(originalLog.message)
        }
    }

    Row(
        modifier = Modifier.fillMaxWidth().height(IntrinsicSize.Min).padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier.width(90.dp).padding(horizontal = 8.dp)
        ) {
            Text(
                text = icon,
                fontSize = 24.sp,
                color = color.takeIf { it != Color.Unspecified } ?: MaterialTheme.colorScheme.onSurface
            )
            Spacer(Modifier.height(4.dp))
            Text(
                text = formatter.format(Date(originalLog.timestamp)),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                fontSize = 11.sp
            )
        }
        DashedVerticalDivider()
        Column(modifier = Modifier.padding(start = 12.dp, end = 16.dp).weight(1f)) {
            Text(
                text = "[${originalLog.category}]",
                style = MaterialTheme.typography.labelMedium,
                fontWeight = FontWeight.Bold,
                color = color.takeIf { it != Color.Unspecified } ?: MaterialTheme.colorScheme.primary,
                fontFamily = FontFamily.Monospace
            )
            Spacer(Modifier.height(4.dp))
            Text(
                text = annotatedString,
                style = MaterialTheme.typography.bodyMedium.copy(lineHeight = 20.sp)
            )
        }
    }
}

@Composable
fun getLogAppearance(level: LogLevel): Pair<String, Color> {
    return when (level) {
        LogLevel.INFO -> "ℹ️" to MaterialTheme.colorScheme.outline
        LogLevel.SUCCESS -> "✅" to Color(0xFF34A853)
        LogLevel.WARN -> "⚠️" to Color(0xFFFBBC05)
        LogLevel.ERROR -> "❌" to MaterialTheme.colorScheme.error
        LogLevel.EVENT -> "⚡" to MaterialTheme.colorScheme.primary
        LogLevel.DOZE -> "🌙" to Color(0xFF6650a4)
        LogLevel.BATTERY -> "🔋" to Color(0xFF0B8043)
        LogLevel.REPORT -> "📊" to Color(0xFF1A73E8)
        LogLevel.ACTION_OPEN -> "▶️" to Color.Unspecified
        LogLevel.ACTION_CLOSE -> "⏹️" to MaterialTheme.colorScheme.onSurfaceVariant
        LogLevel.ACTION_FREEZE -> "❄️" to Color(0xFF4285F4)
        LogLevel.ACTION_UNFREEZE -> "☀️" to Color(0xFFF4B400)
        LogLevel.ACTION_DELAY -> "⏳" to Color(0xFFE52592)
        LogLevel.TIMER -> "⏰" to Color(0xFFF25622)
        LogLevel.BATCH_PARENT -> "📦" to Color.Unspecified
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/logs/LogsViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/logs/LogsViewModel.kt
package com.crfzit.crfzit.ui.logs

import android.app.Application
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.LogEntry
import com.crfzit.crfzit.data.model.LogLevel
import com.crfzit.crfzit.data.repository.AppInfoRepository
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.UUID

// 数据模型保持不变
sealed interface TimelineItem {
    val id: String
    val timestamp: Long
}
data class SingleLogItem(val log: UiLogEntry) : TimelineItem {
    override val id: String = "${log.originalLog.timestamp}-${log.originalLog.level}-${log.originalLog.message}-${UUID.randomUUID()}"
    override val timestamp: Long = log.originalLog.timestamp
}
data class LogGroupItem(val parentLog: UiLogEntry, val childLogs: List<UiLogEntry>) : TimelineItem {
    override val id: String = "${parentLog.originalLog.timestamp}-group-${UUID.randomUUID()}"
    override val timestamp: Long = parentLog.originalLog.timestamp
}
data class UiLogEntry(val originalLog: LogEntry, val appName: String?)

data class LogsUiState(
    val isLoading: Boolean = true,
    val rawLogs: List<UiLogEntry> = emptyList(),
    val timelineItems: List<TimelineItem> = emptyList(),
    val isLoadingMore: Boolean = false,
    val hasReachedEnd: Boolean = false,
    val logFiles: List<String> = emptyList(),
    val currentFileIndex: Int = 0
)

class LogsViewModel(application: Application) : AndroidViewModel(application) {
    companion object {
        private const val PAGE_SIZE = 50
        // [核心新增] 控制内存中最多保留的日志条数
        private const val MAX_LOGS_IN_MEMORY = 1000
    }

    private val daemonRepository = DaemonRepository.getInstance()
    private val appInfoRepository = AppInfoRepository.getInstance(application)

    private val _uiState = MutableStateFlow(LogsUiState())
    val uiState: StateFlow<LogsUiState> = _uiState.asStateFlow()

    private var pollingJob: Job? = null
    private val uiStateUpdateMutex = Mutex()

    init {
        viewModelScope.launch {
            appInfoRepository.getAllApps(forceRefresh = true)
            loadInitialLogs()
            startPollingForNewLogs()
        }
    }

    private fun loadInitialLogs() {
        viewModelScope.launch {
            uiStateUpdateMutex.withLock {
                _uiState.value = LogsUiState(isLoading = true)
            }
            val files = daemonRepository.getLogFiles() ?: emptyList()
            if (files.isEmpty()) {
                _uiState.update { it.copy(isLoading = false, hasReachedEnd = true) }
                return@launch
            }
            val initialLogs = daemonRepository.getLogs(filename = files[0], limit = PAGE_SIZE) ?: emptyList()
            val uiHistory = initialLogs.map { mapToUiLog(it) }
            _uiState.update {
                it.copy(
                    isLoading = false,
                    rawLogs = uiHistory,
                    timelineItems = processLogsIntoTimelineItems(uiHistory),
                    logFiles = files,
                    currentFileIndex = 0,
                    hasReachedEnd = initialLogs.size < PAGE_SIZE && files.size <= 1
                )
            }
        }
    }

    fun loadMoreLogs() {
        viewModelScope.launch {
            if (_uiState.value.isLoadingMore || _uiState.value.hasReachedEnd) return@launch
            uiStateUpdateMutex.withLock {
                val currentState = _uiState.value
                if (currentState.isLoadingMore || currentState.hasReachedEnd) return@withLock
                _uiState.update { it.copy(isLoadingMore = true) }
                val lastLogTimestamp = currentState.rawLogs.lastOrNull()?.originalLog?.timestamp
                val currentFilename = currentState.logFiles.getOrNull(currentState.currentFileIndex)
                if (currentFilename == null || lastLogTimestamp == null) {
                    _uiState.update { it.copy(isLoadingMore = false, hasReachedEnd = true) }
                    return@withLock
                }
                var olderLogs = daemonRepository.getLogs(filename = currentFilename, before = lastLogTimestamp, limit = PAGE_SIZE) ?: emptyList()
                var nextFileIndex = currentState.currentFileIndex
                if (olderLogs.isEmpty() && currentState.currentFileIndex + 1 < currentState.logFiles.size) {
                    nextFileIndex = currentState.currentFileIndex + 1
                    olderLogs = daemonRepository.getLogs(filename = currentState.logFiles[nextFileIndex], limit = PAGE_SIZE) ?: emptyList()
                }
                val newUiLogs = if (olderLogs.isNotEmpty()) olderLogs.map { mapToUiLog(it) } else emptyList()

                // [核心修改] 确保加载更多时也不会超过内存上限
                val combinedRawLogs = (currentState.rawLogs + newUiLogs).takeLast(MAX_LOGS_IN_MEMORY)

                _uiState.update {
                    it.copy(
                        isLoadingMore = false,
                        rawLogs = combinedRawLogs,
                        timelineItems = processLogsIntoTimelineItems(combinedRawLogs),
                        currentFileIndex = nextFileIndex,
                        hasReachedEnd = olderLogs.size < PAGE_SIZE && nextFileIndex >= it.logFiles.size - 1
                    )
                }
            }
        }
    }

    private fun startPollingForNewLogs() {
        pollingJob?.cancel()
        pollingJob = viewModelScope.launch {
            while (true) {
                delay(3000)
                try {
                    val latestTimestamp = _uiState.value.rawLogs.firstOrNull()?.originalLog?.timestamp
                    val files = daemonRepository.getLogFiles() ?: emptyList()
                    if (files.isEmpty()) continue
                    val newLogs = daemonRepository.getLogs(filename = files[0], since = latestTimestamp)
                    if (!newLogs.isNullOrEmpty()) {
                        val newUiLogs = newLogs.map { mapToUiLog(it) }
                        uiStateUpdateMutex.withLock {
                            val currentState = _uiState.value
                            // [核心修改] 合并并截断，确保内存占用可控
                            val combinedRawLogs = (newUiLogs + currentState.rawLogs)
                                .distinctBy { log -> "${log.originalLog.timestamp}-${log.originalLog.message}-${log.originalLog.level}" }
                                .sortedByDescending { log -> log.originalLog.timestamp }
                                .take(MAX_LOGS_IN_MEMORY)
                            _uiState.update {
                                it.copy(
                                    rawLogs = combinedRawLogs,
                                    timelineItems = processLogsIntoTimelineItems(combinedRawLogs),
                                    logFiles = if (files != currentState.logFiles) files else currentState.logFiles
                                )
                            }
                        }
                    } else if (files != _uiState.value.logFiles) {
                        _uiState.update { it.copy(logFiles = files) }
                    }
                } catch (e: Exception) {
                    Log.w("LogsViewModel", "Error polling for new logs: ${e.message}")
                }
            }
        }
    }

    private fun processLogsIntoTimelineItems(logs: List<UiLogEntry>): List<TimelineItem> {
        if (logs.isEmpty()) return emptyList()
        val result = mutableListOf<TimelineItem>()
        val sortedLogs = logs.sortedBy { it.originalLog.timestamp }
        var i = 0
        while (i < sortedLogs.size) {
            val currentLog = sortedLogs[i]
            if (currentLog.originalLog.level == LogLevel.BATCH_PARENT) {
                val children = mutableListOf<UiLogEntry>()
                var j = i + 1
                while (j < sortedLogs.size &&
                    sortedLogs[j].originalLog.level == LogLevel.REPORT &&
                    sortedLogs[j].originalLog.timestamp == currentLog.originalLog.timestamp
                ) {
                    children.add(sortedLogs[j])
                    j++
                }
                result.add(LogGroupItem(currentLog, children))
                i = if (children.isNotEmpty()) j else i + 1
            } else {
                result.add(SingleLogItem(currentLog))
                i++
            }
        }
        return result.asReversed()
    }

    private suspend fun mapToUiLog(log: LogEntry): UiLogEntry {
        val appName = log.packageName?.let { pkg ->
            val baseName = appInfoRepository.getAppInfo(pkg)?.appName
            if (log.userId != 0 && log.userId != -1) "$baseName (分身)" else baseName
        }
        if (log.level == LogLevel.REPORT) {
            val originalMessageTitle = log.message.substringBefore(" 总计:")
            return UiLogEntry(originalLog = log, appName = appName ?: originalMessageTitle)
        }
        return UiLogEntry(originalLog = log, appName = appName ?: log.packageName)
    }

    override fun onCleared() {
        pollingJob?.cancel()
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/profiles/ProfileManagementScreen.kt
```
package com.crfzit.crfzit.ui.profiles

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProfileManagementScreen(onNavigateBack: () -> Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("情景模式管理") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "返回")
                    }
                }
            )
        }
    ) { padding ->
        Box(
            modifier = Modifier.padding(padding).fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("情景模式管理功能 (待实现)")
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsScreen.kt
package com.crfzit.crfzit.ui.settings

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.crfzit.crfzit.ui.icons.AppIcons
import kotlin.math.roundToInt

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(viewModel: SettingsViewModel = viewModel()) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = { TopAppBar(title = { Text("设置") }) }
    ) { padding ->
        LazyColumn(
            modifier = Modifier.padding(padding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                SettingsGroup(title = "核心策略") {
                    TimeoutSlider(
                        title = "智能模式后台超时",
                        value = uiState.standardTimeoutSec.toFloat(),
                        onValueChange = { viewModel.setStandardTimeout(it.roundToInt()) },
                        valueRange = 30f..300f,
                        unit = "秒"
                    )
                }
            }

            item {
                SettingsGroup(title = "定时解冻 (心跳)") {
                    SwitchSetting(
                        title = "启用定时解冻",
                        subtitle = "定期唤醒应用以同步消息，平衡续航与通知",
                        checked = uiState.isTimedUnfreezeEnabled,
                        onCheckedChange = viewModel::setTimedUnfreezeEnabled
                    )

                    if (uiState.isTimedUnfreezeEnabled) {
                        Spacer(Modifier.height(16.dp))
                        TimeoutSlider(
                            title = "解冻间隔",
                            value = uiState.timedUnfreezeIntervalSec.toFloat(),
                            onValueChange = { viewModel.setTimedUnfreezeInterval(it.roundToInt()) },
                            valueRange = 300f..7200f,
                            unit = "分钟",
                            displayValueTransform = { (it / 60).roundToInt() }
                        )
                    }
                }
            }

            // [核心新增] “关于”区域
            item {
                SettingsGroup(title = "关于") {
                    InfoItem(title = "作者", value = "zzaolv")
                    Divider(modifier = Modifier.padding(vertical = 8.dp))
                    InfoItem(title = "构建时间", value = uiState.buildTime)
                    Divider(modifier = Modifier.padding(vertical = 8.dp))
                    ClickableInfoItem(
                        title = "项目地址（别点）",
                        icon = AppIcons.GitHub,
                        onClick = { viewModel.onGitHubIconClicked() }
                    )
                }
            }
        }
    }
}

// [核心新增] 可重用的信息展示行
@Composable
fun InfoItem(title: String, value: String) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.bodyLarge,
            modifier = Modifier.weight(1f)
        )
        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

// [核心新增] 可重用的、带图标的、可点击的信息行
@Composable
fun ClickableInfoItem(
    title: String,
    icon: ImageVector,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.bodyLarge,
            modifier = Modifier.weight(1f)
        )
        Icon(
            imageVector = icon,
            contentDescription = title,
            tint = MaterialTheme.colorScheme.primary
        )
    }
}


@Composable
fun SettingsGroup(title: String, content: @Composable ColumnScope.() -> Unit) {
    Card {
        Column(Modifier.padding(16.dp)) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.primary,
                modifier = Modifier.padding(bottom = 8.dp)
            )
            content()
        }
    }
}

@Composable
fun SwitchSetting(
    title: String,
    subtitle: String,
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onCheckedChange(!checked) },
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(title, style = MaterialTheme.typography.bodyLarge)
            Text(
                text = subtitle,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        Switch(
            checked = checked,
            onCheckedChange = onCheckedChange
        )
    }
}

@Composable
fun TimeoutSlider(
    title: String,
    value: Float,
    onValueChange: (Float) -> Unit,
    valueRange: ClosedFloatingPointRange<Float>,
    unit: String,
    displayValueTransform: (Float) -> Int = { it.roundToInt() }
) {
    var sliderPosition by remember(value) { mutableFloatStateOf(value) }

    Column {
        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(title, modifier = Modifier.weight(1f))
            Text(
                "${displayValueTransform(sliderPosition)} $unit",
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.primary,
                textDecoration = TextDecoration.Underline
            )
        }
        Slider(
            value = sliderPosition,
            onValueChange = { sliderPosition = it },
            valueRange = valueRange,
            steps = ((valueRange.endInclusive - valueRange.start) / (if(unit == "分钟") 300f else 10f)).roundToInt() - 1,
            onValueChangeFinished = {
                onValueChange(sliderPosition)
            }
        )
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsViewModel.kt
package com.crfzit.crfzit.ui.settings

import android.app.Application
import android.content.Intent
import android.net.Uri
import android.widget.Toast
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.BuildConfig // 导入自动生成的BuildConfig
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

data class SettingsUiState(
    val isLoading: Boolean = true,
    val standardTimeoutSec: Int = 90,
    val isTimedUnfreezeEnabled: Boolean = true,
    val timedUnfreezeIntervalSec: Int = 1800,
    // [核心新增] 新增用于显示构建时间的字段
    val buildTime: String = "N/A"
)

class SettingsViewModel(private val app: Application) : AndroidViewModel(app) {
    private val daemonRepository = DaemonRepository.getInstance()

    private val _uiState = MutableStateFlow(SettingsUiState())
    val uiState = _uiState.asStateFlow()

    // [核心新增] 定义原神相关的常量
    private companion object {
        const val GENSHIN_PACKAGE_NAME = "com.miHoYo.GenshinImpact"
        const val GENSHIN_URL = "https://ys.mihoyo.com/main/"
    }

    init {
        loadSettings()
        loadBuildInfo() // 在初始化时加载构建信息
    }

    private fun loadBuildInfo() {
        // [核心新增] 从BuildConfig获取时间戳并格式化
        try {
            val buildTimestamp = BuildConfig.BUILD_TIME
            val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault())
            _uiState.update { it.copy(buildTime = dateFormat.format(Date(buildTimestamp))) }
        } catch (e: Exception) {
            // In case of any error, keep the default "N/A"
        }
    }

    // [核心新增] 处理GitHub图标点击事件的恶趣味逻辑
    fun onGitHubIconClicked() {
        val packageManager = app.packageManager
        val launchIntent = packageManager.getLaunchIntentForPackage(GENSHIN_PACKAGE_NAME)

        if (launchIntent != null) {
            // 如果安装了原神，启动它！
            Toast.makeText(app, "正在启动...", Toast.LENGTH_SHORT).show()
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            app.startActivity(launchIntent)
        } else {
            // 如果没安装，跳转到官网
            Toast.makeText(app, "未检测到应用，正在前往官网...", Toast.LENGTH_SHORT).show()
            val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(GENSHIN_URL))
            browserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            app.startActivity(browserIntent)
        }
    }

    private fun loadSettings() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val config = daemonRepository.getAllPolicies()
            if (config != null) {
                val masterConfig = config.masterConfig
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        standardTimeoutSec = masterConfig.standardTimeoutSec,
                        isTimedUnfreezeEnabled = masterConfig.isTimedUnfreezeEnabled,
                        timedUnfreezeIntervalSec = masterConfig.timedUnfreezeIntervalSec
                    )
                }
            } else {
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }

    fun setStandardTimeout(seconds: Int) {
        _uiState.update { it.copy(standardTimeoutSec = seconds) }
        sendMasterConfigUpdate()
    }

    fun setTimedUnfreezeEnabled(isEnabled: Boolean) {
        _uiState.update { it.copy(isTimedUnfreezeEnabled = isEnabled) }
        sendMasterConfigUpdate()
    }

    fun setTimedUnfreezeInterval(seconds: Int) {
        _uiState.update { it.copy(timedUnfreezeIntervalSec = seconds) }
        sendMasterConfigUpdate()
    }

    private fun sendMasterConfigUpdate() {
        viewModelScope.launch {
            val currentState = _uiState.value
            val payload = mapOf(
                "standard_timeout_sec" to currentState.standardTimeoutSec,
                "is_timed_unfreeze_enabled" to currentState.isTimedUnfreezeEnabled,
                "timed_unfreeze_interval_sec" to currentState.timedUnfreezeIntervalSec
            )
            daemonRepository.setMasterConfig(payload)
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsScreen.kt
package com.crfzit.crfzit.ui.stats

import android.graphics.Paint
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.PathEffect
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.crfzit.crfzit.data.model.MetricsRecord
import kotlin.math.abs

private val ChartColors = listOf(
    Color(0xFFF44336), Color(0xFF4CAF50), Color(0xFF2196F3), Color(0xFFFFC107),
    Color(0xFF9C27B0), Color(0xFF00BCD4), Color(0xFFE91E63), Color(0xFFFF9800)
)

@Composable
fun StatisticsScreen(viewModel: StatisticsViewModel = viewModel()) {
    val uiState by viewModel.uiState.collectAsState()

    if (uiState.isLoading && uiState.records.isEmpty()) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            CircularProgressIndicator()
        }
    } else {
        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                val coreCount = uiState.records.firstOrNull()?.perCoreCpuUsagePercent?.size ?: 0
                ChartCard(title = "CPU 使用率 (%)") {
                    MultiLineChart(
                        records = uiState.records,
                        valueExtractor = { it.perCoreCpuUsagePercent },
                        range = 0f..100f
                    )
                    if (coreCount > 0) {
                        Spacer(Modifier.height(8.dp))
                        ChartLegend(coreCount = coreCount)
                    }
                }
            }
            item {
                ChartCard(title = "内存使用率 (%)") {
                    LineChart(
                        records = uiState.records,
                        color = Color(0xFF34A853),
                        valueExtractor = {
                            if (it.memTotalKb > 0) (it.memTotalKb - it.memAvailableKb) * 100f / it.memTotalKb else 0f
                        },
                        range = 0f..100f,
                        labelFormat = "%.1f%%"
                    )
                }
            }
            item {
                ChartCard(title = "电池温度 (°C)") {
                    LineChart(
                        records = uiState.records,
                        color = Color(0xFFF4B400),
                        valueExtractor = { it.batteryTempCelsius },
                        range = 20f..50f,
                        labelFormat = "%.1f°C"
                    )
                }
            }
        }
    }
}

@Composable
fun ChartCard(title: String, content: @Composable ColumnScope.() -> Unit) {
    Card(shape = RoundedCornerShape(16.dp)) {
        Column(Modifier.padding(horizontal = 16.dp, vertical = 20.dp)) {
            Text(title, style = MaterialTheme.typography.titleMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
            Spacer(Modifier.height(16.dp))
            content()
        }
    }
}

@Composable
fun ChartLegend(coreCount: Int) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(top = 4.dp),
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        for (i in 0 until coreCount) {
            val color = ChartColors.getOrElse(i) { Color.Gray }
            Box(modifier = Modifier.size(10.dp).background(color, shape = RoundedCornerShape(2.dp)))
            Text(text = "C${i}", style = MaterialTheme.typography.labelSmall, modifier = Modifier.padding(start = 4.dp, end = 12.dp))
        }
    }
}

@Composable
private fun rememberTextPaint(color: Color = Color.Black, spSize: Float = 12f, align: Paint.Align = Paint.Align.CENTER): Paint {
    val density = LocalDensity.current
    val textColor = color.toArgb()
    return remember(density, color, spSize, align) {
        Paint().apply {
            this.color = textColor; this.textAlign = align; this.textSize = with(density) { spSize.sp.toPx() }
        }
    }
}

fun DrawScope.drawChartScaffold(yRange: ClosedFloatingPointRange<Float>, yAxisPaint: Paint, yAxisLabelCount: Int = 5) {
    val gridPath = Path()
    val step = size.height / (yAxisLabelCount - 1)
    (0 until yAxisLabelCount).forEach { i ->
        val y = i * step
        gridPath.moveTo(0f, y); gridPath.lineTo(size.width, y)
        val labelValue = yRange.endInclusive - i * (yRange.endInclusive - yRange.start) / (yAxisLabelCount - 1)
        drawIntoCanvas { it.nativeCanvas.drawText("%.0f".format(labelValue), -12f, y + yAxisPaint.textSize / 3, yAxisPaint) }
    }
    drawPath(gridPath, Color.Gray.copy(alpha = 0.3f), style = Stroke(width = 1f, pathEffect = PathEffect.dashPathEffect(floatArrayOf(10f, 10f))))
}

private data class LabelInfo(val index: Int, val x: Float, val y: Float, val text: String, val priority: Int)

@Composable
fun LineChart(
    modifier: Modifier = Modifier,
    records: List<MetricsRecord>,
    color: Color,
    valueExtractor: (MetricsRecord) -> Float,
    range: ClosedFloatingPointRange<Float>? = null,
    labelFormat: String = "%.1f"
) {
    // [核心修复] 1. 创建三种对齐方式的画笔
    val leftTextPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurface, spSize = 10f, align = Paint.Align.LEFT)
    val centerTextPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurface, spSize = 10f, align = Paint.Align.CENTER)
    val rightTextPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurface, spSize = 10f, align = Paint.Align.RIGHT)
    val yAxisPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurfaceVariant, spSize = 10f, align = Paint.Align.RIGHT)
    val labelCollisionThreshold: Dp = 40.dp

    Canvas(modifier = modifier.fillMaxWidth().height(150.dp).padding(start = 32.dp)) {
        val yValues = records.map(valueExtractor)
        val yMin = range?.start ?: (yValues.minOrNull() ?: 0f)
        val yMax = range?.endInclusive ?: (yValues.maxOrNull() ?: 100f)
        val yRangeValue = (yMax - yMin).coerceAtLeast(1f)

        drawChartScaffold(yRange = yMin..yMax, yAxisPaint = yAxisPaint)
        if (records.isEmpty()) return@Canvas

        val xStep = if (records.size > 1) size.width / (records.size - 1) else size.width / 2
        val path = Path()

        val labelsToConsider = mutableMapOf<Int, LabelInfo>()
        if (records.isNotEmpty()) {
            val latestIndex = records.indices.last
            val minIndex = yValues.withIndex().minByOrNull { it.value }?.index ?: -1
            val maxIndex = yValues.withIndex().maxByOrNull { it.value }?.index ?: -1

            val latestY = size.height - ((yValues[latestIndex] - yMin) / yRangeValue * size.height)
            labelsToConsider[latestIndex] = LabelInfo(latestIndex, if (records.size == 1) xStep else latestIndex * xStep, latestY, labelFormat.format(yValues[latestIndex]), 3)

            if (maxIndex != -1) {
                val maxY = size.height - ((yValues[maxIndex] - yMin) / yRangeValue * size.height)
                labelsToConsider[maxIndex] = LabelInfo(maxIndex, if (records.size == 1) xStep else maxIndex * xStep, maxY, labelFormat.format(yValues[maxIndex]), 2)
            }
            if (minIndex != -1) {
                val minY = size.height - ((yValues[minIndex] - yMin) / yRangeValue * size.height)
                labelsToConsider[minIndex] = LabelInfo(minIndex, if (records.size == 1) xStep else minIndex * xStep, minY, labelFormat.format(yValues[minIndex]), 1)
            }
        }

        val finalLabels = mutableListOf<LabelInfo>()
        val sortedLabels = labelsToConsider.values.sortedByDescending { it.priority }
        for (label in sortedLabels) {
            var hasCollision = false
            for (existingLabel in finalLabels) {
                if (abs(label.x - existingLabel.x) < labelCollisionThreshold.toPx()) { hasCollision = true; break }
            }
            if (!hasCollision) { finalLabels.add(label) }
        }

        records.forEachIndexed { index, _ ->
            val x = if (records.size == 1) xStep else index * xStep
            val y = size.height - ((yValues[index] - yMin) / yRangeValue * size.height)
            if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)
            if (records.size == 1) drawCircle(color, radius = 8f, center = Offset(x, y))
        }
        if (records.size > 1) drawPath(path = path, color = color, style = Stroke(width = 4f))

        finalLabels.forEach { label ->
            // [核心修复] 2. 边界感知和动态对齐
            val paint = when {
                label.x < 20.dp.toPx() -> leftTextPaint // 靠近左边界，左对齐
                label.x > size.width - 20.dp.toPx() -> rightTextPaint // 靠近右边界，右对齐
                else -> centerTextPaint // 其他情况居中
            }
            // [核心修复] 3. 增强垂直避让
            val yOffset = when {
                label.y < 20f -> 30f // 离顶部太近，向下翻转
                label.y > size.height - 20f -> -30f // 离底部太近，向上翻转
                else -> -15f // 默认在上方
            }
            drawIntoCanvas {
                it.nativeCanvas.drawText(label.text, label.x, label.y + yOffset, paint)
            }
        }
    }
}

@Composable
fun MultiLineChart(
    modifier: Modifier = Modifier,
    records: List<MetricsRecord>,
    valueExtractor: (MetricsRecord) -> List<Float>,
    range: ClosedFloatingPointRange<Float>
) {
    val yAxisPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurfaceVariant, spSize = 10f, align = Paint.Align.RIGHT)
    Canvas(modifier = modifier.fillMaxWidth().height(150.dp).padding(start = 32.dp)) {
        drawChartScaffold(yRange = range, yAxisPaint = yAxisPaint)
        if (records.isEmpty()) return@Canvas
        val coreCount = records.first().perCoreCpuUsagePercent.size
        if (coreCount == 0) return@Canvas
        val xStep = if (records.size > 1) size.width / (records.size - 1) else size.width / 2
        for (coreIndex in 0 until coreCount) {
            val path = Path()
            val color = ChartColors.getOrElse(coreIndex) { Color.Gray }
            records.forEachIndexed { recordIndex, record ->
                val x = if (records.size == 1) xStep else recordIndex * xStep
                val yValue = record.perCoreCpuUsagePercent.getOrElse(coreIndex) { 0f }
                val y = size.height - ((yValue - range.start) / (range.endInclusive - range.start) * size.height)
                if (recordIndex == 0) path.moveTo(x, y) else path.lineTo(x, y)
                if (records.size == 1) drawCircle(color, radius = 8f, center = Offset(x, y))
            }
            if (records.size > 1) drawPath(path = path, color = color, style = Stroke(width = 4f))
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsViewModel.kt
package com.crfzit.crfzit.ui.stats

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.MetricsRecord
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class StatisticsUiState(
    val isLoading: Boolean = true,
    val records: List<MetricsRecord> = emptyList()
)

class StatisticsViewModel : ViewModel() {
    private val daemonRepository = DaemonRepository.getInstance()
    private val _uiState = MutableStateFlow(StatisticsUiState())
    val uiState: StateFlow<StatisticsUiState> = _uiState.asStateFlow()

    // [核心修改] 1. 定义一个27秒的时间窗口（单位：毫秒）
    private val timeWindowMs = 27_000L

    init {
        loadInitialStats()
        listenForNewStats()
    }

    private fun loadInitialStats() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val history = daemonRepository.getHistoryStats() ?: emptyList()

            // [核心修改] 2. 对初始加载的数据也应用时间窗口
            val filteredHistory = if (history.isNotEmpty()) {
                val latestTimestamp = history.last().timestamp
                history.filter { record ->
                    latestTimestamp - record.timestamp <= timeWindowMs
                }
            } else {
                emptyList()
            }

            _uiState.update { it.copy(isLoading = false, records = filteredHistory) }
        }
    }

    private fun listenForNewStats() {
        viewModelScope.launch {
            daemonRepository.getStatsStream().collect { newRecord ->
                _uiState.update { currentState ->
                    // [核心修改] 3. 实时维护一个滚动的时间窗口

                    // 将新记录添加到当前列表
                    val combinedList = currentState.records + newRecord

                    // 获取最新记录的时间戳作为基准
                    val latestTimestamp = newRecord.timestamp

                    // 过滤掉所有不在27秒时间窗口内的数据
                    val windowedList = combinedList.filter { record ->
                        latestTimestamp - record.timestamp <= timeWindowMs
                    }

                    currentState.copy(records = windowedList)
                }
            }
        }
    }

    // ViewModel的 onCleared 方法保持不变，无需修改
    override fun onCleared() {
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/theme/Color.kt
```
package com.crfzit.crfzit.ui.theme // 确保包名正确

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)
```

app/src/main/java/com/crfzit/crfzit/ui/theme/Theme.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/theme
package com.crfzit.crfzit.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40
)

@Composable
fun CRFzitTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            // 【全面屏适配】将状态栏设置为透明，让Scaffold来控制颜色
            window.statusBarColor = Color.Transparent.toArgb()
            // 【全面屏适配】设置导航栏颜色为透明，并确保内容和导航栏图标颜色对比度
            window.navigationBarColor = Color.Transparent.toArgb()
            // 设置状态栏图标颜色
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
            // 设置导航栏图标颜色
            WindowCompat.getInsetsController(window, view).isAppearanceLightNavigationBars = !darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
```

app/src/main/java/com/crfzit/crfzit/ui/theme/Type.kt
```
package com.crfzit.crfzit.ui.theme // 确保包名正确

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
)
```



settings.gradle.kts

// D:/project/Cerberus/settings.gradle.kts

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}

// 核心：这里是唯一且合并后的 dependencyResolutionManagement 块
dependencyResolutionManagement {
    // 仓库管理模式设置，保持不变
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)

    // 🇨🇳 把所有仓库都放在这一个 repositories 块里
    repositories {
        google()
        mavenCentral()
        // 🇨🇳 把 Xposed 的仓库也加到这里
        maven { url = uri("https://api.xposed.info/") }
    }
}

rootProject.name = "CRFzit" // 您可以修改为 "Cerberus"
include(":app")