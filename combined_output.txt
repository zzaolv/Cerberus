

.gitignore

*.iml
.gradle
/local.properties
/.idea/caches
/.idea/libraries
/.idea/modules.xml
/.idea/workspace.xml
/.idea/navEditor.xml
/.idea/assetWizardSettings.xml
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
.kotlin
local.properties
/magisk/Cerberus.zip
/magisk/cerberus-UI.apk
/magisk/cerberusd
daemon_context.txt
local.properties
daemon.py
collo.py
tree.py
project_context.txt
app/release/*
magisk/magisk.zip
magisk/system/bin/cerberusd
magisk/system/Cerberus-UI/Cerberus-UI.apk
hs_err_*.log
replay_*.log
magisk/Cerberus.apk



GEMINI.md

# è§’è‰²ï¼šé¦–å¸­å…¨æ ˆæ¶æ„å¸ˆã€Android å†…æ ¸ä¸Androidå¼€å‘ä¸“å®¶é¡¾é—®

## æ ¸å¿ƒèƒ½åŠ›ï¼š

- å…¨æ ˆè§†é‡ï¼šå…·å¤‡æ¨ªè·¨å‰ç«¯ã€åç«¯ã€ç§»åŠ¨ç«¯ã€ç½‘ç»œã€æ•°æ®åº“åŠäº‘åŸç”Ÿæ¶æ„çš„æ·±åšæŠ€æœ¯åŠŸåº•ã€‚
- é¡¹ç›®ä¼˜åŒ–ï¼šç²¾é€šæ€§èƒ½åˆ†æã€ä»£ç é‡æ„ã€æ¶æ„å‡çº§ï¼Œè‡´åŠ›äºæå‡é¡¹ç›®çš„**å¯ç”¨æ€§ã€å¯æ‰©å±•æ€§ä¸å¯ç»´æŠ¤æ€§**ã€‚
- è¯­è¨€å¤§å¸ˆï¼šç†Ÿç»ƒæŒæ¡ C/C++,JAVA ç­‰å¤šç§ä¸»æµç¼–ç¨‹è¯­è¨€åŠå…¶ç”Ÿæ€ï¼Œå¹¶èƒ½è¿…é€Ÿé€‚åº”ä»»ä½•æ–°æŠ€æœ¯æ ˆã€‚

## è¡ŒåŠ¨å‡†åˆ™ï¼š

- æ·±åº¦æ€è€ƒï¼šåˆ†æé—®é¢˜æ—¶ï¼Œç»¼åˆè¿ç”¨æ‰¹åˆ¤æ€§ã€åˆ›é€ æ€§ã€ç³»ç»Ÿæ€§æ€ç»´ï¼Œä¸ä»…è¦è§£å†³è¡¨é¢é—®é¢˜ï¼Œæ›´è¦æ´å¯Ÿå…¶**æ ¹æœ¬åŸå› **ï¼Œå¹¶æä¾›å…¼å…·**å‰ç»æ€§ä¸å®ç”¨æ€§**çš„è§£å†³æ–¹æ¡ˆã€‚
- ä¸­æ–‡æ²Ÿé€šï¼šæ‰€æœ‰æé—®ã€è§£é‡Šå’Œäº¤æµéƒ½å¿…é¡»ä½¿ç”¨**ç®€ä½“ä¸­æ–‡**è¿›è¡Œã€‚
- ä¸¥æ ¼æŒ‰ç…§ç”¨æˆ·éœ€æ±‚è§£å†³é—®é¢˜ã€‚

README.md

#  Cerberus - æ™ºèƒ½åå°ç®¡ç†ä¸ç³»ç»Ÿç›‘æ§å·¥å…·

![Project Cerberus Banner](https://img.shields.io/badge/Project-Cerberus-blueviolet?style=for-the-badge&logo=android)
![Language](https://img.shields.io/badge/Language-Kotlin%20%26%20C%2B%2B-orange?style=for-the-badge)
![License](https://img.shields.io/badge/License-MIT-green?style=for-the-badge)
![Status](https://img.shields.io/badge/Status-Active%20Development-brightgreen?style=for-the-badge)

**ä¸­æ–‡** | [English](#) 

---

## ğŸ“– é¡¹ç›®ç®€ä»‹

**Project Cerberus** æ˜¯ä¸€æ¬¾ä¸“ä¸º Android æå®¢å’Œé«˜çº§ç”¨æˆ·è®¾è®¡çš„ç³»ç»Ÿçº§åå°ç®¡ç†ä¸æ€§èƒ½ç›‘æ§å·¥å…·ã€‚å®ƒä¸ä»…æ˜¯ä¸€ä¸ªåº”ç”¨å†»ç»“å·¥å…·ï¼Œæ›´æ˜¯ä¸€ä¸ªæ·±åº¦èå…¥ç³»ç»Ÿã€å…·å¤‡æ™ºèƒ½ç­–ç•¥å’Œç²¾ç»†åŒ–æ§åˆ¶èƒ½åŠ›çš„â€œç³»ç»Ÿå‰¯è„‘â€ã€‚

é¡¹ç›®é‡‡ç”¨ç°ä»£åŒ–çš„æŠ€æœ¯æ ˆï¼ˆJetpack Compose, Kotlin Coroutines, C++17ï¼‰å’Œåˆ›æ–°çš„æ··åˆæ¶æ„ï¼ˆ`Xposed`+`Daemon`ï¼‰ï¼Œæ—¨åœ¨å®ç°æè‡´çš„æ€§èƒ½ã€åŠŸè€—ä¸é€šçŸ¥ä½“éªŒçš„å¹³è¡¡ã€‚

## âœ¨ æ ¸å¿ƒåŠŸèƒ½

*   **æ™ºèƒ½åº”ç”¨ç®¡ç†**ï¼š
    *   **å¤šç­–ç•¥å†»ç»“**ï¼šä¸ºæ¯ä¸ªåº”ç”¨è®¾ç½®â€œè±å…â€ã€â€œæ™ºèƒ½â€ã€â€œä¸¥æ ¼â€ç­‰ä¸åŒç®¡ç†ç­–ç•¥ã€‚
    *   **ä¼˜é›…å†»ç»“æŠ€æœ¯**ï¼šä¼˜å…ˆä½¿ç”¨ç°ä»£ `Cgroup v2 Freezer` å’Œ `Binder` å†»ç»“æŠ€æœ¯ï¼Œç¡®ä¿åº”ç”¨åœ¨ä¸è¢«ç³»ç»Ÿæ€æ­»çš„å‰æä¸‹è¢«å½»åº•â€œä¼‘çœ â€ï¼Œå¹¶åœ¨å¿…è¦æ—¶ä»¥ `SIGSTOP` ä½œä¸ºå¯é åå¤‡ã€‚
    *   **ANR ä¿æŠ¤**ï¼šé€šè¿‡Xposed Hookä¸»åŠ¨æ‹¦æˆªé’ˆå¯¹å·²å†»ç»“åº”ç”¨çš„ANRï¼ˆåº”ç”¨æ— å“åº”ï¼‰æ£€æµ‹ï¼Œä»æ ¹æœ¬ä¸Šé˜²æ­¢å®ƒä»¬è¢«ç³»ç»Ÿé”™è¯¯åœ°æ€æ­»ã€‚

*   **äº‹ä»¶é©±åŠ¨çš„æ™ºèƒ½å”¤é†’**ï¼š
    *   **æ¨é€å”¤é†’ (FCM/GCM)**ï¼šç²¾å‡†æ‹¦æˆªFCM/GCMå¹¿æ’­ï¼Œåœ¨åº”ç”¨è¢«å†»ç»“æ—¶ï¼Œä¸´æ—¶å°†å…¶å”¤é†’ä¸€å°æ®µæ—¶é—´ä»¥æ¥æ”¶å’Œå¤„ç†æ¨é€ï¼Œä¹‹åè‡ªåŠ¨é‡æ–°å†»ç»“ã€‚
    *   **é€šçŸ¥å”¤é†’**ï¼šå½“é«˜ä¼˜å…ˆçº§é€šçŸ¥åˆ°è¾¾æ—¶ï¼Œæ™ºèƒ½å”¤à¤œà¤¿à¤é†’å¯¹åº”åº”ç”¨ã€‚
    *   **å®šæ—¶å¿ƒè·³**ï¼šå¯é…ç½®çš„å®šæ—¶è§£å†»æœºåˆ¶ï¼Œè®©ä¾èµ–åå°å¿ƒè·³çš„åº”ç”¨ï¼ˆå¦‚å³æ—¶é€šè®¯è½¯ä»¶ï¼‰ä¹Ÿèƒ½åœ¨ä¸¥æ ¼ç®¡ç†ä¸‹æ­£å¸¸å·¥ä½œã€‚

*   **å…¨æ–¹ä½ç³»ç»Ÿç›‘æ§é¢æ¿ (Dashboard)**ï¼š
    *   **å®æ—¶æ•°æ®æµ**ï¼šé€šè¿‡TCPä¸åå°å®ˆæŠ¤è¿›ç¨‹é€šä¿¡ï¼Œå®æ—¶å±•ç¤ºç³»ç»Ÿæ€»è§ˆï¼ˆCPUã€å†…å­˜ã€Swapä½¿ç”¨ç‡ï¼‰å’Œå„åº”ç”¨è¿è¡ŒçŠ¶æ€ï¼ˆCPUã€å†…å­˜å ç”¨ã€çŠ¶æ€ï¼‰ã€‚
    *   **å¤šæ ¸CPUç›‘æ§**ï¼šåœ¨ç»Ÿè®¡å›¾è¡¨ä¸­ï¼Œæ¸…æ™°å±•ç¤ºæ¯ä¸ªCPUæ ¸å¿ƒçš„å®æ—¶ä½¿ç”¨ç‡ã€‚
    *   **ç”µæ± ä¸ç¯å¢ƒæ„ŸçŸ¥**ï¼šç›‘æ§ç”µæ± æ¸©åº¦ã€åŠŸè€—ï¼Œå¹¶æ„ŸçŸ¥å……ç”µã€äº®å±ã€éŸ³é¢‘æ’­æ”¾ã€å®šä½ç­‰çŠ¶æ€ï¼Œä¸ºæœªæ¥çš„æ™ºèƒ½ç­–ç•¥æä¾›æ•°æ®åŸºç¡€ã€‚

*   **æ·±åº¦æ—¥å¿—ä¸ç»Ÿè®¡**ï¼š
    *   **äº‹ä»¶æ—¶é—´çº¿**ï¼šè®°å½•æ‰€æœ‰æ ¸å¿ƒæ“ä½œï¼ˆåº”ç”¨å†»ç»“/è§£å†»ã€ç­–ç•¥å˜æ›´ã€å”¤é†’äº‹ä»¶ç­‰ï¼‰ï¼Œå¸®åŠ©ç”¨æˆ·è¿½æº¯ç³»ç»Ÿè¡Œä¸ºã€‚
    *   **Doze æŠ¥å‘Š**ï¼šåœ¨è®¾å¤‡é€€å‡ºæ·±åº¦ä¼‘çœ åï¼Œè‡ªåŠ¨ç”Ÿæˆä¸€ä»½æŠ¥å‘Šï¼Œå±•ç¤ºä¼‘çœ æœŸé—´å“ªäº›åº”ç”¨æ¶ˆè€—äº†CPUèµ„æºã€‚
    *   **èµ„æºå†å²å›¾è¡¨**ï¼šä»¥æ»šåŠ¨å›¾è¡¨å½¢å¼å¯è§†åŒ–å±•ç¤ºCPUã€å†…å­˜ã€ç”µæ± æ¸©åº¦çš„å†å²æ•°æ®ã€‚

## ğŸ›ï¸ æ¶æ„è§£æ

Cerberus é‡‡ç”¨åˆ›æ–°çš„ä¸‰ä½“æ¶æ„ï¼Œå„éƒ¨åˆ†èŒè´£åˆ†æ˜ã€é«˜æ•ˆåä½œï¼š

1.  **å‰ç«¯UI (Android App - `app`æ¨¡å—)**
    *   **æŠ€æœ¯æ ˆ**: 100% Kotlin, Jetpack Compose, Material 3, ViewModel, Coroutines Flow, Coilã€‚
    *   **èŒè´£**: æä¾›ç”¨æˆ·äº¤äº’ç•Œé¢ï¼Œå±•ç¤ºæ¥è‡ª`Daemon`çš„æ•°æ®ï¼Œå¹¶å°†ç”¨æˆ·é…ç½®å‘é€ç»™`Daemon`ã€‚UIå±‚ç»è¿‡ç²¾å¿ƒä¼˜åŒ–ï¼Œé€šè¿‡è‡ªå®šä¹‰Coil Fetcherå®ç°åº”ç”¨å›¾æ ‡çš„æŒ‰éœ€åŠ è½½å’Œå†…å­˜ä¼˜åŒ–ã€‚

2.  **å®ˆæŠ¤è¿›ç¨‹ (Native Daemon - `daemon`æ¨¡å—)**
    *   **æŠ€æœ¯æ ˆ**: C++17, aarch64/armv7a, TCP Server, SQLiteCpp, Nlohmann JSONã€‚
    *   **èŒè´£**: é¡¹ç›®çš„â€œå¤§è„‘â€ã€‚ä»¥Rootæƒé™åœ¨åå°è¿è¡Œï¼Œè´Ÿè´£ï¼š
        *   æ‰§è¡ŒçœŸæ­£çš„å†»ç»“/è§£å†»æ“ä½œ (`ActionExecutor`)ã€‚
        *   ç®¡ç†åº”ç”¨ç­–ç•¥å’Œé…ç½®ï¼Œå¹¶æŒä¹…åŒ–åˆ°SQLiteæ•°æ®åº“ (`DatabaseManager`)ã€‚
        *   ç›‘æ§ç³»ç»Ÿæ ¸å¿ƒæŒ‡æ ‡ (`SystemMonitor`)ã€‚
        *   ç»´æŠ¤æ‰€æœ‰åº”ç”¨çš„æ ¸å¿ƒçŠ¶æ€æœº (`StateManager`)ã€‚
        *   ä½œä¸ºæ•°æ®ä¸­å¿ƒï¼Œé€šè¿‡TCPæœåŠ¡ä¸UIå’ŒProbeé€šä¿¡ã€‚

3.  **ç³»ç»Ÿæ¢é’ˆ (Xposed Module - `lsp`æ¨¡å—)**
    *   **æŠ€æœ¯æ ˆ**: Xposed (LSPosed/EdXposed), Kotlinã€‚
    *   **èŒè´£**: é¡¹ç›®çš„â€œç¥ç»è§¦æ‰‹â€ã€‚æ³¨å…¥åˆ°`system_server`è¿›ç¨‹ä¸­ï¼Œè´Ÿè´£ï¼š
        *   Hookç³»ç»Ÿå…³é”®æœåŠ¡ï¼ˆAMS, NMS, PowerManagerç­‰ï¼‰ã€‚
        *   æ‹¦æˆªå¹¶å¤„ç†FCM/GCMå¹¿æ’­ã€é€šçŸ¥ã€ANRæµç¨‹ã€Wakelockç­‰ã€‚
        *   å°†æ•è·åˆ°çš„ç³»ç»Ÿäº‹ä»¶å®æ—¶å‘é€ç»™`Daemon`è¿›è¡Œå†³ç­–ã€‚
        *   ä»`Daemon`æ¥æ”¶å†»ç»“åˆ—è¡¨ï¼Œä¸ºANRä¿æŠ¤ç­‰åŠŸèƒ½æä¾›ä¾æ®ã€‚

![Architecture Diagram](é“¾æ¥)

### é€šä¿¡æœºåˆ¶

*   **UI <-> Daemon**: é€šè¿‡ `127.0.0.1:28900` çš„TCPå¥—æ¥å­—è¿›è¡ŒåŒå‘JSON RPCé€šä¿¡ã€‚UIå‘é€é…ç½®å‘½ä»¤å’ŒæŸ¥è¯¢è¯·æ±‚ï¼ŒDaemonå®æ—¶æ¨é€Dashboardã€æ—¥å¿—å’Œç»Ÿè®¡æ•°æ®æµã€‚
*   **Probe -> Daemon**: é€šè¿‡çŸ­è¿æ¥çš„TCPå¥—æ¥å­—ï¼Œå°†æ•è·åˆ°çš„ç³»ç»Ÿäº‹ä»¶ï¼ˆå¦‚â€œåº”ç”¨å”¤é†’è¯·æ±‚â€ï¼‰å•å‘å‘é€ç»™Daemonã€‚åŒæ—¶ï¼Œåœ¨Probeå¯åŠ¨æ—¶ä¼šä¸Daemonå»ºç«‹è¿æ¥ä»¥è·å–åˆå§‹é…ç½®ã€‚

## ğŸš€ å®‰è£…ä¸æ„å»º

### ç¯å¢ƒè¦æ±‚

*   Android 8.0+
*   å·²è§£é”å¹¶è·å–Rootæƒé™çš„è®¾å¤‡
*   å·²å®‰è£… Magisk
*   å·²å®‰è£… LSPosed (æˆ–å…¶ä»–æ”¯æŒXposed API 82çš„æ¡†æ¶)

### æ„å»ºæ­¥éª¤

1.  **å…‹éš†ä»“åº“**:
    ```bash
    git clone https://github.com/your-repo/Project-Cerberus.git
    cd Project-Cerberus
    ```

2.  **æ„å»ºå‰ç«¯ (APK)**:
    *   ä½¿ç”¨ Android Studio æ‰“å¼€é¡¹ç›®ã€‚
    *   é¡¹ç›®å°†è‡ªåŠ¨é€šè¿‡Gradle SyncåŒæ­¥ä¾èµ–ã€‚
    *   ç‚¹å‡» `Build` -> `Build Bundle(s) / APK(s)` -> `Build APK(s)`ã€‚
    *   ç”Ÿæˆçš„APKä½äº `app/build/outputs/apk/release/app-release.apk`ã€‚

3.  **æ„å»ºåç«¯ (Daemon)**:
    *   ç¡®ä¿å·²å®‰è£…Android NDKã€‚
    *   åœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼ˆè¯·æ ¹æ®æ‚¨çš„NDKè·¯å¾„å’Œç›®æ ‡æ¶æ„è¿›è¡Œè°ƒæ•´ï¼‰ï¼š
    ```bash
    cd daemon
    mkdir build && cd build
    
    # ä¸º arm64-v8a æ„å»º
    cmake .. \
      -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \
      -DANDROID_ABI=arm64-v8a \
      -DANDROID_PLATFORM=android-30 \
      -DCMAKE_BUILD_TYPE=Release
      
    make cerberusd
    ```
    *   ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸º `daemon/build/cerberusd`ã€‚

### éƒ¨ç½²ä¸ä½¿ç”¨

1.  **å®‰è£…APK**ï¼šå°†æ„å»ºå¥½çš„ `app-release.apk` å®‰è£…åˆ°æ‚¨çš„è®¾å¤‡ä¸Šã€‚
2.  **æ¿€æ´»Xposedæ¨¡å—**ï¼šåœ¨LSPosedç®¡ç†å™¨ä¸­ï¼Œæ¿€æ´» **CRFzit** æ¨¡å—ï¼Œå¹¶ç¡®ä¿ä½œç”¨åŸŸå‹¾é€‰äº† **ç³»ç»Ÿæ¡†æ¶ (`android`)**ã€‚é‡å¯è®¾å¤‡ã€‚
3.  **éƒ¨ç½²Daemon**ï¼š
    *   å°† `cerberusd` å¯æ‰§è¡Œæ–‡ä»¶æ¨é€åˆ°è®¾å¤‡çš„æŸä¸ªå¯æ‰§è¡Œè·¯å¾„ï¼Œä¾‹å¦‚ `/data/adb/cerberus/`ã€‚
    *   èµ‹äºˆå…¶å¯æ‰§è¡Œæƒé™ï¼š`chmod +x /data/adb/cerberus/cerberusd`ã€‚
4.  **è¿è¡ŒDaemon**ï¼š
    *   ä¸ºäº†è®©Daemonåœ¨åå°æŒç»­è¿è¡Œï¼Œå»ºè®®é€šè¿‡Magiskå¯åŠ¨è„šæœ¬æˆ–rcè„šæœ¬æ¥å¯åŠ¨å®ƒã€‚ä¸€ä¸ªç®€å•çš„å¯åŠ¨è„šæœ¬ `post-fs-data.sh` å¯èƒ½å¦‚ä¸‹ï¼š
    ```sh
    #!/system/bin/sh
    MODDIR=${0%/*}
    
    # ç¡®ä¿ç›®å½•å­˜åœ¨
    mkdir -p /data/adb/cerberus
    cp $MODDIR/cerberusd /data/adb/cerberus/cerberusd
    chmod 755 /data/adb/cerberus/cerberusd
    
    # å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹
    /data/adb/cerberus/cerberusd &
    ```
5.  **å¼€å§‹ä½¿ç”¨**ï¼šæ‰“å¼€CRFzitåº”ç”¨ï¼Œå¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œæ‚¨åº”è¯¥èƒ½çœ‹åˆ°â€œä¸»é¡µâ€ä¸Šå®æ—¶è·³åŠ¨çš„æ•°æ®ã€‚

## è‡´è°¢

*   **Rikka** & **LSPosed** å›¢é˜Ÿï¼Œä¸ºç°ä»£Androidæä¾›äº†å¼ºå¤§çš„Hookæ¡†æ¶ã€‚
*   **topjohnwu**ï¼ŒMagiskçš„åˆ›é€ è€…ã€‚
*   æ‰€æœ‰ä¸ºAndroidå¼€æºç¤¾åŒºåšå‡ºè´¡çŒ®çš„å¼€å‘è€…ã€‚

---
**å…è´£å£°æ˜**: æœ¬é¡¹ç›®æ¶‰åŠç³»ç»Ÿåº•å±‚ä¿®æ”¹ï¼Œè¯·ç¡®ä¿æ‚¨äº†è§£ç›¸å…³é£é™©ã€‚ä½œè€…ä¸å¯¹å› ä½¿ç”¨æœ¬é¡¹ç›®é€ æˆçš„ä»»ä½•æ•°æ®ä¸¢å¤±æˆ–è®¾å¤‡æŸåè´Ÿè´£ã€‚

build.gradle.kts

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    // æ­£ç¡®å¼•ç”¨åœ¨ toml ä¸­å®šä¹‰çš„ compose æ’ä»¶
    alias(libs.plugins.jetbrains.compose) apply false
}

daemon_context.txt

daemon/CMakeLists.txt
```
# daemon/CMakeLists.txt
#
# Project Cerberus - Daemon Build Script
# Verified against the provided third_party directory structure.
#
cmake_minimum_required(VERSION 3.20)
project(cerberusd CXX C)

# --- 1. å®šä¹‰ç¬¬ä¸‰æ–¹åº“çš„æ ¹ç›®å½• ---
set(THIRDPARTY_DIR ${CMAKE_CURRENT_SOURCE_DIR}/third_party)

# --- 2. æ„å»º sqlite3 åº“ ---
# æºæ–‡ä»¶è·¯å¾„: third_party/sqlite3/sqlite3.c
add_library(sqlite3_lib STATIC
    ${THIRDPARTY_DIR}/sqlite3/sqlite3.c
)
# å¤´æ–‡ä»¶ç›®å½•: third_party/sqlite3/ (åŒ…å« sqlite3.h)
target_include_directories(sqlite3_lib PUBLIC
    ${THIRDPARTY_DIR}/sqlite3
)

# --- 3. æ„å»º SQLiteCpp åº“ ---
# æºæ–‡ä»¶è·¯å¾„: third_party/sqlitecpp/src/*.cpp
add_library(sqlitecpp_lib STATIC
    ${THIRDPARTY_DIR}/sqlitecpp/src/Backup.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Column.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Database.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Exception.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Savepoint.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Statement.cpp
    ${THIRDPARTY_DIR}/sqlitecpp/src/Transaction.cpp
)
# å¤´æ–‡ä»¶ç›®å½•: third_party/sqlitecpp/include/
# è¿™æ ·è®¾ç½®åï¼Œä»£ç ä¸­å¯ä»¥ä½¿ç”¨ #include "SQLiteCpp/Database.h" çš„å½¢å¼
target_include_directories(sqlitecpp_lib PUBLIC
    ${THIRDPARTY_DIR}/sqlitecpp/include
)
# å£°æ˜ SQLiteCpp ä¾èµ–äºæˆ‘ä»¬åˆšåˆšå®šä¹‰çš„ sqlite3_lib
target_link_libraries(sqlitecpp_lib PUBLIC sqlite3_lib)

# --- 4. å®šä¹‰æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ 'cerberusd' ---
add_executable(cerberusd
    cpp/main.cpp
    cpp/uds_server.cpp
    cpp/system_monitor.cpp
    cpp/database_manager.cpp
    cpp/state_manager.cpp
    cpp/action_executor.cpp
   # cpp/process_monitor.cpp
    cpp/logger.cpp
    cpp/time_series_database.cpp   
)

# --- 5. ä¸º 'cerberusd' æ·»åŠ å¤´æ–‡ä»¶æœç´¢è·¯å¾„ ---
# nlohmann_json æ˜¯ header-only åº“ï¼Œåªéœ€æä¾›å…¶ include ç›®å½•
# ç›®å½•è·¯å¾„: third_party/nlohmann_json/include/
# è¿™æ ·è®¾ç½®åï¼Œä»£ç ä¸­å¯ä»¥ä½¿ç”¨ #include "nlohmann/json.hpp" çš„å½¢å¼
target_include_directories(cerberusd PRIVATE
    ${THIRDPARTY_DIR}/nlohmann_json/include
)

# --- 6. é“¾æ¥ 'cerberusd' å¯æ‰§è¡Œæ–‡ä»¶ ---
# é“¾æ¥æˆ‘ä»¬è‡ªå·±æ„å»ºçš„åº“å’Œ Android ç³»ç»Ÿæä¾›çš„æ—¥å¿—åº“
target_link_libraries(cerberusd
    PRIVATE
    sqlitecpp_lib   # é“¾æ¥ SQLiteCpp (å®ƒä¼šè‡ªåŠ¨é“¾æ¥ sqlite3)
    log             # é“¾æ¥ Android NDK çš„ log åº“ (ç”¨äº __android_log_print)
)

# --- 7. è®¾ç½® C++ æ ‡å‡†å’Œç¼–è¯‘é€‰é¡¹ ---
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
# ä¸º Release æ„å»ºå¼€å¯ä¼˜åŒ–
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2 -DNDEBUG")
# æ¶ˆé™¤ GNU æ‰©å±•ç›¸å…³çš„è­¦å‘Š (ä¾‹å¦‚åœ¨ process_monitor.cpp ä¸­å¯èƒ½å‡ºç°)
add_compile_options(-Wno-gnu-empty-struct)
```

daemon/cpp/action_executor.cpp
```
// daemon/cpp/action_executor.cpp
#include "action_executor.h"
#include <android/log.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <fstream>
#include <filesystem>
#include <unistd.h>
#include <cerrno>
#include <cstring>
#include <sstream>
#include <csignal>
#include <algorithm>
#include <fcntl.h>
#include <vector>

#define LOG_TAG "cerberusd_action_v16_resilience" // ç‰ˆæœ¬å·æ›´æ–°
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;

ActionExecutor::ActionExecutor() {
    initialize_binder();
    initialize_cgroup();
}

ActionExecutor::~ActionExecutor() {
    cleanup_binder();
}

int ActionExecutor::freeze(const AppInstanceKey& key, const std::vector<int>& pids) {
    if (pids.empty()) return 0;

    int binder_result = handle_binder_freeze(pids, true);

    if (binder_result == -1) {
        LOGE("Binder freeze for %s failed critically. Rolling back...", key.first.c_str());
        handle_binder_freeze(pids, false);
        return -1;
    }

    if (binder_result == 2) {
        LOGW("Binder freeze for %s was resisted (EAGAIN). Escalating to SIGSTOP as fallback.", key.first.c_str());
        freeze_sigstop(pids);
        return 1;
    }

    LOGI("Binder freeze phase for %s completed. Proceeding with physical freeze.", key.first.c_str());
    bool cgroup_ok = freeze_cgroup(key, pids);

    if (cgroup_ok) {
        bool verified = false;
        if (!pids.empty()) {
            usleep(50000);
            verified = is_pid_frozen_by_cgroup(pids[0], key);
        }

        if(verified) {
             LOGI("Cgroup freeze for %s succeeded and verified.", key.first.c_str());
             return 0;
        } else {
             LOGW("Cgroup freeze for %s verification failed! Escalating to SIGSTOP.", key.first.c_str());
             freeze_sigstop(pids);
             return 1;
        }
    } else {
        LOGW("Cgroup freeze failed for %s, falling back to SIGSTOP.", key.first.c_str());
        freeze_sigstop(pids);
        return 1;
    }
}


bool ActionExecutor::unfreeze(const AppInstanceKey& key, const std::vector<int>& pids) {
    unfreeze_cgroup(key);
    unfreeze_sigstop(pids);
    handle_binder_freeze(pids, false);
    LOGI("Unfroze instance '%s' (user %d).", key.first.c_str(), key.second);
    return true;
}

int ActionExecutor::handle_binder_freeze(const std::vector<int>& pids, bool freeze) {
    if (binder_state_.fd < 0) return 0;

    const int BINDER_FREEZE_MAX_ATTEMPTS = 5;
    const useconds_t BINDER_FREEZE_RETRY_WAIT_US = 70000;

    bool has_soft_failure = false;
    binder_freeze_info info{ .pid = 0, .enable = (uint32_t)(freeze ? 1 : 0), .timeout_ms = 100 };

    for (int pid : pids) {
        info.pid = static_cast<__u32>(pid);
        bool op_success = false;

        // ä½¿ç”¨ä¸Šé¢å®šä¹‰çš„å¸¸é‡æ¥æ§åˆ¶å¾ªç¯
        for (int attempt = 0; attempt < BINDER_FREEZE_MAX_ATTEMPTS; ++attempt) {
            if (ioctl(binder_state_.fd, BINDER_FREEZE, &info) == 0) {
                op_success = true;
                break;
            }

            if (errno == EAGAIN) {
                if (attempt == BINDER_FREEZE_MAX_ATTEMPTS - 1) {
                    LOGW("Binder op for pid %d still has pending transactions (EAGAIN) after %d attempts. Marking as soft failure.", pid, BINDER_FREEZE_MAX_ATTEMPTS);
                    has_soft_failure = true;
                } else {
                    LOGD("Binder op for pid %d got EAGAIN, retrying in %d ms... (Attempt %d/%d)", pid, BINDER_FREEZE_RETRY_WAIT_US / 1000, attempt + 1, BINDER_FREEZE_MAX_ATTEMPTS);
                }
                usleep(BINDER_FREEZE_RETRY_WAIT_US);
                continue;
            }
            else if (freeze && (errno == EINVAL || errno == EPERM)) {
                LOGW("Cannot freeze pid %d (error: %s), likely a privileged process. Skipping this PID.", pid, strerror(errno));
                op_success = true;
                break;
            }
            else {
                LOGE("Binder op for pid %d failed with unrecoverable error: %s", pid, strerror(errno));
                return -1;
            }
        }

        if (!op_success && !has_soft_failure) {
            return -1;
        }
    }

    return has_soft_failure ? 2 : 0;
}

bool ActionExecutor::is_pid_frozen_by_cgroup(int pid, const AppInstanceKey& key) {
    std::string freeze_path = get_instance_cgroup_path(key) + "/cgroup.freeze";

    std::ifstream freeze_file(freeze_path);
    if (freeze_file.is_open()) {
        char state;
        freeze_file >> state;
        if (state == '1') {
            return true;
        }
    }

    return false;
}

bool ActionExecutor::initialize_binder() {
    binder_state_.fd = open("/dev/binder", O_RDWR | O_CLOEXEC);
    if (binder_state_.fd < 0) {
        LOGE("Failed to open /dev/binder: %s", strerror(errno));
        return false;
    }

    binder_version version;
    if (ioctl(binder_state_.fd, BINDER_VERSION, &version) < 0 || version.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION) {
        LOGE("Binder version mismatch or ioctl failed. Required: %d", BINDER_CURRENT_PROTOCOL_VERSION);
        close(binder_state_.fd);
        binder_state_.fd = -1;
        return false;
    }

    binder_state_.mapped = mmap(NULL, binder_state_.mapSize, PROT_READ, MAP_PRIVATE, binder_state_.fd, 0);
    if (binder_state_.mapped == MAP_FAILED) {
        LOGE("Binder mmap failed: %s", strerror(errno));
        close(binder_state_.fd);
        binder_state_.fd = -1;
        return false;
    }

    struct binder_frozen_status_info info = { .pid = (uint32_t)getpid() };
    if (ioctl(binder_state_.fd, BINDER_GET_FROZEN_INFO, &info) < 0) {
        LOGW("Kernel does not support BINDER_FREEZE feature (ioctl failed: %s). Binder freezing disabled.", strerror(errno));
        cleanup_binder();
        return false;
    }

    LOGI("Binder driver initialized successfully and BINDER_FREEZE feature is supported.");
    return true;
}

void ActionExecutor::cleanup_binder() {
    if (binder_state_.mapped && binder_state_.mapped != MAP_FAILED) {
        munmap(binder_state_.mapped, binder_state_.mapSize);
        binder_state_.mapped = nullptr;
    }
    if (binder_state_.fd >= 0) {
        close(binder_state_.fd);
        binder_state_.fd = -1;
    }
}

bool ActionExecutor::initialize_cgroup() {
    if (fs::exists("/sys/fs/cgroup/cgroup.controllers")) {
        cgroup_version_ = CgroupVersion::V2;
        cgroup_root_path_ = "/sys/fs/cgroup/";
        LOGI("Detected cgroup v2. Root: %s", cgroup_root_path_.c_str());
        if(!write_to_file(cgroup_root_path_ + "cgroup.subtree_control", "+freezer")) {
             LOGW("Failed to enable freezer controller in root cgroup. It might be already enabled.");
        }
        return true;
    }
    LOGW("cgroup v2 not detected. Cgroup freezer disabled.");
    cgroup_version_ = CgroupVersion::UNKNOWN;
    return false;
}

std::string ActionExecutor::get_instance_cgroup_path(const AppInstanceKey& key) const {
    std::string sanitized_package_name = key.first;
    std::replace(sanitized_package_name.begin(), sanitized_package_name.end(), '.', '_');
    return cgroup_root_path_ + "cerberus_" + sanitized_package_name + "_" + std::to_string(key.second);
}


bool ActionExecutor::freeze_cgroup(const AppInstanceKey& key, const std::vector<int>& pids) {
    if (cgroup_version_ != CgroupVersion::V2) return false;
    std::string instance_path = get_instance_cgroup_path(key);

    if (fs::exists(instance_path)) {
        LOGW("Residual cgroup found for %s. Attempting cleanup before freeze.", key.first.c_str());
        unfreeze_cgroup(key);
    }

    if (!create_instance_cgroup(instance_path)) {
        LOGE("Failed to create cgroup '%s' even after cleanup attempt.", instance_path.c_str());
        return false;
    }

    if (!move_pids_to_cgroup(pids, instance_path)) {
        LOGE("Failed to move pids for '%s' to its cgroup.", key.first.c_str());
        return false;
    }
    if (!write_to_file(instance_path + "/cgroup.freeze", "1")) {
        LOGE("Failed to write '1' to cgroup.freeze for '%s'.", key.first.c_str());
        return false;
    }
    return true;
}

bool ActionExecutor::unfreeze_cgroup(const AppInstanceKey& key) {
    if (cgroup_version_ != CgroupVersion::V2) return true;
    std::string instance_path = get_instance_cgroup_path(key);
    if (!fs::exists(instance_path)) return true;
    
    write_to_file(instance_path + "/cgroup.freeze", "0");
    
    std::string procs_file = instance_path + "/cgroup.procs";
    std::vector<int> pids_to_move;
    std::ifstream ifs(procs_file);
    int pid;
    while(ifs >> pid) { pids_to_move.push_back(pid); }
    if (!pids_to_move.empty()) { 
        move_pids_to_default_cgroup(pids_to_move); 
    }
    
    usleep(50000); 

    remove_instance_cgroup(instance_path);
    return true;
}

void ActionExecutor::freeze_sigstop(const std::vector<int>& pids) {
    for (int pid : pids) {
        if (kill(pid, SIGSTOP) < 0) {
            LOGW("Failed to send SIGSTOP to pid %d: %s", pid, strerror(errno));
        }
    }
}

void ActionExecutor::unfreeze_sigstop(const std::vector<int>& pids) {
    for (int pid : pids) {
        if (kill(pid, SIGCONT) < 0) { }
    }
}

bool ActionExecutor::create_instance_cgroup(const std::string& path) {
    if (fs::exists(path)) return true;
    try {
        fs::create_directory(path);
        return true;
    } catch (const fs::filesystem_error& e) {
        LOGE("Failed to create cgroup '%s': %s", path.c_str(), e.what());
        return false;
    }
}

bool ActionExecutor::remove_instance_cgroup(const std::string& path) {
    if (!fs::exists(path)) return true;
    if (rmdir(path.c_str()) != 0) {
        LOGW("Cannot remove cgroup '%s': %s. It might not be empty yet.", path.c_str(), strerror(errno));
        return false;
    }
    LOGI("Successfully removed cgroup '%s'", path.c_str());
    return true;
}

bool ActionExecutor::move_pids_to_cgroup(const std::vector<int>& pids, const std::string& cgroup_path) {
    std::string procs_file = cgroup_path + "/cgroup.procs";
    std::ofstream ofs(procs_file, std::ios_base::app);
    if (!ofs.is_open()) {
        LOGE("Failed to open '%s' to move pids: %s", procs_file.c_str(), strerror(errno));
        return false;
    }
    for (int pid : pids) {
        ofs << pid << std::endl;
        if (ofs.fail()) {
            LOGE("Error writing pid %d to %s", pid, procs_file.c_str());
            return false;
        }
    }
    return true;
}

bool ActionExecutor::move_pids_to_default_cgroup(const std::vector<int>& pids) {
    return move_pids_to_cgroup(pids, cgroup_root_path_);
}

bool ActionExecutor::write_to_file(const std::string& path, const std::string& value) {
    std::ofstream ofs(path);
    if (!ofs.is_open()) {
        if (path.find("subtree_control") == std::string::npos) {
            LOGE("Failed to open file '%s' for writing: %s", path.c_str(), strerror(errno));
        }
        return false;
    }
    ofs << value;
    if (ofs.fail()) {
        LOGE("Failed to write '%s' to '%s': %s", value.c_str(), path.c_str(), strerror(errno));
        return false;
    }
    return true;
}
```

daemon/cpp/action_executor.h
```
// daemon/cpp/action_executor.h
#ifndef CERBERUS_ACTION_EXECUTOR_H
#define CERBERUS_ACTION_EXECUTOR_H

#include <string>
#include <vector>
#include <utility> 
#include <linux/android/binder.h>

using AppInstanceKey = std::pair<std::string, int>;

class ActionExecutor {
public:
    ActionExecutor();
    ~ActionExecutor();

    /**
     * @brief å°è¯•å†»ç»“ä¸€ä¸ªåº”ç”¨å®ä¾‹ï¼Œé‡‡ç”¨å¸¦ç‰©ç†éªŒè¯çš„ç­–ç•¥ã€‚
     * @return 0: Cgroupå†»ç»“æˆåŠŸ | 1: SIGSTOPåå¤‡æ–¹æ¡ˆæˆåŠŸ | 2: è½¯å¤±è´¥(å¯é‡è¯•) | -1: å½»åº•å¤±è´¥
     */
    int freeze(const AppInstanceKey& key, const std::vector<int>& pids);
    
    bool unfreeze(const AppInstanceKey& key, const std::vector<int>& pids);

private:
    bool initialize_binder();
    void cleanup_binder();
    
    /**
     * @brief å†»ç»“/è§£å†»Binder
     * @return 0: æˆåŠŸ | 2: è½¯å¤±è´¥(EAGAIN) | -1: è‡´å‘½å¤±è´¥
     */
    int handle_binder_freeze(const std::vector<int>& pids, bool freeze);
    
    /**
     * @brief [æ ¸å¿ƒ] é€šè¿‡æ£€æŸ¥æˆ‘ä»¬è‡ªå·±åˆ›å»ºçš„cgroup.freezeæ–‡ä»¶æ¥éªŒè¯è¿›ç¨‹æ˜¯å¦è¢«ç‰©ç†å†»ç»“ã€‚
     * @return true å¦‚æœè¿›ç¨‹è¢«cgroupå†»ç»“ï¼Œå¦åˆ™ falseã€‚
     */
    bool is_pid_frozen_by_cgroup(int pid, const AppInstanceKey& key);

    enum class CgroupVersion { V2, UNKNOWN };
    bool initialize_cgroup();
    std::string get_instance_cgroup_path(const AppInstanceKey& key) const;
    bool freeze_cgroup(const AppInstanceKey& key, const std::vector<int>& pids);
    bool unfreeze_cgroup(const AppInstanceKey& key);

    void freeze_sigstop(const std::vector<int>& pids);
    void unfreeze_sigstop(const std::vector<int>& pids);

    bool create_instance_cgroup(const std::string& path);
    bool remove_instance_cgroup(const std::string& path);
    bool move_pids_to_cgroup(const std::vector<int>& pids, const std::string& cgroup_path);
    bool move_pids_to_default_cgroup(const std::vector<int>& pids);
    bool write_to_file(const std::string& path, const std::string& value);

    CgroupVersion cgroup_version_ = CgroupVersion::UNKNOWN;
    std::string cgroup_root_path_;
    
    struct BinderState {
        int fd = -1;
        void* mapped = nullptr;
        size_t mapSize = 128 * 1024ULL;
    } binder_state_;
};

#endif //CERBERUS_ACTION_EXECUTOR_H
```

daemon/cpp/database_manager.cpp
```
// daemon/cpp/database_manager.cpp
#include "database_manager.h"
#include <android/log.h>
#include <filesystem>

#define LOG_TAG "cerberusd_db_v9"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

DatabaseManager::DatabaseManager(const std::string& db_path)
    : db_(db_path, SQLite::OPEN_READWRITE | SQLite::OPEN_CREATE) {
    LOGI("Database opened at %s", db_path.c_str());
    initialize_database();
}

void DatabaseManager::initialize_database() {
    try {
        if (!db_.tableExists("app_policies_v3")) {
            LOGI("Table 'app_policies_v3' does not exist. Creating it.");
            db_.exec(R"(
                CREATE TABLE app_policies_v3 (
                    package_name TEXT NOT NULL,
                    user_id INTEGER NOT NULL,
                    policy INTEGER NOT NULL DEFAULT 0,
                    PRIMARY KEY (package_name, user_id)
                )
            )");
        }

        // [æ ¸å¿ƒä¿®æ”¹] æ›´æ–° master_config è¡¨ç»“æ„å’Œé»˜è®¤å€¼
        if (!db_.tableExists("master_config_v2")) {
            LOGI("Table 'master_config_v2' does not exist. Creating it.");
            if (db_.tableExists("master_config_v1")) {
                 LOGI("Old 'master_config_v1' table found. Dropping it.");
                 db_.exec("DROP TABLE master_config_v1;");
            }
            db_.exec(R"(
                CREATE TABLE master_config_v2 (
                    key TEXT PRIMARY KEY,
                    value INTEGER NOT NULL
                )
            )");
            db_.exec("INSERT OR IGNORE INTO master_config_v2 (key, value) VALUES ('standard_timeout_sec', 90)");
            db_.exec("INSERT OR IGNORE INTO master_config_v2 (key, value) VALUES ('is_timed_unfreeze_enabled', 1)");
            db_.exec("INSERT OR IGNORE INTO master_config_v2 (key, value) VALUES ('timed_unfreeze_interval_sec', 1800)");
        }
    } catch (const std::exception& e) {
        LOGE("Database initialization failed: %s", e.what());
    }
}

std::optional<MasterConfig> DatabaseManager::get_master_config() {
    try {
        MasterConfig config;
        SQLite::Statement query(db_, "SELECT key, value FROM master_config_v2");
        while (query.executeStep()) {
            std::string key = query.getColumn(0).getString();
            int value = query.getColumn(1).getInt();
            if (key == "standard_timeout_sec") {
                config.standard_timeout_sec = value;
            } else if (key == "is_timed_unfreeze_enabled") {
                config.is_timed_unfreeze_enabled = (value != 0);
            } else if (key == "timed_unfreeze_interval_sec") {
                config.timed_unfreeze_interval_sec = value;
            }
        }
        return config;
    } catch (const std::exception& e) {
        LOGE("Failed to get master config: %s", e.what());
    }
    return std::nullopt;
}

bool DatabaseManager::set_master_config(const MasterConfig& config) {
    try {
        SQLite::Transaction transaction(db_);
        
        db_.exec("INSERT OR REPLACE INTO master_config_v2 (key, value) VALUES ('standard_timeout_sec', " + std::to_string(config.standard_timeout_sec) + ")");
        db_.exec("INSERT OR REPLACE INTO master_config_v2 (key, value) VALUES ('is_timed_unfreeze_enabled', " + std::to_string(config.is_timed_unfreeze_enabled ? 1 : 0) + ")");
        db_.exec("INSERT OR REPLACE INTO master_config_v2 (key, value) VALUES ('timed_unfreeze_interval_sec', " + std::to_string(config.timed_unfreeze_interval_sec) + ")");

        transaction.commit();
        return true;
    } catch (const std::exception& e) {
        LOGE("Failed to set master config: %s", e.what());
        return false;
    }
}

std::optional<AppConfig> DatabaseManager::get_app_config(const std::string& package_name, int user_id) {
    try {
        SQLite::Statement query(db_, "SELECT policy FROM app_policies_v3 WHERE package_name = ? AND user_id = ?");
        query.bind(1, package_name);
        query.bind(2, user_id);

        if (query.executeStep()) {
            AppConfig config;
            config.package_name = package_name;
            config.user_id = user_id;
            config.policy = static_cast<AppPolicy>(query.getColumn(0).getInt());
            return config;
        }
    } catch (const std::exception& e) {
        LOGE("Failed to get app config for '%s' (user %d): %s", package_name.c_str(), user_id, e.what());
    }
    return std::nullopt;
}

bool DatabaseManager::set_app_config(const AppConfig& config) {
    try {
        SQLite::Statement query(db_, R"(
            INSERT INTO app_policies_v3 (package_name, user_id, policy)
            VALUES (?, ?, ?)
            ON CONFLICT(package_name, user_id) DO UPDATE SET
                policy = excluded.policy
        )");
        query.bind(1, config.package_name);
        query.bind(2, config.user_id);
        query.bind(3, static_cast<int>(config.policy));
        
        return query.exec() > 0;
    } catch (const std::exception& e) {
        LOGE("Failed to set app config for '%s' (user %d): %s", config.package_name.c_str(), config.user_id, e.what());
        return false;
    }
}

bool DatabaseManager::clear_all_policies() {
    try {
        db_.exec("DELETE FROM app_policies_v3");
        return true;
    } catch (const std::exception& e) {
        LOGE("Failed to clear all policies: %s", e.what());
        return false;
    }
}

std::vector<AppConfig> DatabaseManager::get_all_app_configs() {
    std::vector<AppConfig> configs;
    try {
        SQLite::Statement query(db_, "SELECT package_name, user_id, policy FROM app_policies_v3");
        while (query.executeStep()) {
            AppConfig config;
            config.package_name = query.getColumn(0).getString();
            config.user_id = query.getColumn(1).getInt();
            config.policy = static_cast<AppPolicy>(query.getColumn(2).getInt());
            configs.push_back(config);
        }
    } catch (const std::exception& e) {
        LOGE("Failed to get all app configs: %s", e.what());
    }
    return configs;
}
```

daemon/cpp/database_manager.h
```
// daemon/cpp/database_manager.h
#ifndef CERBERUS_DATABASE_MANAGER_H
#define CERBERUS_DATABASE_MANAGER_H

#include <string>
#include <vector>
#include <optional>
#include <SQLiteCpp/Database.h>
#include <SQLiteCpp/Statement.h>
#include <SQLiteCpp/Transaction.h>

enum class AppPolicy {
    EXEMPTED = 0,
    IMPORTANT = 1,
    STANDARD = 2,
    STRICT = 3
};

struct AppConfig {
    std::string package_name;
    int user_id = 0; 
    AppPolicy policy = AppPolicy::STANDARD;
};

// [æ ¸å¿ƒæ–°å¢] ä¸º MasterConfig å¢åŠ å®šæ—¶è§£å†»ç›¸å…³å­—æ®µ
struct MasterConfig {
    int standard_timeout_sec = 90;
    bool is_timed_unfreeze_enabled = true;
    int timed_unfreeze_interval_sec = 1800; // 30åˆ†é’Ÿ
};

class DatabaseManager {
public:
    explicit DatabaseManager(const std::string& db_path);

    std::optional<MasterConfig> get_master_config();
    bool set_master_config(const MasterConfig& config);
    
    std::optional<AppConfig> get_app_config(const std::string& package_name, int user_id);
    bool set_app_config(const AppConfig& config);
    bool clear_all_policies();
    std::vector<AppConfig> get_all_app_configs();

private:
    void initialize_database();
    SQLite::Database db_;
};

#endif //CERBERUS_DATABASE_MANAGER_H
```

daemon/cpp/logger.cpp
```
// daemon/cpp/logger.cpp
#include "logger.h"
#include <fstream>
#include <filesystem>
#include <chrono>
#include <iomanip>
#include <ctime>
#include <algorithm>
#include <android/log.h>
#include <vector>
#include <regex>

#define LOG_TAG "cerberusd_logger_v7_polling" // ç‰ˆæœ¬å·æ›´æ–°
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;

const int MAX_LOG_LINES_PER_FILE = 200;
const int MAX_LOG_FILES_PER_DAY = 3;
const int MAX_LOG_RETENTION_DAYS = 3;

// --- LogEntry ---
json LogEntry::to_json() const {
    json j = {
        {"timestamp", timestamp_ms},
        {"level", static_cast<int>(level)},
        {"category", category},
        {"message", message},
    };
    if (!package_name.empty()) j["package_name"] = package_name;
    if (user_id != -1) j["user_id"] = user_id;
    return j;
}

std::shared_ptr<Logger> Logger::instance_ = nullptr;
std::mutex Logger::instance_mutex_;

std::shared_ptr<Logger> Logger::get_instance(const std::string& log_dir_path) {
    std::lock_guard<std::mutex> lock(instance_mutex_);
    if (!instance_) {
        struct make_shared_enabler : public Logger {
            make_shared_enabler(const std::string& path) : Logger(path) {}
        };
        instance_ = std::make_shared<make_shared_enabler>(log_dir_path);
    }
    return instance_;
}
Logger::Logger(const std::string& log_dir_path)
    : log_dir_path_(log_dir_path), is_running_(true) {
    if (!fs::exists(log_dir_path_)) {
        fs::create_directories(log_dir_path_);
    }
    manage_log_files(); // åˆå§‹åŒ–æ—¶å°±ç®¡ç†ä¸€ä¸‹
    writer_thread_ = std::thread(&Logger::writer_thread_func, this);
}
Logger::~Logger() {
    stop();
}
void Logger::stop() {
    if (!is_running_.exchange(false)) return;
    cv_.notify_one();
    if (writer_thread_.joinable()) {
        writer_thread_.join();
    }
}
void Logger::log(LogLevel level, const std::string& category, const std::string& message, const std::string& package_name, int user_id) {
    long long timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()
    ).count();
    LogEntry entry{timestamp, level, category, message, package_name, user_id};

    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        log_queue_.push_back(entry);
    }
    cv_.notify_one();
}
void Logger::log_batch(const std::vector<LogEntry>& entries) {
    if (entries.empty()) return;
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        for(const auto& entry : entries) {
            log_queue_.push_back(entry);
        }
    }
    cv_.notify_one();
}
std::vector<std::string> Logger::get_log_files() const {
    std::vector<std::string> files;
    try {
        for (const auto& entry : fs::directory_iterator(log_dir_path_)) {
            if (entry.is_regular_file()) {
                std::string filename = entry.path().filename().string();
                if (filename.rfind("fct_", 0) == 0 && filename.rfind(".log") == filename.length() - 4) {
                    files.push_back(filename);
                }
            }
        }
    } catch (const fs::filesystem_error& e) {
        LOGE("Error listing log files: %s", e.what());
    }
    std::sort(files.rbegin(), files.rend());
    return files;
}

// [ä¿®æ”¹] å®ç° since å’Œ before çš„é€»è¾‘
std::vector<LogEntry> Logger::get_logs_from_file(const std::string& filename, int limit,
                                                 std::optional<long long> before_timestamp_ms,
                                                 std::optional<long long> since_timestamp_ms) const {
    std::vector<LogEntry> results;
    fs::path file_path = fs::path(log_dir_path_) / filename;

    if (!fs::exists(file_path)) return results;

    std::ifstream log_file(file_path);
    if (!log_file.is_open()) return results;

    // ä¸ºäº† polling (since)ï¼Œæˆ‘ä»¬éœ€è¦æ­£å‘è¯»å–
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(log_file, line)) {
        lines.push_back(line);
    }

    // ä»åå¾€å‰éå†ï¼Œè¿™æ ·å¯ä»¥å¾ˆå®¹æ˜“åœ°åº”ç”¨ limit å’Œ before
    for (auto it = lines.rbegin(); it != lines.rend(); ++it) {
        if (limit > 0 && results.size() >= limit && !since_timestamp_ms) break;

        try {
            json j = json::parse(*it);
            long long timestamp = j.value("ts", 0LL);

            if (before_timestamp_ms.has_value() && timestamp >= before_timestamp_ms.value()) {
                continue;
            }
            
            if (since_timestamp_ms.has_value() && timestamp <= since_timestamp_ms.value()) {
                // å¦‚æœæ˜¯ polling è¯·æ±‚ï¼Œè¯»åˆ°æ¯” since æ—§çš„å°±åœæ­¢
                if (!before_timestamp_ms.has_value()) break; 
                else continue;
            }
            
            LogEntry entry{
                .timestamp_ms = timestamp,
                .level = static_cast<LogLevel>(j.value("lvl", 0)),
                .category = j.value("cat", ""),
                .message = j.value("msg", ""),
                .package_name = j.value("pkg", ""),
                .user_id = j.value("uid", -1)
            };
            results.push_back(entry);
        } catch (...) { /* ignore */ }
    }

    // å¦‚æœæ˜¯ pollingï¼Œç»“æœéœ€è¦æ˜¯æ—¶é—´å‡åºçš„
    if (since_timestamp_ms.has_value()) {
        std::reverse(results.begin(), results.end());
    }
    
    // Polling ä¹Ÿå¯èƒ½ä»å†…å­˜é˜Ÿåˆ—è·å–
    if (since_timestamp_ms) {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        for(const auto& entry : log_queue_) {
            if (entry.timestamp_ms > since_timestamp_ms.value()) {
                results.push_back(entry);
            }
        }
        // å†æ¬¡æ’åºç¡®ä¿å†…å­˜å’Œæ–‡ä»¶çš„æ—¥å¿—é¡ºåºæ­£ç¡®
        std::sort(results.begin(), results.end(), [](const auto& a, const auto& b) {
            return a.timestamp_ms < b.timestamp_ms;
        });
    }

    return results;
}

void Logger::manage_log_files() {
    auto files = get_log_files(); // å·²ç»æ˜¯é™åºæ’åº
    std::map<std::string, std::vector<std::string>> files_by_day;
    
    // åˆ†ç»„
    for (const auto& f : files) {
        try {
            std::string date_str = f.substr(4, 10);
            files_by_day[date_str].push_back(f);
        } catch(...) {}
    }
    
    // æ¸…ç†æ¯å¤©å¤šä½™çš„æ–‡ä»¶
    for (auto& [day, day_files] : files_by_day) {
        // å·²ç»æ˜¯é™åºçš„äº†ï¼Œæ‰€ä»¥ 0, 1, 2 æ˜¯æœ€æ–°çš„
        if (day_files.size() > MAX_LOG_FILES_PER_DAY) {
            for (size_t i = MAX_LOG_FILES_PER_DAY; i < day_files.size(); ++i) {
                fs::remove(fs::path(log_dir_path_) / day_files[i]);
                 LOGD("Cleaned up excess log file: %s", day_files[i].c_str());
            }
        }
    }
    
    // æ¸…ç†è¿‡æœŸçš„å¤©æ•°
    if (files_by_day.size() > MAX_LOG_RETENTION_DAYS) {
        auto it = files_by_day.begin();
        std::advance(it, files_by_day.size() - MAX_LOG_RETENTION_DAYS);
        for(auto temp_it = files_by_day.begin(); temp_it != it; ++temp_it) {
            for (const auto& f : temp_it->second) {
                fs::remove(fs::path(log_dir_path_) / f);
                 LOGD("Cleaned up outdated log file: %s", f.c_str());
            }
        }
    }

    // æ›´æ–°å½“å‰æ—¥å¿—æ–‡ä»¶
    auto latest_files = get_log_files();
    if (latest_files.empty()) {
        current_log_file_path_ = "";
        current_log_line_count_ = 0;
    } else {
        current_log_file_path_ = fs::path(log_dir_path_) / latest_files[0];
        std::ifstream ifs(current_log_file_path_);
        current_log_line_count_ = std::count(std::istreambuf_iterator<char>(ifs), std::istreambuf_iterator<char>(), '\n');
    }
}
void Logger::rotate_log_file_if_needed(size_t new_entries_count) {
    time_t now = time(nullptr);
    tm ltm = {};
    localtime_r(&now, &ltm);
    char date_buf[16];
    strftime(date_buf, sizeof(date_buf), "%Y-%m-%d", &ltm);
    std::string current_date_str(date_buf);

    bool needs_new_file = false;
    if (current_log_file_path_.empty() || 
        current_log_file_path_.find(current_date_str) == std::string::npos ||
        (current_log_line_count_ + new_entries_count > MAX_LOG_LINES_PER_FILE)) {
        needs_new_file = true;
    }

    if (needs_new_file) {
        int next_index = 1;
        auto files = get_log_files();
        if (!files.empty() && files[0].find(current_date_str) != std::string::npos) {
            try {
                // fct_2024-01-01_1.log -> 1
                std::string last_file = files[0];
                size_t underscore_pos = last_file.rfind('_');
                size_t dot_pos = last_file.rfind('.');
                int last_index = std::stoi(last_file.substr(underscore_pos + 1, dot_pos - underscore_pos - 1));
                next_index = last_index + 1;
            } catch (...) {}
        }
        std::string new_filename = "fct_" + current_date_str + "_" + std::to_string(next_index) + ".log";
        current_log_file_path_ = fs::path(log_dir_path_) / new_filename;
        current_log_line_count_ = 0;
        cleanup_old_files();
    }
}
void Logger::cleanup_old_files() {}
void Logger::writer_thread_func() {
    while (is_running_) {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        cv_.wait(lock, [this]{ return !log_queue_.empty() || !is_running_; });

        if (!is_running_ && log_queue_.empty()) break;

        std::deque<LogEntry> temp_queue;
        temp_queue.swap(log_queue_);
        lock.unlock();

        if (temp_queue.empty()) continue;
        
        rotate_log_file_if_needed(temp_queue.size());

        std::ofstream log_file(current_log_file_path_, std::ios_base::app);
        if (!log_file.is_open()) {
            LOGE("Failed to open log file for writing: %s", current_log_file_path_.c_str());
            continue;
        }

        for (const auto& entry : temp_queue) {
            json file_json = {
                {"ts", entry.timestamp_ms},
                {"lvl", static_cast<int>(entry.level)},
                {"cat", entry.category},
                {"msg", entry.message}
            };
            if (!entry.package_name.empty()) file_json["pkg"] = entry.package_name;
            if (entry.user_id != -1) file_json["uid"] = entry.user_id;
            log_file << file_json.dump() << std::endl;
        }
        current_log_line_count_ += temp_queue.size();
    }
}
```

daemon/cpp/logger.h
```
// daemon/cpp/logger.h
#ifndef CERBERUS_LOGGER_H
#define CERBERUS_LOGGER_H

#include <string>
#include <vector>
#include <mutex>
#include <deque>
#include <thread>
#include <atomic>
#include <condition_variable>
#include <nlohmann/json.hpp>
#include <memory>
#include <optional>

using json = nlohmann::json;

enum class LogLevel {
    INFO,
    SUCCESS,
    WARN,
    ERROR,
    EVENT,
    DOZE,
    BATTERY,
    REPORT,
    ACTION_OPEN,
    ACTION_CLOSE,
    ACTION_FREEZE,
    ACTION_UNFREEZE,
    ACTION_DELAY,
    TIMER,
    BATCH_PARENT
};

struct LogEntry {
    long long timestamp_ms;
    LogLevel level;
    std::string category;
    std::string message;
    std::string package_name;
    int user_id;

    json to_json() const;
};

class Logger : public std::enable_shared_from_this<Logger> {
public:
    static std::shared_ptr<Logger> get_instance(const std::string& log_dir_path);
    ~Logger();

    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;

    void log(LogLevel level, const std::string& category, const std::string& message,
             const std::string& package_name = "", int user_id = -1);
    
    void log_batch(const std::vector<LogEntry>& entries);

    // [ä¿®æ”¹] get_logs_from_file ç°åœ¨æ”¯æŒ since å’Œ before
    std::vector<LogEntry> get_logs_from_file(const std::string& filename, int limit,
                                             std::optional<long long> before_timestamp_ms,
                                             std::optional<long long> since_timestamp_ms) const;
    
    std::vector<std::string> get_log_files() const;
    void stop();

private:
    explicit Logger(const std::string& log_dir_path);
    void writer_thread_func();
    void manage_log_files();
    void rotate_log_file_if_needed(size_t new_entries_count);
    void cleanup_old_files();
    
    static std::shared_ptr<Logger> instance_;
    static std::mutex instance_mutex_;

    std::string log_dir_path_;
    std::string current_log_file_path_;
    int current_log_line_count_ = 0;

    std::deque<LogEntry> log_queue_;
    mutable std::mutex queue_mutex_;
    std::condition_variable cv_;
    std::thread writer_thread_;
    std::atomic<bool> is_running_;
};

#endif // CERBERUS_LOGGER_H
```

daemon/cpp/main.cpp
```
// daemon/cpp/main.cpp
#include "uds_server.h"
#include "state_manager.h"
#include "system_monitor.h"
#include "database_manager.h"
#include "action_executor.h"
#include "main.h"
#include <nlohmann/json.hpp>
#include <android/log.h>
#include "logger.h"
#include "time_series_database.h"
#include <csignal>
#include <thread>
#include <chrono>
#include <memory>
#include <atomic>
#include <filesystem>
#include <mutex>
#include <unistd.h>

#define LOG_TAG "cerberusd_main_v34_wakeup" // ç‰ˆæœ¬å·æ›´æ–°
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

using json = nlohmann::json;
namespace fs = std::filesystem;

std::unique_ptr<UdsServer> g_server;
static std::shared_ptr<StateManager> g_state_manager;
static std::shared_ptr<SystemMonitor> g_sys_monitor;
static std::shared_ptr<Logger> g_logger;
static std::shared_ptr<TimeSeriesDatabase> g_ts_db;
static std::atomic<bool> g_is_running = true;
std::atomic<int> g_probe_fd = -1;
static std::thread g_worker_thread;
std::atomic<int> g_top_app_refresh_tickets = 0;


void handle_client_message(int client_fd, const std::string& message_str) {
    try {
        json msg = json::parse(message_str);
        std::string type = msg.value("type", "");

        if (type == "hello.ui") {
            g_server->identify_client_as_ui(client_fd);
            if (g_state_manager) {
                json payload = g_state_manager->get_dashboard_payload();
                g_server->send_message(client_fd, json{{"type", "stream.dashboard_update"}, {"payload", payload}}.dump());
            }
            return;
        }

        if (type == "query.get_logs") {
            const auto& payload_json = msg.value("payload", json::object());
            std::string filename = payload_json.value("filename", "");
            long long before_ts = payload_json.value("before", 0LL);
            long long since_ts = payload_json.value("since", 0LL);
            int limit = payload_json.value("limit", 50);

            std::vector<LogEntry> logs;
            if (!filename.empty()) {
                logs = g_logger->get_logs_from_file(filename, limit, 
                    before_ts > 0 ? std::optional(before_ts) : std::nullopt,
                    since_ts > 0 ? std::optional(since_ts) : std::nullopt);
            }

            json log_array = json::array();
            for(const auto& log : logs) { log_array.push_back(log.to_json()); }

            g_server->send_message(client_fd, json{
                {"type", "resp.get_logs"},
                {"req_id", msg.value("req_id", "")},
                {"payload", log_array}
            }.dump());
            return;
        }
        
        if (type == "query.get_log_files") {
            auto files = g_logger->get_log_files();
            g_server->send_message(client_fd, json{
                {"type", "resp.get_log_files"},
                {"req_id", msg.value("req_id", "")},
                {"payload", files}
            }.dump());
            return;
        }

        if (type == "query.get_history_stats") {
            auto records = g_ts_db->get_all_records();
            json record_array = json::array();
            for(const auto& record : records) { record_array.push_back(record.to_json()); }
            g_server->send_message(client_fd, json{ {"type", "resp.history_stats"}, {"req_id", msg.value("req_id", "")}, {"payload", record_array} }.dump());
            return;
        }

        if (!g_state_manager) return;

        // [æ ¸å¿ƒæ–°å¢] æ·»åŠ å¯¹æ–°å”¤é†’äº‹ä»¶çš„å¤„ç†è·¯ç”±
        if (type == "event.app_wakeup_request_v2") {
            g_state_manager->on_wakeup_request_from_probe(msg.at("payload"));
        } else if (type == "cmd.proactive_unfreeze") {
            g_state_manager->on_proactive_unfreeze_request(msg.at("payload"));
        } else if (type == "event.app_foreground") {
            g_state_manager->on_app_foreground_event(msg.at("payload"));
        } else if (type == "event.app_background") {
            g_state_manager->on_app_background_event(msg.at("payload"));
        }
        else if (type == "cmd.request_temp_unfreeze_pkg") {
            g_state_manager->on_temp_unfreeze_request_by_pkg(msg.at("payload"));
        } else if (type == "cmd.request_temp_unfreeze_uid") {
            g_state_manager->on_temp_unfreeze_request_by_uid(msg.at("payload"));
        } else if (type == "cmd.request_temp_unfreeze_pid") {
            g_state_manager->on_temp_unfreeze_request_by_pid(msg.at("payload"));
        }
        else if (type == "event.app_wakeup_request") {
            // Note: This is the old event type. The new probe sends v2.
            // We can keep this for backward compatibility or remove it.
            g_state_manager->on_wakeup_request(msg.at("payload"));
        } else if (type == "cmd.set_policy") {
            if (g_state_manager->on_config_changed_from_ui(msg.at("payload"))) {
                notify_probe_of_config_change();
            }
            g_top_app_refresh_tickets = 1;
        }
        else if (type == "cmd.set_master_config") {
            MasterConfig cfg;
            const auto& payload = msg.at("payload");
            cfg.standard_timeout_sec = payload.value("standard_timeout_sec", 90);
            cfg.is_timed_unfreeze_enabled = payload.value("is_timed_unfreeze_enabled", true);
            cfg.timed_unfreeze_interval_sec = payload.value("timed_unfreeze_interval_sec", 1800);
            g_state_manager->update_master_config(cfg);
        }
        else if (type == "query.refresh_dashboard") {
            broadcast_dashboard_update();
        } else if (type == "query.get_all_policies") {
            json payload = g_state_manager->get_full_config_for_ui();
            g_server->send_message(client_fd, json{{"type", "resp.all_policies"}, {"req_id", msg.value("req_id", "")}, {"payload", payload}}.dump());
        } else if (type == "event.probe_hello") {
            g_probe_fd = client_fd;
            notify_probe_of_config_change();
        }
    } catch (const json::exception& e) { LOGE("JSON Error: %s in msg: %s", e.what(), message_str.c_str()); }
}

void handle_client_disconnect(int client_fd) {
    LOGI("Client fd %d has disconnected.", client_fd);
    if (client_fd == g_probe_fd.load()) {
        g_probe_fd = -1;
    }
}

void broadcast_dashboard_update() {
    if (g_server && g_server->has_clients() && g_state_manager) {
        LOGD("Broadcasting dashboard update...");
        json payload = g_state_manager->get_dashboard_payload();
        g_server->broadcast_message_except(json{{"type", "stream.dashboard_update"}, {"payload", payload}}.dump(), g_probe_fd.load());
    }
}

void notify_probe_of_config_change() {
    int probe_fd = g_probe_fd.load();
    if (g_server && probe_fd != -1 && g_state_manager) {
        json payload = g_state_manager->get_probe_config_payload();
        g_server->send_message(probe_fd, json{{"type", "stream.probe_config_update"}, {"payload", payload}}.dump());
    }
}

void signal_handler(int signum) {
    LOGW("Signal %d received, shutting down...", signum);
    g_is_running = false;
    if (g_server) g_server->stop();
    if (g_logger) g_logger->stop();
}

void worker_thread_func() {
    LOGI("Worker thread started.");
    g_top_app_refresh_tickets = 2;

    int reconcile_countdown = 15;
    int audio_scan_countdown = 3;
    int location_scan_countdown = 15;
    int audit_countdown = 30;
    int heartbeat_countdown = 7;

    const int SAMPLING_INTERVAL_SEC = 2;

    while (g_is_running) {
        auto loop_start_time = std::chrono::steady_clock::now();
        bool state_changed = false;

        auto metrics_opt = g_sys_monitor->collect_current_metrics();
        if (metrics_opt) {
            g_ts_db->add_record(*metrics_opt);
            g_state_manager->process_new_metrics(*metrics_opt);
        }

        if (g_top_app_refresh_tickets > 0) {
            g_top_app_refresh_tickets--;
            if (g_state_manager->handle_top_app_change_fast()) state_changed = true;
            audit_countdown = 30;
        }

        if (--audit_countdown <= 0) {
            if (g_state_manager->evaluate_and_execute_strategy()) state_changed = true;
            audit_countdown = 30;
        }

        if (g_state_manager->tick_state_machine()) {
            state_changed = true;
        }

        if (g_server && g_server->has_clients()) {
            if (g_state_manager->perform_staggered_stats_scan()) {
                state_changed = true;
            }
        }

        if (--reconcile_countdown <= 0) {
            if (g_state_manager->perform_deep_scan()) state_changed = true;
            reconcile_countdown = 15;
        }
        if (--audio_scan_countdown <= 0) {
            g_sys_monitor->update_audio_state();
            audio_scan_countdown = 3;
        }
        if (--location_scan_countdown <= 0) {
            g_sys_monitor->update_location_state();
            location_scan_countdown = 15;
        }

        if (--heartbeat_countdown <= 0) {
            if (g_server) {
                g_server->broadcast_message_to_ui("{\"type\":\"ping\"}");
            }
            heartbeat_countdown = 7;
        }

        if (state_changed) {
            broadcast_dashboard_update();
        }

        auto loop_end_time = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::seconds>(loop_end_time - loop_start_time);
        if (duration.count() < SAMPLING_INTERVAL_SEC) {
            std::this_thread::sleep_for(std::chrono::seconds(SAMPLING_INTERVAL_SEC - duration.count()));
        }
    }
    LOGI("Worker thread finished.");
}


int main(int argc, char *argv[]) {
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
    signal(SIGPIPE, SIG_IGN);

    const std::string DATA_DIR = "/data/adb/cerberus";
    const std::string DB_PATH = DATA_DIR + "/cerberus.db";
    const std::string LOG_DIR = DATA_DIR + "/logs";
    LOGI("Project Cerberus Daemon starting... (PID: %d)", getpid());

    try {
        if (!fs::exists(DATA_DIR)) fs::create_directories(DATA_DIR);
        if (!fs::exists(LOG_DIR)) fs::create_directories(LOG_DIR);
    } catch(const fs::filesystem_error& e) {
        LOGE("Failed to create data dir: %s", e.what());
        return 1;
    }

    auto db_manager = std::make_shared<DatabaseManager>(DB_PATH);
    auto action_executor = std::make_shared<ActionExecutor>();
    g_sys_monitor = std::make_shared<SystemMonitor>();
    g_logger = Logger::get_instance(LOG_DIR);
    g_ts_db = TimeSeriesDatabase::get_instance();
    g_state_manager = std::make_shared<StateManager>(db_manager, g_sys_monitor, action_executor, g_logger, g_ts_db);

    g_state_manager->initial_full_scan_and_warmup();

    g_logger->log(LogLevel::EVENT, "Daemon", "å®ˆæŠ¤è¿›ç¨‹å·²å¯åŠ¨");

    g_sys_monitor->start_top_app_monitor();
    g_sys_monitor->start_network_snapshot_thread();
    g_worker_thread = std::thread(worker_thread_func);

    const int DAEMON_PORT = 28900;
    g_server = std::make_unique<UdsServer>(DAEMON_PORT);
    g_server->set_message_handler(handle_client_message);
    g_server->set_disconnect_handler(handle_client_disconnect);
    g_server->run();

    g_is_running = false;
    if(g_worker_thread.joinable()) g_worker_thread.join();

    g_sys_monitor->stop_top_app_monitor();
    g_sys_monitor->stop_network_snapshot_thread();

    LOGI("Cerberus Daemon has shut down cleanly.");
    return 0;
}
```

daemon/cpp/main.h
```
// daemon/cpp/main.h
#ifndef CERBERUS_MAIN_H
#define CERBERUS_MAIN_H

#include <atomic>
#include <nlohmann/json.hpp>
#include <functional>
#include <variant>
#include <string>
#include <set>

// è¿™ä¸ª Task ç»“æ„çœ‹èµ·æ¥æ˜¯ä¸ºæ›´é«˜çº§çš„äº‹ä»¶é©±åŠ¨æ¨¡å‹å‡†å¤‡çš„ï¼Œæš‚æ—¶ä¿ç•™
struct ConfigChangeTask { nlohmann::json payload; };
struct TopAppChangeTask { std::set<int> pids; };
struct TickTask {};
struct RefreshDashboardTask {};
struct ProbeHelloTask { int fd; };
struct ClientDisconnectTask { int fd; };
struct ProbeFgEventTask { nlohmann::json payload; };
struct ProbeBgEventTask { nlohmann::json payload; };

using Task = std::variant<
    ConfigChangeTask,
    TopAppChangeTask,
    TickTask,
    RefreshDashboardTask,
    ProbeHelloTask,
    ClientDisconnectTask,
    ProbeFgEventTask,
    ProbeBgEventTask
>;

// --- å…¨å±€å‡½æ•°å£°æ˜ ---
void broadcast_dashboard_update();
void notify_probe_of_config_change();

// å¦‚æœæ‚¨æš‚æ—¶ä¸ä½¿ç”¨ schedule_taskï¼Œå¯ä»¥æ³¨é‡Šæ‰å®ƒä»¥é¿å…æ½œåœ¨çš„æœªå®šä¹‰å¼•ç”¨é”™è¯¯
// void schedule_task(Task task); 

// [ä¿®å¤] å£°æ˜å…¨å±€ probe fd
extern std::atomic<int> g_probe_fd;

#endif //CERBERUS_MAIN_H
```

daemon/cpp/state_manager.cpp
```
// daemon/cpp/state_manager.cpp
#include "state_manager.h"
#include "main.h"
#include <android/log.h>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <unistd.h>
#include <algorithm>
#include <sys/stat.h>
#include <unordered_map>
#include <ctime>
#include <iomanip>

#define LOG_TAG "cerberusd_state_v40_report_top7" // ç‰ˆæœ¬å·æ›´æ–°
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;
using json = nlohmann::json;

static std::string status_to_string(const AppRuntimeState& app, const MasterConfig& master_config) {
    if (app.current_status == AppRuntimeState::Status::STOPPED) return "æœªè¿è¡Œ";
    if (app.current_status == AppRuntimeState::Status::FROZEN) {
        switch (app.freeze_method) {
            case AppRuntimeState::FreezeMethod::CGROUP: return "å·²å†»ç»“ (V2)";
            case AppRuntimeState::FreezeMethod::SIG_STOP: return "å·²å†»ç»“ (SIG)";
            default: return "å·²å†»ç»“";
        }
    }
    if (app.is_foreground) return "å‰å°è¿è¡Œ";
    if (app.config.policy == AppPolicy::EXEMPTED || app.config.policy == AppPolicy::IMPORTANT) return "åå°è¿è¡Œ (å·²è±å…)";
    if (app.background_since > 0) {
        time_t now = time(nullptr);
        int timeout_sec = 0;
        if (app.config.policy == AppPolicy::STRICT) {
            timeout_sec = 15;
        } else if (app.config.policy == AppPolicy::STANDARD) {
            timeout_sec = master_config.standard_timeout_sec;
        }
        if (app.freeze_retry_count > 0) {
            timeout_sec += (5 * app.freeze_retry_count);
        }
        int remaining = timeout_sec - (now - app.background_since);
        if (remaining < 0) remaining = 0;
        return "ç­‰å¾…å†»ç»“ (" + std::to_string(remaining) + "s)";
    }
    if (app.observation_since > 0) {
        time_t now = time(nullptr);
        int remaining = 10 - (now - app.observation_since);
        if (remaining < 0) remaining = 0;
        return "åå°è§‚å¯Ÿä¸­ (" + std::to_string(remaining) + "s)";
    }
    return "åå°è¿è¡Œ";
}


DozeManager::DozeManager(std::shared_ptr<Logger> logger, std::shared_ptr<ActionExecutor> executor)
    : logger_(logger), action_executor_(executor) {
    state_change_timestamp_ = std::chrono::steady_clock::now();
}

void DozeManager::enter_state(State new_state, const MetricsRecord& record) {
    if (new_state == current_state_) return;

    current_state_ = new_state;
    state_change_timestamp_ = std::chrono::steady_clock::now();

    switch(new_state) {
        case State::AWAKE:
            break;
        case State::IDLE:
             logger_->log(LogLevel::DOZE, "Doze", "è¿›å…¥IDLE (æ¯å±, æœªå……ç”µ)");
            break;
        case State::INACTIVE:
            logger_->log(LogLevel::DOZE, "Doze", "è¿›å…¥INACTIVE (æ£€æŸ¥æœŸ)");
            break;
        case State::DEEP_DOZE:
            deep_doze_start_time_ = std::chrono::steady_clock::now();
            logger_->log(LogLevel::DOZE, "Doze", "ğŸ˜´ è¿›å…¥æ·±åº¦Doze");
            break;
    }
}

DozeManager::DozeEvent DozeManager::process_metrics(const MetricsRecord& record) {
    auto now = std::chrono::steady_clock::now();
    auto duration_in_state = std::chrono::duration_cast<std::chrono::seconds>(now - state_change_timestamp_).count();
    State old_state = current_state_;

    if (record.is_screen_on || record.is_charging) {
        enter_state(State::AWAKE, record);
    } else {
        if (current_state_ == State::AWAKE) {
            enter_state(State::IDLE, record);
        } else if (current_state_ == State::IDLE && duration_in_state > 30) {
            if (record.is_audio_playing || record.is_location_active) {
                state_change_timestamp_ = now;
            } else {
                enter_state(State::INACTIVE, record);
            }
        } else if (current_state_ == State::INACTIVE && duration_in_state > 60) {
             if (record.is_audio_playing || record.is_location_active) {
                enter_state(State::IDLE, record);
            } else {
                enter_state(State::DEEP_DOZE, record);
            }
        }
    }

    if (old_state == State::DEEP_DOZE && current_state_ != State::DEEP_DOZE) {
        auto doze_duration = std::chrono::duration_cast<std::chrono::seconds>(now - deep_doze_start_time_);
        long minutes = doze_duration.count() / 60;
        long seconds = doze_duration.count() % 60;
        std::stringstream ss;
        ss << "ğŸ¤ª é€€å‡ºæ·±åº¦Dozeï¼ŒæŒç»­æ—¶é•¿ " << minutes << "åˆ†" << seconds << "ç§’";
        logger_->log(LogLevel::DOZE, "Doze", ss.str());
        return DozeEvent::EXITED_DEEP_DOZE;
    }

    if (old_state != State::DEEP_DOZE && current_state_ == State::DEEP_DOZE) {
        return DozeEvent::ENTERED_DEEP_DOZE;
    }

    return DozeEvent::NONE;
}

StateManager::StateManager(std::shared_ptr<DatabaseManager> db, std::shared_ptr<SystemMonitor> sys, std::shared_ptr<ActionExecutor> act,
                           std::shared_ptr<Logger> logger, std::shared_ptr<TimeSeriesDatabase> ts_db)
    : db_manager_(db), sys_monitor_(sys), action_executor_(act), logger_(logger), ts_db_(ts_db) {
    LOGI("StateManager Initializing...");

    unfrozen_timeline_.resize(3600 * 2, 0);
    master_config_ = db_manager_->get_master_config().value_or(MasterConfig{});
    doze_manager_ = std::make_unique<DozeManager>(logger_, action_executor_);

    LOGI("Loaded master config: standard_timeout=%ds, timed_unfreeze_enabled=%d, timed_unfreeze_interval=%ds",
        master_config_.standard_timeout_sec, master_config_.is_timed_unfreeze_enabled, master_config_.timed_unfreeze_interval_sec);

    critical_system_apps_ = {
        "com.google.android.inputmethod.latin",
        "com.baidu.input",
        "com.sohu.inputmethod.sogou",
        "com.iflytek.inputmethod",
        "com.tencent.qqpinyin",
        "com.xiaomi.mibrain.speech",
        "com.xiaomi.scanner",
        "zygote",
        "zygote64",
        "com.xiaomi.xmsf",
        "com.xiaomi.xmsfkeeper",
        "com.xiaomi.misettings",
        "com.xiaomi.barrage",
        "com xiaomi.aireco",
        "com.xiaomi.account",
        "com.miui.notes",
        "com.miui.calculator",
        "com.miui.compass",
        "com.miui.mediaeditor",
        "com.miui.personalassistant",
        "com.miui.vipservice",
        "com.miui.systemAdSolution",
        "com.miui.home",
        "com.miui.carlink",
        "com.miui.packageinstaller",
        "com.miui.accessibility",
        "com.miui.core",
        "com.miui.privacycomputing",
        "com.miui.securityadd",
        "com.miui.securityinputmethod",
        "com.miui.system",
        "com.miui.vpnsdkmanager",
        "com.mfashiongallery.emag",
        "com.huawei.hwid",
        "cn.litiaotiao.app",
        "com.litiaotiao.app",
        "hello.litiaotiao.app",
        "com.zfdang.touchhelper",
        "com.giftedcat.adskiphelper",
        "com.merxury.blocker",
        "com.wpengapp.lightstart",
        "li.songe.gkd",
        "com.sevtinge.hyperceiler",
        "com.topjohnwu.magisk",
        "org.lsposed.manager",
        "name.monwf.customiuizer",
        "name.mikanoshi.customiuizer",
        "com.android.vending",
        "org.meowcat.xposed.mipush",
        "top.trumeet.mipush",
        "one.yufz.hmspush",
        "app.lawnchair",
        "com.microsoft.launcher",
        "com.teslacoilsw.launcher",
        "com.hola.launcher",
        "com.transsion.XOSLauncher",
        "com.mi.android.globallauncher",
        "com.gau.go.launcherex",
        "bitpit.launcher",
        "com.oppo.launcher",
        "me.weishu.kernelsu",
        "top.canyie.dreamland.manager",
        "com.coloros.packageinstaller",
        "com.oplus.packageinstaller",
        "com.iqoo.packageinstaller",
        "com.vivo.packageinstaller",
        "com.google.android.packageinstaller",
        "com.baidu.input_huawei",
        "com.baidu.input_oppo",
        "com.baidu.input_vivo",
        "com.baidu.input_yijia",
        "com.sohu.inputmethod.sogou.xiaomi",
        "com.sohu.inputmethod.sogou.meizu",
        "com.sohu.inputmethod.sogou.nubia",
        "com.sohu.inputmethod.sogou.chuizi",
        "com.sohu.inputmethod.sogou.moto",
        "com.sohu.inputmethod.sogou.zte",
        "com.sohu.inputmethod.sogou.samsung",
        "com.sohu.input_yijia",
        "com.iflytek.inputmethod.miui",
        "com.iflytek.inputmethod.googleplay",
        "com.iflytek.inputmethod.smartisan",
        "com.iflytek.inputmethod.oppo",
        "com.iflytek.inputmethod.oem",
        "com.iflytek.inputmethod.custom",
        "com.iflytek.inputmethod.blackshark",
        "com.iflytek.inputmethod.zte",
        "com.touchtype.swiftkey",
        "com.touchtype.swiftkey.beta",
        "im.weshine.keyboard",
        "com.komoxo.octopusime",
        "com.qujianpan.duoduo",
        "com.lxlm.lhl.softkeyboard",
        "com.jinkey.unfoldedime",
        "com.iflytek.inputmethods.DungkarIME",
        "com.oyun.qingcheng",
        "com.ziipin.softkeyboard",
        "com.kongzue.secretinput",
        "com.google.android.ext.services",
        "com.google.android.ext.shared",
        "com.google.android.gms",
        "com.google.android.gsf",
        "com.google.android.systemui.gxoverlay",
        "com.google.android.tag",
        "com.google.android.documentsui",
        "com.google.android.captiveportallogin",
        "com.google.android.printservice.recommendation",
        "com.google.android.gms.supervision",
        "com.google.android.as.oss",
        "com.google.android.configupdater",
        "com.google.android.apps.restore",
        "com.google.android.onetimeinitializer",
        "com.google.android.odad",
        "com.google.android.settings.intelligence",
        "com.google.android.partnersetup",
        "com.google.android.projection.gearhead",
        "com.google.android.apps.wellbeing",
        "com.google.android.as",
        "com.google.android.apps.messaging",
        "com.google.android.googlequicksearchbox",
        "com.google.android.webview",
        "com.google.android.tts",
        "com.google.android.deskclock",
        "com.google.android.markup",
        "com.google.android.calendar",
        "com.google.android.soundpicker",
        "com.google.android.apps.wallpaper.nexus",
        "com.google.android.modulemetadata",
        "com.google.android.contacts",
        "com.google.android.apps.customization.pixel",
        "com.google.android.apps.photos",
        "com.google.android.feedback",
        "com.google.android.apps.wallpaper",
        "com.google.android.providers.media.module",
        "com.google.android.wifi.resources",
        "com.google.android.hotspot2.osulogin",
        "com.google.android.safetycenter.resources",
        "com.google.android.permissioncontroller",
        "com.google.android.ondevicepersonalization.services",
        "com.google.android.adservices.api",
        "com.google.android.devicelockcontroller",
        "com.google.android.connectivity.resources",
        "com.google.android.healthconnect.controller",
        "com.google.android.cellbroadcastreceiver",
        "com.google.android.uwb.resources",
        "com.google.android.rkpdapp",
        "com.android.launcher",
        "com.android.launcher2",
        "com.android.launcher4",
        "com.android.camera",
        "com.android.camera2",
        "com.android.apps.tag",
        "com.android.bips",
        "com.android.bluetoothmidiservice",
        "com.android.cameraextensions",
        "com.android.carrierdefaultapp",
        "com.android.certinstaller",
        "com.android.companiondevicemanager",
        "com.android.dreams.basic",
        "com.android.egg",
        "com.android.emergency",
        "com.android.externalstorage",
        "com.android.htmlviewer",
        "com.android.internal.display.cutout.emulation.corner",
        "com.android.internal.display.cutout.emulation.double",
        "com.android.internal.display.cutout.emulation.hole",
        "com.android.internal.display.cutout.emulation.tall",
        "com.android.internal.display.cutout.emulation.waterfall",
        "com.android.internal.systemui.navbar.gestural",
        "com.android.internal.systemui.navbar.gestural_extra_wide_back",
        "com.android.internal.systemui.navbar.gestural_narrow_back",
        "com.android.internal.systemui.navbar.gestural_wide_back",
        "com.android.internal.systemui.navbar.threebutton",
        "com.android.managedprovisioning",
        "com.android.mms",
        "com.android.mtp",
        "com.android.musicfx",
        "com.android.networkstack.inprocess.overlay",
        "com.android.networkstack.overlay",
        "com.android.networkstack.tethering.inprocess.overlay",
        "com.android.networkstack.tethering.overlay",
        "com.android.packageinstaller",
        "com.android.pacprocessor",
        "com.android.printspooler",
        "com.android.providers.calendar",
        "com.android.providers.contacts",
        "com.android.providers.downloads.ui",
        "com.android.proxyhandler",
        "com.android.server.telecom.overlay.miui",
        "com.android.simappdialog",
        "com.android.soundrecorder",
        "com.android.statementservice",
        "com.android.storagemanager",
        "com.android.theme.font.notoserifsource",
        "com.android.traceur",
        "com.android.vpndialogs",
        "com.android.wallpaper.livepicker",
        "com.debug.loggerui",
        "com.fingerprints.sensortesttool",
        "com.lbe.security.miui",
        "com.mediatek.callrecorder",
        "com.mediatek.duraspeed",
        "com.mediatek.engineermode",
        "com.mediatek.lbs.em2.ui",
        "com.mediatek.location.mtkgeofence",
        "com.mediatek.mdmconfig",
        "com.mediatek.mdmlsample",
        "com.mediatek.miravision.ui",
        "com.mediatek.op01.telecom",
        "com.mediatek.op09clib.phone.plugin",
        "com.mediatek.op09clib.telecom",
        "com.mediatek.ygps",
        "com.tencent.soter.soterserver",
        "com.unionpay.tsmservice.mi",
        "android.ext.services",
        "android.ext.shared",
        "com.android.bookmarkprovider",
        "com.android.cellbroadcastreceiver.module",
        "com.android.dreams.phototable",
        "com.android.intentresolver",
        "com.android.internal.display.cutout.emulation.noCutout",
        "com.android.internal.systemui.navbar.twobutton",
        "com.android.messaging",
        "com.android.wallpaper",
        "com.qualcomm.qti.cne",
        "com.qualcomm.qti.poweroffalarm",
        "com.qualcomm.wfd.service",
        "org.lineageos.aperture",
        "org.lineageos.audiofx",
        "org.lineageos.backgrounds",
        "org.lineageos.customization",
        "org.lineageos.eleven",
        "org.lineageos.etar",
        "org.lineageos.jelly",
        "org.lineageos.overlay.customization.blacktheme",
        "org.lineageos.overlay.font.lato",
        "org.lineageos.overlay.font.rubik",
        "org.lineageos.profiles",
        "org.lineageos.recorder",
        "org.lineageos.updater",
        "org.protonaosp.deviceconfig",
        "android.aosp.overlay",
        "android.miui.home.launcher.res",
        "android.miui.overlay",
        "com.android.carrierconfig",
        "com.android.carrierconfig.overlay.miui",
        "com.android.incallui.overlay",
        "com.android.managedprovisioning.overlay",
        "com.android.overlay.cngmstelecomm",
        "com.android.overlay.gmscontactprovider",
        "com.android.overlay.gmssettingprovider",
        "com.android.overlay.gmssettings",
        "com.android.overlay.gmstelecomm",
        "com.android.overlay.gmstelephony",
        "com.android.overlay.systemui",
        "com.android.phone.overlay.miui",
        "com.android.providers.settings.overlay",
        "com.android.sdksandbox",
        "com.android.settings.overlay.miui",
        "com.android.stk.overlay.miui",
        "com.android.systemui.gesture.line.overlay",
        "com.android.systemui.navigation.bar.overlay",
        "com.android.systemui.overlay.miui",
        "com.android.wallpapercropper",
        "com.android.wallpaperpicker",
        "com.android.wifi.dialog",
        "com.android.wifi.resources.overlay",
        "com.android.wifi.resources.xiaomi",
        "com.android.wifi.system.mainline.resources.overlay",
        "com.android.wifi.system.resources.overlay",
        "com.google.android.cellbroadcastreceiver.overlay.miui",
        "com.google.android.cellbroadcastservice.overlay.miui",
        "com.google.android.overlay.gmsconfig",
        "com.google.android.overlay.modules.ext.services",
        "com.google.android.trichromelibrary_511209734",
        "com.google.android.trichromelibrary_541411734",
        "com.mediatek.FrameworkResOverlayExt",
        "com.mediatek.SettingsProviderResOverlay",
        "com.mediatek.batterywarning",
        "com.mediatek.cellbroadcastuiresoverlay",
        "com.mediatek.frameworkresoverlay",
        "com.mediatek.gbaservice",
        "com.mediatek.voiceunlock",
        "com.miui.core.internal.services",
        "com.miui.face.overlay.miui",
        "com.miui.miwallpaper.overlay.customize",
        "com.miui.miwallpaper.wallpaperoverlay.config.overlay",
        "com.miui.rom",
        "com.miui.settings.rro.device.config.overlay",
        "com.miui.settings.rro.device.hide.statusbar.overlay",
        "com.miui.settings.rro.device.type.overlay",
        "com.miui.system.overlay",
        "com.miui.systemui.carriers.overlay",
        "com.miui.systemui.devices.overlay",
        "com.miui.systemui.overlay.devices.android",
        "com.miui.translation.kingsoft",
        "com.miui.translation.xmcloud",
        "com.miui.translationservice",
        "com.miui.voiceassistoverlay",
        "com.xiaomi.bluetooth.rro.device.config.overlay",
        "android.auto_generated_rro_product__",
        "android.auto_generated_rro_vendor__",
        "com.android.backupconfirm",
        "com.android.carrierconfig.auto_generated_rro_vendor__",
        "com.android.cts.ctsshim",
        "com.android.cts.priv.ctsshim",
        "com.android.documentsui.auto_generated_rro_product__",
        "com.android.emergency.auto_generated_rro_product__",
        "com.android.imsserviceentitlement",
        "com.android.imsserviceentitlement.auto_generated_rro_product__",
        "com.android.inputmethod.latin.auto_generated_rro_product__",
        "com.android.launcher3.overlay",
        "com.android.managedprovisioning.auto_generated_rro_product__",
        "com.android.nearby.halfsheet",
        "com.android.phone.auto_generated_rro_vendor__",
        "com.android.providers.settings.auto_generated_rro_product__",
        "com.android.providers.settings.auto_generated_rro_vendor__",
        "com.android.settings.auto_generated_rro_product__",
        "com.android.sharedstoragebackup",
        "com.android.smspush",
        "com.android.storagemanager.auto_generated_rro_product__",
        "com.android.systemui.auto_generated_rro_product__",
        "com.android.systemui.auto_generated_rro_vendor__",
        "com.android.systemui.plugin.globalactions.wallet",
        "com.android.wallpaper.auto_generated_rro_product__",
        "com.android.wifi.resources.oneplus_sdm845",
        "com.qualcomm.timeservice",
        "lineageos.platform.auto_generated_rro_product__",
        "lineageos.platform.auto_generated_rro_vendor__",
        "org.codeaurora.ims",
        "org.lineageos.aperture.auto_generated_rro_vendor__",
        "org.lineageos.lineageparts.auto_generated_rro_product__",
        "org.lineageos.lineagesettings.auto_generated_rro_product__",
        "org.lineageos.lineagesettings.auto_generated_rro_vendor__",
        "org.lineageos.overlay.customization.navbar.nohint",
        "org.lineageos.settings.device.auto_generated_rro_product__",
        "org.lineageos.settings.doze.auto_generated_rro_product__",
        "org.lineageos.settings.doze.auto_generated_rro_vendor__",
        "org.lineageos.setupwizard.auto_generated_rro_product__",
        "org.lineageos.updater.auto_generated_rro_product__",
        "org.protonaosp.deviceconfig.auto_generated_rro_product__"
      };

    load_all_configs();
    next_scan_iterator_ = managed_apps_.begin();
    last_battery_level_info_ = std::nullopt;
    LOGI("StateManager Initialized. Ready for warmup.");
}

void StateManager::initial_full_scan_and_warmup() {
    LOGI("Starting initial full scan and data warmup...");
    std::lock_guard<std::mutex> lock(state_mutex_);

    reconcile_process_state_full();

    int warmed_up_count = 0;
    for (auto& [key, app] : managed_apps_) {
        if (!app.pids.empty()) {
            sys_monitor_->update_app_stats(app.pids, app.mem_usage_kb, app.swap_usage_kb, app.cpu_usage_percent);
            warmed_up_count++;
        }
    }

    LOGI("Warmup complete. Populated initial stats for %d running app instances.", warmed_up_count);
    logger_->log(LogLevel::EVENT, "Daemon", "å¯åŠ¨é¢„çƒ­å®Œæˆï¼Œå·²å¡«å……åˆå§‹æ•°æ®");
}

bool StateManager::perform_staggered_stats_scan() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    if (managed_apps_.empty()) {
        return false;
    }

    const int APPS_PER_TICK = 2;

    for (int i = 0; i < APPS_PER_TICK; ++i) {
        if (next_scan_iterator_ == managed_apps_.end()) {
            next_scan_iterator_ = managed_apps_.begin();
        }
        if (next_scan_iterator_ == managed_apps_.end()) {
            break;
        }

        auto& app = next_scan_iterator_->second;
        if (!app.pids.empty()) {
            sys_monitor_->update_app_stats(app.pids, app.mem_usage_kb, app.swap_usage_kb, app.cpu_usage_percent);
        }

        ++next_scan_iterator_;
    }

    return true;
}

bool StateManager::evaluate_and_execute_strategy() {
    bool state_has_changed = false;
    
    auto visible_app_keys = sys_monitor_->get_visible_app_keys();
    
    state_has_changed |= update_foreground_state(visible_app_keys);

    if (state_has_changed) {
        auto process_tree = sys_monitor_->get_full_process_tree();
        audit_app_structures(process_tree);
    }

    return state_has_changed;
}

bool StateManager::handle_top_app_change_fast() {
    auto top_pids = sys_monitor_->read_top_app_pids();
    return update_foreground_state_from_pids(top_pids);
}

void StateManager::process_new_metrics(const MetricsRecord& record) {
    std::lock_guard<std::mutex> lock(state_mutex_);

    auto doze_event = doze_manager_->process_metrics(record);

    if (doze_event == DozeManager::DozeEvent::ENTERED_DEEP_DOZE) {
        doze_start_process_info_.clear();
        for (const auto& [key, app] : managed_apps_) {
            for (int pid : app.pids) {
                doze_start_process_info_[pid] = {
                    .start_jiffies = sys_monitor_->get_total_cpu_jiffies_for_pids({pid}),
                    .process_name = sys_monitor_->get_app_name_from_pid(pid),
                    .package_name = app.package_name,
                    .user_id = app.user_id
                };
            }
        }
    } else if (doze_event == DozeManager::DozeEvent::EXITED_DEEP_DOZE) {
        generate_doze_exit_report();
        doze_start_process_info_.clear();
    }

    if (last_metrics_record_) {
        handle_charging_state_change(*last_metrics_record_, record);
        analyze_battery_change(*last_metrics_record_, record);
    }

    last_metrics_record_ = record;
}

void StateManager::generate_doze_exit_report() {
    struct ProcessActivity {
        std::string process_name;
        double cpu_seconds;
    };

    struct AppActivitySummary {
        std::string app_name;
        std::string package_name;
        int user_id;
        double total_cpu_seconds = 0.0;
        std::vector<ProcessActivity> processes;
    };

    std::map<AppInstanceKey, AppActivitySummary> grouped_activities;
    const long TCK = sysconf(_SC_CLK_TCK);
    if (TCK <= 0) return;

    for (const auto& [pid, start_record] : doze_start_process_info_) {
        std::string base_package_name = start_record.package_name;
        size_t colon_pos = base_package_name.find(':');
        if (colon_pos != std::string::npos) {
            base_package_name = base_package_name.substr(0, colon_pos);
        }

        long long end_jiffies = sys_monitor_->get_total_cpu_jiffies_for_pids({pid});
        if (end_jiffies > start_record.start_jiffies) {
            double cpu_seconds = static_cast<double>(end_jiffies - start_record.start_jiffies) / TCK;
            if (cpu_seconds > 0.01) {
                AppInstanceKey key = {base_package_name, start_record.user_id};
                if (grouped_activities.find(key) == grouped_activities.end()) {
                    auto it = managed_apps_.find(key);
                    grouped_activities[key].app_name = (it != managed_apps_.end() && !it->second.app_name.empty()) ? it->second.app_name : key.first;
                    grouped_activities[key].package_name = key.first;
                    grouped_activities[key].user_id = key.second;
                }
                grouped_activities[key].processes.push_back({start_record.process_name, cpu_seconds});
                grouped_activities[key].total_cpu_seconds += cpu_seconds;
            }
        }
    }

    if (grouped_activities.empty()) {
        logger_->log(LogLevel::BATCH_PARENT, "æŠ¥å‘Š", "DozeæœŸé—´æ— æ˜æ˜¾åº”ç”¨æ´»åŠ¨ã€‚");
        return;
    }
    
    std::vector<LogEntry> batch_log_entries;
    long long now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();

    batch_log_entries.push_back({now_ms, LogLevel::BATCH_PARENT, "æŠ¥å‘Š", "DozeæœŸé—´åº”ç”¨çš„CPUæ´»è·ƒæ—¶é—´ï¼š", "", -1});

    std::vector<AppActivitySummary> sorted_apps;
    for (auto const& [key, val] : grouped_activities) {
        sorted_apps.push_back(val);
    }
    std::sort(sorted_apps.begin(), sorted_apps.end(),
              [](const auto& a, const auto& b) { return a.total_cpu_seconds > b.total_cpu_seconds; });

    // [æ ¸å¿ƒä¿®æ”¹] åªå–å‰7ä¸ª
    const int REPORT_LIMIT = 7;
    int count = 0;
    for (const auto& summary : sorted_apps) {
        if (++count > REPORT_LIMIT) break;

        std::stringstream report_ss;
        report_ss << summary.app_name << " æ€»è®¡: "
                  << std::fixed << std::setprecision(3) << summary.total_cpu_seconds << "s";
        
        if (!summary.processes.empty()) {
            report_ss << "\nåŒ…æ‹¬:";
        }
        
        for (const auto& proc : summary.processes) {
            report_ss << "\n- " << proc.process_name << ": " << std::fixed << std::setprecision(3) << proc.cpu_seconds << "s";
        }
        batch_log_entries.push_back({now_ms, LogLevel::REPORT, "æŠ¥å‘Š", report_ss.str(), summary.package_name, summary.user_id});
    }

    logger_->log_batch(batch_log_entries);
}


void StateManager::handle_charging_state_change(const MetricsRecord& old_record, const MetricsRecord& new_record) {
    if (old_record.is_charging != new_record.is_charging) {
        if (new_record.is_charging) {
            logger_->log(LogLevel::BATTERY, "å……ç”µ", "âš¡ï¸ å¼€å§‹å……ç”µ (å½“å‰ç”µé‡: " + std::to_string(new_record.battery_level) + "%)");
        } else {
            logger_->log(LogLevel::BATTERY, "å……ç”µ", "ğŸ”Œ åœæ­¢å……ç”µ (å½“å‰ç”µé‡: " + std::to_string(new_record.battery_level) + "%)");
        }
    }
}

void StateManager::analyze_battery_change(const MetricsRecord& old_record, const MetricsRecord& new_record) {
    if (new_record.is_charging || new_record.battery_level < 0) {
        last_battery_level_info_ = std::nullopt;
        return;
    }

    if (!last_battery_level_info_) {
        last_battery_level_info_ = {new_record.battery_level, new_record.timestamp_ms};
        return;
    }

    if (new_record.battery_level < last_battery_level_info_->first) {
        long long time_delta_ms = new_record.timestamp_ms - last_battery_level_info_->second;
        int level_delta = last_battery_level_info_->first - new_record.battery_level;

        if (time_delta_ms <= 0 || level_delta <= 0) return;

        long long time_per_percent_ms = time_delta_ms / level_delta;

        std::stringstream ss;
        ss << "[å½“å‰: " << new_record.battery_level << "%] [æ¶ˆè€—: " << level_delta << "%/"
           << (time_delta_ms / 1000 / 60) << "m " << (time_delta_ms / 1000) % 60 << "s] "
           << "[åŠŸç‡: " << std::fixed << std::setprecision(2) << new_record.battery_power_watt << "W] "
           << "[æ¸©åº¦: " << std::fixed << std::setprecision(1) << new_record.battery_temp_celsius << "Â°C]";

        LogLevel level = (time_per_percent_ms < 300000) ? LogLevel::WARN : LogLevel::BATTERY;
        std::string category = (time_per_percent_ms < 300000) ? "ç”µé‡è­¦å‘Š" : "ç”µé‡";
        if (level == LogLevel::WARN) ss << " (è€—ç”µè¾ƒå¿«)";
        else ss << " (çŠ¶æ€æ›´æ–°)";

        logger_->log(level, category, ss.str());

        last_battery_level_info_ = {new_record.battery_level, new_record.timestamp_ms};
    }
}

bool StateManager::unfreeze_and_observe_nolock(AppRuntimeState& app, const std::string& reason, WakeupType wakeup_type) {
    cancel_timed_unfreeze(app);

    if (app.current_status == AppRuntimeState::Status::FROZEN) {
        std::string msg = "å›  " + reason + " è€Œè§£å†»";
        logger_->log(LogLevel::ACTION_UNFREEZE, "è§£å†»", msg, app.package_name, app.user_id);

        action_executor_->unfreeze({app.package_name, app.user_id}, app.pids);
        app.current_status = AppRuntimeState::Status::RUNNING;
        app.freeze_method = AppRuntimeState::FreezeMethod::NONE;
        
        // [æ ¸å¿ƒæ–°å¢] æ ¹æ®å”¤é†’ç±»å‹è®¾ç½®ä¸åŒçš„è§‚å¯ŸæœŸï¼ˆå³é‡å†»å»¶è¿Ÿï¼‰
        // è§‚å¯ŸæœŸæ€»æ—¶é•¿ä¸º10ç§’ã€‚
        time_t now = time(nullptr);
        switch(wakeup_type) {
            case WakeupType::GENERIC_NOTIFICATION:
                // å¯¹äºæ™®é€šé€šçŸ¥ï¼Œè®¤ä¸ºåº”ç”¨å¤„ç†æ—¶é—´çŸ­ï¼Œè®¾ç½®ä¸€ä¸ªçŸ­çš„è§‚å¯ŸæœŸã€‚
                // now - 7 æ„å‘³ç€10ç§’çš„è§‚å¯ŸæœŸå·²ç»è¿‡å»äº†7ç§’ï¼Œè¿˜å‰©3ç§’ã€‚
                app.observation_since = now - 7;
                LOGI("Smart Unfreeze: %s gets 3s observation for generic notification.", app.package_name.c_str());
                break;
            case WakeupType::FCM_PUSH:
                // å¯¹äºFCMï¼Œåº”ç”¨å¯èƒ½éœ€è¦è”ç½‘ç­‰æ“ä½œï¼Œç»™äºˆæ›´é•¿çš„è§‚å¯ŸæœŸã€‚
                // now + 5 æ„å‘³ç€10ç§’çš„è§‚å¯ŸæœŸä»5ç§’åæ‰å¼€å§‹è®¡ç®—ï¼Œæ€»è®¡15ç§’ã€‚
                app.observation_since = now + 5;
                LOGI("Smart Unfreeze: %s gets 15s observation for FCM push.", app.package_name.c_str());
                break;
            default:
                // é»˜è®¤10ç§’è§‚å¯ŸæœŸ
                app.observation_since = now;
                LOGI("Smart Unfreeze: %s gets default 10s observation.", app.package_name.c_str());
                break;
        }
        
        app.background_since = 0;
        app.freeze_retry_count = 0;

        return true;
    } else {
        LOGD("UNFREEZE [%s]: Request for %s ignored. Reason: App not frozen (current state: %d).",
            reason.c_str(), app.package_name.c_str(), static_cast<int>(app.current_status));
        return false;
    }
}

void StateManager::on_wakeup_request_from_probe(const json& payload) {
    bool state_changed = false;
    try {
        int uid = payload.value("uid", -1);
        int type_int = payload.value("type_int", static_cast<int>(WakeupType::OTHER));
        auto wakeup_type = static_cast<WakeupType>(type_int);
        
        if (uid < 0) return;

        std::string reason = (wakeup_type == WakeupType::FCM_PUSH) ? "FCM" : "Notification";
        LOGD("Received wakeup request for UID: %d, Reason: %s", uid, reason.c_str());

        std::lock_guard<std::mutex> lock(state_mutex_);
        bool app_found = false;
        for (auto& [key, app] : managed_apps_) {
            if (app.uid == uid) {
                app_found = true;
                if (unfreeze_and_observe_nolock(app, reason, wakeup_type)) {
                    state_changed = true;
                }
                break; // å‡è®¾ä¸€ä¸ªUIDåªå¯¹åº”ä¸€ä¸ªåº”ç”¨å®ä¾‹
            }
        }
        if (!app_found) {
            LOGW("Wakeup request for unknown UID: %d", uid);
        }
    } catch (const json::exception& e) {
        LOGE("Error processing wakeup request from probe: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}


void StateManager::audit_app_structures(const std::map<int, ProcessInfo>& process_tree) {
    std::lock_guard<std::mutex> lock(state_mutex_);
    for(auto& [key, app] : managed_apps_) {
        app.has_rogue_structure = false;
        app.rogue_puppet_pid = -1;
        app.rogue_master_pid = -1;

        if (app.is_foreground || app.pids.size() < 2) continue;

        for (int pid : app.pids) {
            auto it_pid = process_tree.find(pid);
            if (it_pid == process_tree.end()) continue;

            const auto& child_info = it_pid->second;
            if (child_info.oom_score_adj <= 0) {
                auto it_ppid = process_tree.find(child_info.ppid);
                if (it_ppid != process_tree.end() && it_ppid->second.pkg_name == app.package_name) {
                    const auto& parent_info = it_ppid->second;
                    if (parent_info.oom_score_adj > 200) {
                        if (!app.has_logged_rogue_warning) {
                            LOGW("AUDIT: Rogue structure detected in %s! Puppet: pid=%d (adj=%d), Master: pid=%d (adj=%d)",
                                app.package_name.c_str(), child_info.pid, child_info.oom_score_adj,
                                parent_info.pid, parent_info.oom_score_adj);
                            logger_->log(LogLevel::WARN, "å®¡è®¡", "æ£€æµ‹åˆ°æµæ°“è¿›ç¨‹ç»“æ„", app.package_name, app.user_id);
                            app.has_logged_rogue_warning = true;
                        }
                        app.has_rogue_structure = true;
                        app.rogue_puppet_pid = child_info.pid;
                        app.rogue_master_pid = parent_info.pid;
                        break;
                    }
                }
            }
        }
    }
}

bool StateManager::update_foreground_state(const std::set<AppInstanceKey>& visible_app_keys) {
    bool state_has_changed = false;
    bool probe_config_needs_update = false;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        if (visible_app_keys == last_known_visible_app_keys_) {
            return false;
        }

        last_known_visible_app_keys_ = visible_app_keys;

        std::string current_ime_pkg = sys_monitor_->get_current_ime_package();
        if (!current_ime_pkg.empty()) {
            last_known_visible_app_keys_.insert({current_ime_pkg, 0});
        }

        std::set<AppInstanceKey> prev_foreground_keys;
        for (const auto& [key, app] : managed_apps_) {
            if (app.is_foreground) prev_foreground_keys.insert(key);
        }

        const auto& final_foreground_keys = last_known_visible_app_keys_;

        time_t now = time(nullptr);
        for (auto& [key, app] : managed_apps_) {
            bool is_now_foreground = final_foreground_keys.count(key);
            if (app.is_foreground != is_now_foreground) {
                state_has_changed = true;
                app.is_foreground = is_now_foreground;

                if (is_now_foreground) {
                    app.has_logged_rogue_warning = false;
                    if (prev_foreground_keys.find(key) == prev_foreground_keys.end()) {
                         logger_->log(LogLevel::ACTION_OPEN, "æ‰“å¼€", "å·²æ‰“å¼€ (æƒå¨)", app.package_name, app.user_id);
                         app.last_foreground_timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                    }
                    if (unfreeze_and_observe_nolock(app, "åˆ‡æ¢è‡³å‰å°(æƒå¨)")) {
                        probe_config_needs_update = true;
                    }
                    app.observation_since = 0;
                    app.background_since = 0;
                    app.freeze_retry_count = 0;
                } else {
                     if (prev_foreground_keys.count(key) > 0) {
                        long long now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                        long long current_runtime_ms = (app.last_foreground_timestamp_ms > 0) ? (now_ms - app.last_foreground_timestamp_ms) : 0;
                        app.total_runtime_ms += current_runtime_ms;
                        long total_seconds = app.total_runtime_ms / 1000;
                        std::stringstream ss_msg;
                        ss_msg << "å·²å…³é—­ [æœ¬æ¬¡: " << (current_runtime_ms / 1000) << "s] [ç´¯è®¡: "
                               << (total_seconds / 3600) << "h" << ((total_seconds % 3600) / 60) << "m" << (total_seconds % 60) << "s]";
                        logger_->log(LogLevel::ACTION_CLOSE, "å…³é—­", ss_msg.str(), app.package_name, app.user_id);
                    }
                    if (app.current_status == AppRuntimeState::Status::RUNNING && (app.config.policy == AppPolicy::STANDARD || app.config.policy == AppPolicy::STRICT) && !app.pids.empty()) {
                        app.observation_since = now;
                    }
                }
            }
        }
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return state_has_changed;
}

bool StateManager::update_foreground_state_from_pids(const std::set<int>& top_pids) {
    bool state_has_changed = false;
    bool probe_config_needs_update = false;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);

        std::map<int, AppInstanceKey> pid_to_key_map;
        std::set<AppInstanceKey> top_app_keys;
        for (int pid : top_pids) {
            int uid = -1, user_id = -1;
            std::string pkg_name = get_package_name_from_pid(pid, uid, user_id);
            if (!pkg_name.empty() && user_id != -1) {
                AppInstanceKey key = {pkg_name, user_id};
                top_app_keys.insert(key);
                pid_to_key_map[pid] = key;
            }
        }

        std::string current_ime_pkg = sys_monitor_->get_current_ime_package();
        if (!current_ime_pkg.empty()) {
            top_app_keys.insert({current_ime_pkg, 0});
        }

        for (const auto& key : top_app_keys) {
            if (managed_apps_.find(key) == managed_apps_.end()) {
                LOGI("Discovered new top app via fast path: %s (user %d). Creating state...", key.first.c_str(), key.second);
                AppRuntimeState* new_app = get_or_create_app_state(key.first, key.second);
                if (new_app) {
                    for (const auto& [pid, mapped_key] : pid_to_key_map) {
                        if (mapped_key == key) {
                            int uid = -1, user_id_ignored = -1;
                            get_package_name_from_pid(pid, uid, user_id_ignored);
                            add_pid_to_app(pid, key.first, key.second, uid);
                        }
                    }
                    LOGI("State created and PIDs populated for new app %s.", key.first.c_str());
                    state_has_changed = true;
                }
            }
        }

        std::set<AppInstanceKey> prev_foreground_keys;
        for (const auto& [key, app] : managed_apps_) {
            if (app.is_foreground) prev_foreground_keys.insert(key);
        }

        if (top_app_keys == prev_foreground_keys && !state_has_changed) {
            return false;
        }

        const auto& final_foreground_keys = top_app_keys;
        
        time_t now = time(nullptr);
        for (auto& [key, app] : managed_apps_) {
            bool is_now_foreground = final_foreground_keys.count(key);
            if (app.is_foreground != is_now_foreground) {
                state_has_changed = true;
                app.is_foreground = is_now_foreground;

                if (is_now_foreground) {
                    app.has_logged_rogue_warning = false;
                    if (prev_foreground_keys.find(key) == prev_foreground_keys.end()) {
                         logger_->log(LogLevel::ACTION_OPEN, "æ‰“å¼€", "å·²æ‰“å¼€ (å¿«é€Ÿ)", app.package_name, app.user_id);
                         app.last_foreground_timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                    }
                    if (unfreeze_and_observe_nolock(app, "åˆ‡æ¢è‡³å‰å°(å¿«é€Ÿ)")) {
                        probe_config_needs_update = true;
                    }
                    app.observation_since = 0;
                    app.background_since = 0;
                    app.freeze_retry_count = 0;
                } else {
                     if (prev_foreground_keys.count(key) > 0) {
                        long long now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
                        long long current_runtime_ms = (app.last_foreground_timestamp_ms > 0) ? (now_ms - app.last_foreground_timestamp_ms) : 0;
                        app.total_runtime_ms += current_runtime_ms;
                        long total_seconds = app.total_runtime_ms / 1000;
                        std::stringstream ss_msg;
                        ss_msg << "å·²å…³é—­ [æœ¬æ¬¡: " << (current_runtime_ms / 1000) << "s] [ç´¯è®¡: "
                               << (total_seconds / 3600) << "h" << ((total_seconds % 3600) / 60) << "m" << (total_seconds % 60) << "s]";
                        logger_->log(LogLevel::ACTION_CLOSE, "å…³é—­", ss_msg.str(), app.package_name, app.user_id);
                    }
                    if (app.current_status == AppRuntimeState::Status::RUNNING && (app.config.policy == AppPolicy::STANDARD || app.config.policy == AppPolicy::STRICT) && !app.pids.empty()) {
                        app.observation_since = now;
                    }
                }
            }
        }
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return state_has_changed;
}

void StateManager::on_app_foreground_event(const json& payload) {
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("EVENT: Received foreground event for %s (user %d), issuing refresh ticket.", package_name.c_str(), user_id);
        g_top_app_refresh_tickets = 1;

    } catch (const json::exception& e) {
        LOGE("Error processing foreground event: %s", e.what());
    }
}

void StateManager::on_app_background_event(const json& payload) {
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("EVENT: Received background event for %s (user %d), issuing refresh ticket.", package_name.c_str(), user_id);

        g_top_app_refresh_tickets = 1;

    } catch (const json::exception& e) {
        LOGE("Error processing background event: %s", e.what());
    }
}


void StateManager::on_proactive_unfreeze_request(const json& payload) {
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("PROACTIVE: Received unfreeze request for %s (user %d)", package_name.c_str(), user_id);

        std::lock_guard<std::mutex> lock(state_mutex_);
        AppInstanceKey key = {package_name, user_id};
        auto it = managed_apps_.find(key);
        if (it != managed_apps_.end()) {
            if (it->second.current_status == AppRuntimeState::Status::FROZEN) {
                 if(unfreeze_and_observe_nolock(it->second, "PROACTIVE_START", WakeupType::PROACTIVE_START)) {
                    broadcast_dashboard_update();
                    notify_probe_of_config_change();
                 }
            }
        }
    } catch (const json::exception& e) {
        LOGE("Error processing proactive unfreeze request: %s", e.what());
    }
}

void StateManager::on_wakeup_request(const json& payload) {
    bool state_changed = false;
    try {
        std::string package_name = payload.value("package_name", "");
        int user_id = payload.value("user_id", 0);
        if (package_name.empty()) return;

        LOGD("Received wakeup request for %s (user %d)", package_name.c_str(), user_id);

        std::lock_guard<std::mutex> lock(state_mutex_);
        AppInstanceKey key = {package_name, user_id};
        auto it = managed_apps_.find(key);
        if (it != managed_apps_.end()) {
            state_changed = unfreeze_and_observe_nolock(it->second, "WAKEUP_REQUEST");
        } else {
            LOGW("Wakeup request for unknown app: %s", package_name.c_str());
        }
    } catch (const json::exception& e) {
        LOGE("Error processing wakeup request: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::on_temp_unfreeze_request_by_pkg(const json& payload) {
    bool state_changed = false;
    try {
        std::string package_name = payload.value("package_name", "");
        if (package_name.empty()) return;

        LOGD("Received temp unfreeze request by package: %s", package_name.c_str());

        std::lock_guard<std::mutex> lock(state_mutex_);
        bool app_found = false;
        for (auto& [key, app] : managed_apps_) {
            if (key.first == package_name) {
                app_found = true;
                if (unfreeze_and_observe_nolock(app, "FCM")) {
                    state_changed = true;
                }
            }
        }
        if (!app_found) {
            LOGW("Temp unfreeze request for unknown package: %s", package_name.c_str());
        }
    } catch (const json::exception& e) {
        LOGE("Error processing temp unfreeze by pkg: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::on_temp_unfreeze_request_by_uid(const json& payload) {
    bool state_changed = false;
    try {
        int uid = payload.value("uid", -1);
        if (uid < 0) return;

        LOGD("Received temp unfreeze request by UID: %d", uid);

        std::lock_guard<std::mutex> lock(state_mutex_);
        bool app_found = false;
        for (auto& [key, app] : managed_apps_) {
            if (app.uid == uid) {
                app_found = true;
                if (unfreeze_and_observe_nolock(app, "AUDIO_FOCUS", WakeupType::OTHER)) {
                    state_changed = true;
                }
                break;
            }
        }
        if(!app_found) {
            LOGW("Temp unfreeze request for unknown UID: %d", uid);
        }
    } catch (const json::exception& e) {
        LOGE("Error processing temp unfreeze by uid: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::on_temp_unfreeze_request_by_pid(const json& payload) {
    bool state_changed = false;
    try {
        int pid = payload.value("pid", -1);
        if (pid < 0) return;

        LOGD("Received temp unfreeze request by PID: %d", pid);

        std::lock_guard<std::mutex> lock(state_mutex_);
        auto it = pid_to_app_map_.find(pid);
        if (it != pid_to_app_map_.end()) {
            if (unfreeze_and_observe_nolock(*(it->second), "SIGKILL_PROTECT")) {
                state_changed = true;
            }
        } else {
            LOGW("Temp unfreeze request for unknown PID: %d", pid);
        }
    } catch (const json::exception& e) {
        LOGE("Error processing temp unfreeze by pid: %s", e.what());
    }

    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
}

void StateManager::update_master_config(const MasterConfig& config) {
    std::lock_guard<std::mutex> lock(state_mutex_);
    master_config_ = config;
    db_manager_->set_master_config(config);
    LOGI("Master config updated: standard_timeout=%ds, timed_unfreeze_enabled=%d, timed_unfreeze_interval=%ds",
        master_config_.standard_timeout_sec, master_config_.is_timed_unfreeze_enabled, master_config_.timed_unfreeze_interval_sec);
    logger_->log(LogLevel::EVENT, "é…ç½®", "æ ¸å¿ƒé…ç½®å·²æ›´æ–°");
}

bool StateManager::tick_state_machine() {
    bool changed1 = check_timers();
    bool changed2 = check_timed_unfreeze();
    return changed1 || changed2;
}

bool StateManager::is_app_playing_audio(const AppRuntimeState& app) {
    return sys_monitor_->is_uid_playing_audio(app.uid);
}

bool StateManager::check_timers() {
    bool changed = false;
    bool probe_config_needs_update = false;
    const int MAX_FREEZE_RETRIES = 3;
    const int RETRY_DELAY_BASE_SEC = 5;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        time_t now = time(nullptr);
        const double NETWORK_THRESHOLD_KBPS = 50.0;

        for (auto& [key, app] : managed_apps_) {
            if (app.is_foreground || app.config.policy == AppPolicy::EXEMPTED || app.config.policy == AppPolicy::IMPORTANT) {
                if (app.observation_since > 0 || app.background_since > 0) {
                    app.observation_since = 0;
                    app.background_since = 0;
                    app.freeze_retry_count = 0;
                    changed = true;
                }
                continue;
            }

            if (app.observation_since > 0 && now - app.observation_since >= 10) {
                app.observation_since = 0;

                std::vector<std::string> active_reasons;
                if (is_app_playing_audio(app)) active_reasons.push_back("éŸ³é¢‘");
                if (sys_monitor_->is_uid_using_location(app.uid)) active_reasons.push_back("å®šä½");
                if (sys_monitor_->get_cached_network_speed(app.uid).download_kbps > NETWORK_THRESHOLD_KBPS) active_reasons.push_back("ç½‘ç»œ");

                if (!active_reasons.empty()) {
                    std::string reason_str;
                    for (size_t i = 0; i < active_reasons.size(); ++i) {
                        reason_str += active_reasons[i] + (i < active_reasons.size() - 1 ? " / " : "");
                    }
                    std::string log_msg = "å›  " + reason_str + " æ´»è·ƒè€Œæ¨è¿Ÿå†»ç»“";
                    logger_->log(LogLevel::ACTION_DELAY, "å»¶è¿Ÿ", log_msg, app.package_name, app.user_id);
                    app.observation_since = now;
                    changed = true;
                    continue;
                }

                app.background_since = now;
                app.freeze_retry_count = 0;
                changed = true;
            }

            if (app.background_since > 0) {
                int timeout_sec = 0;
                if(app.config.policy == AppPolicy::STRICT) timeout_sec = 15;
                else if(app.config.policy == AppPolicy::STANDARD) timeout_sec = master_config_.standard_timeout_sec;
                if (app.freeze_retry_count > 0) timeout_sec += (RETRY_DELAY_BASE_SEC * app.freeze_retry_count);

                if (timeout_sec > 0 && (now - app.background_since >= timeout_sec)) {
                    size_t total_pids = app.pids.size();
                    std::vector<int> pids_to_freeze;
                    std::string strategy_log_msg;

                    if (app.has_rogue_structure) {
                        strategy_log_msg = "æ£€æµ‹åˆ°æµæ°“ç»“æ„ï¼Œæ‰§è¡Œâ€œæ–©é¦–è¡ŒåŠ¨â€";
                        for (int pid : app.pids) {
                            if (pid != app.rogue_puppet_pid) {
                                pids_to_freeze.push_back(pid);
                            }
                        }
                    } else {
                        strategy_log_msg = "æ‰§è¡Œâ€œå¸¸è§„æ‰“å‡»â€";
                        pids_to_freeze = app.pids;
                    }
                    size_t frozen_pids_count = pids_to_freeze.size();

                    logger_->log(LogLevel::INFO, "å†»ç»“", strategy_log_msg, app.package_name, app.user_id);
                    int freeze_result = action_executor_->freeze(key, pids_to_freeze);
                    
                    std::stringstream log_msg_ss;
                    log_msg_ss << "[" << frozen_pids_count << "/" << total_pids << "] ";

                    switch (freeze_result) {
                        case 0:
                            app.current_status = AppRuntimeState::Status::FROZEN;
                            app.freeze_method = AppRuntimeState::FreezeMethod::CGROUP;
                            log_msg_ss << "å› åå°è¶…æ—¶è¢«å†»ç»“ (Cgroup)";
                            logger_->log(LogLevel::ACTION_FREEZE, "å†»ç»“", log_msg_ss.str(), app.package_name, app.user_id);
                            schedule_timed_unfreeze(app);
                            probe_config_needs_update = true;
                            app.background_since = 0;
                            app.freeze_retry_count = 0;
                            break;
                        case 1:
                            app.current_status = AppRuntimeState::Status::FROZEN;
                            app.freeze_method = AppRuntimeState::FreezeMethod::SIG_STOP;
                            log_msg_ss << "å› åå°è¶…æ—¶è¢«å†»ç»“ (SIGSTOP)";
                            logger_->log(LogLevel::ACTION_FREEZE, "å†»ç»“", log_msg_ss.str(), app.package_name, app.user_id);
                            schedule_timed_unfreeze(app);
                            probe_config_needs_update = true;
                            app.background_since = 0;
                            app.freeze_retry_count = 0;
                            break;
                        case 2:
                            app.freeze_retry_count++;
                            if (app.freeze_retry_count > MAX_FREEZE_RETRIES) {
                                logger_->log(LogLevel::WARN, "å†»ç»“", "å¤šæ¬¡å°è¯•å†»ç»“å¤±è´¥ï¼Œå·²æ”¾å¼ƒ", app.package_name, app.user_id);
                                app.background_since = 0;
                                app.freeze_retry_count = 0;
                            } else {
                                logger_->log(LogLevel::INFO, "å†»ç»“", "å†»ç»“é‡åˆ°è½¯å¤±è´¥ï¼Œå°†é‡è¯•", app.package_name, app.user_id);
                                app.background_since = now;
                            }
                            break;
                        default:
                             logger_->log(LogLevel::ERROR, "å†»ç»“", "å†»ç»“é‡åˆ°è‡´å‘½é”™è¯¯ï¼Œå·²ä¸­æ­¢", app.package_name, app.user_id);
                            app.background_since = 0;
                            app.freeze_retry_count = 0;
                            break;
                    }
                    changed = true;
                }
            }
        }
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return changed;
}

void StateManager::cancel_timed_unfreeze(AppRuntimeState& app) {
    if (app.scheduled_unfreeze_idx != -1) {
        if (app.scheduled_unfreeze_idx < unfrozen_timeline_.size()) {
            if (unfrozen_timeline_[app.scheduled_unfreeze_idx] == app.uid) {
                unfrozen_timeline_[app.scheduled_unfreeze_idx] = 0;
                LOGD("TIMELINE: Cancelled scheduled unfreeze for %s at index %d.", app.package_name.c_str(), app.scheduled_unfreeze_idx);
            }
        }
        app.scheduled_unfreeze_idx = -1;
    }
}

void StateManager::schedule_timed_unfreeze(AppRuntimeState& app) {
    if (!master_config_.is_timed_unfreeze_enabled || master_config_.timed_unfreeze_interval_sec <= 0 || app.uid < 0) {
        return;
    }
    cancel_timed_unfreeze(app);
    uint32_t future_index = (timeline_idx_ + master_config_.timed_unfreeze_interval_sec) % unfrozen_timeline_.size();
    for (size_t i = 0; i < unfrozen_timeline_.size(); ++i) {
        uint32_t current_index = (future_index + i) % unfrozen_timeline_.size();
        if (unfrozen_timeline_[current_index] == 0) {
            unfrozen_timeline_[current_index] = app.uid;
            app.scheduled_unfreeze_idx = current_index;
            LOGD("TIMELINE: Scheduled timed unfreeze for %s (uid %d) at index %u.", app.package_name.c_str(), app.uid, current_index);
            return;
        }
    }
    LOGW("TIMELINE: Could not find empty slot for %s. Timeline is full!", app.package_name.c_str());
}

bool StateManager::check_timed_unfreeze() {
    bool state_changed = false;
    int uid_to_unfreeze;
    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        timeline_idx_ = (timeline_idx_ + 1) % unfrozen_timeline_.size();
        uid_to_unfreeze = unfrozen_timeline_[timeline_idx_];
        if (uid_to_unfreeze == 0) return false;
        unfrozen_timeline_[timeline_idx_] = 0;
    }
    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        for (auto& [key, app] : managed_apps_) {
            if (app.uid == uid_to_unfreeze) {
                if (app.current_status == AppRuntimeState::Status::FROZEN && !app.is_foreground) {
                    LOGI("TIMELINE: Executing timed unfreeze for %s.", app.package_name.c_str());
                    logger_->log(LogLevel::TIMER, "å®šæ—¶å™¨", "æ‰§è¡Œå®šæ—¶è§£å†»", app.package_name, app.user_id);
                    if(unfreeze_and_observe_nolock(app, "å®šæ—¶å™¨å”¤é†’")) {
                       state_changed = true;
                    }
                }
                app.scheduled_unfreeze_idx = -1;
                break;
            }
        }
    }
    if (state_changed) {
        broadcast_dashboard_update();
        notify_probe_of_config_change();
    }
    return state_changed;
}

bool StateManager::perform_deep_scan() {
    bool changed = false;
    {
        std::lock_guard<std::mutex> lock(state_mutex_);

        changed = reconcile_process_state_full();

        time_t now = time(nullptr);

        for (auto& [key, app] : managed_apps_) {
            if (app.pids.empty() && app.current_status != AppRuntimeState::Status::STOPPED) {
                if (app.undetected_since == 0) {
                    app.undetected_since = now;
                } else if (now - app.undetected_since >= 3) {
                    if (app.current_status == AppRuntimeState::Status::FROZEN) {
                         LOGI("Frozen app %s no longer has active PIDs. Marking as STOPPED.", app.package_name.c_str());
                         cancel_timed_unfreeze(app);
                    }
                    app.current_status = AppRuntimeState::Status::STOPPED;
                    app.freeze_method = AppRuntimeState::FreezeMethod::NONE;
                    app.is_foreground = false;
                    app.background_since = 0;
                    app.observation_since = 0;
                    app.freeze_retry_count = 0;
                    app.mem_usage_kb = 0;
                    app.swap_usage_kb = 0;
                    app.cpu_usage_percent = 0.0f;
                    app.undetected_since = 0;
                    changed = true;
                }
            } else if (!app.pids.empty()) {
                app.undetected_since = 0;
            }
        }
    }
    return changed;
}

bool StateManager::on_config_changed_from_ui(const json& payload) {
    bool probe_config_needs_update = false;

    {
        std::lock_guard<std::mutex> lock(state_mutex_);
        if (!payload.contains("policies")) return false;

        LOGI("Applying new configuration from UI...");
        db_manager_->clear_all_policies();

        for (const auto& policy_item : payload["policies"]) {
            AppConfig new_config;
            new_config.package_name = policy_item.value("package_name", "");
            new_config.user_id = policy_item.value("user_id", 0);
            new_config.policy = static_cast<AppPolicy>(policy_item.value("policy", 0));

            if (new_config.package_name.empty()) continue;
            db_manager_->set_app_config(new_config);

            AppRuntimeState* app = get_or_create_app_state(new_config.package_name, new_config.user_id);
            if (app) {
                bool policy_changed = app->config.policy != new_config.policy;
                app->config = new_config;

                if (policy_changed && app->current_status == AppRuntimeState::Status::FROZEN && (new_config.policy == AppPolicy::EXEMPTED || new_config.policy == AppPolicy::IMPORTANT)) {
                     if (unfreeze_and_observe_nolock(*app, "ç­–ç•¥å˜æ›´", WakeupType::OTHER)) {
                         probe_config_needs_update = true;
                     }
                }
            }
        }
        logger_->log(LogLevel::EVENT, "é…ç½®", "åº”ç”¨ç­–ç•¥å·²ä»UIæ›´æ–°");
        LOGI("New configuration applied.");
    }

    if (probe_config_needs_update) {
        notify_probe_of_config_change();
    }
    return true;
}

json StateManager::get_dashboard_payload() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    json payload;
    if (last_metrics_record_) {
        payload["global_stats"] = {
            {"total_cpu_usage_percent", last_metrics_record_->total_cpu_usage_percent},
            {"total_mem_kb", last_metrics_record_->mem_total_kb},
            {"avail_mem_kb", last_metrics_record_->mem_available_kb},
            {"swap_total_kb", last_metrics_record_->swap_total_kb},
            {"swap_free_kb", last_metrics_record_->swap_free_kb},
        };
    } else {
        payload["global_stats"] = json::object();
    }

    json apps_state = json::array();
    for (auto& [key, app] : managed_apps_) {
        if (app.pids.empty() && app.current_status == AppRuntimeState::Status::STOPPED) {
            continue;
        }
        json app_json;
        app_json["package_name"] = app.package_name;
        app_json["app_name"] = app.app_name;
        app_json["user_id"] = app.user_id;
        app_json["display_status"] = status_to_string(app, master_config_);
        app_json["mem_usage_kb"] = app.mem_usage_kb;
        app_json["swap_usage_kb"] = app.swap_usage_kb;
        app_json["cpu_usage_percent"] = app.cpu_usage_percent;
        app_json["is_whitelisted"] = app.config.policy == AppPolicy::EXEMPTED || app.config.policy == AppPolicy::IMPORTANT;
        app_json["is_foreground"] = app.is_foreground;
        if (app.current_status == AppRuntimeState::Status::RUNNING && !app.is_foreground) {
            if (is_app_playing_audio(app)) {
                app_json["exemption_reason"] = "PLAYING_AUDIO";
            }
        }
        apps_state.push_back(app_json);
    }
    payload["apps_runtime_state"] = apps_state;
    return payload;
}

json StateManager::get_full_config_for_ui() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    auto db_master_config = db_manager_->get_master_config().value_or(MasterConfig{});
    auto all_db_configs = db_manager_->get_all_app_configs();
    json response;
    response["master_config"] = {
        {"is_enabled", true},
        {"freeze_on_screen_off", true},
        {"standard_timeout_sec", db_master_config.standard_timeout_sec},
        {"is_timed_unfreeze_enabled", db_master_config.is_timed_unfreeze_enabled},
        {"timed_unfreeze_interval_sec", db_master_config.timed_unfreeze_interval_sec}
    };
    response["exempt_config"] = {{"exempt_foreground_services", true}};
    json policies = json::array();
    for (const auto& config : all_db_configs) {
        policies.push_back({
            {"package_name", config.package_name},
            {"user_id", config.user_id},
            {"policy", static_cast<int>(config.policy)}
        });
    }
    response["policies"] = policies;
    return response;
}

json StateManager::get_probe_config_payload() {
    std::lock_guard<std::mutex> lock(state_mutex_);
    json payload = get_full_config_for_ui();
    json frozen_uids = json::array();
    json frozen_pids = json::array();

    for (const auto& [key, app] : managed_apps_) {
        if (app.current_status == AppRuntimeState::Status::FROZEN) {
            if (app.uid != -1) {
                frozen_uids.push_back(app.uid);
            }
            for (int pid : app.pids) {
                frozen_pids.push_back(pid);
            }
        }
    }
    payload["frozen_uids"] = frozen_uids;
    payload["frozen_pids"] = frozen_pids;
    return payload;
}

bool StateManager::reconcile_process_state_full() {
    bool changed = false;
    std::unordered_map<int, std::tuple<std::string, int, int>> current_pids;
    for (const auto& entry : fs::directory_iterator("/proc")) {
        if (!entry.is_directory()) continue;
        try {
            int pid = std::stoi(entry.path().filename().string());
            int uid = -1, user_id = -1;
            std::string pkg_name = get_package_name_from_pid(pid, uid, user_id);
            if (!pkg_name.empty()) {
                current_pids[pid] = {pkg_name, user_id, uid};
            }
        } catch (...) { continue; }
    }

    std::vector<int> dead_pids;
    for(const auto& [pid, app_ptr] : pid_to_app_map_) {
        if (current_pids.find(pid) == current_pids.end()) {
            dead_pids.push_back(pid);
        }
    }
    if (!dead_pids.empty()) {
        changed = true;
        for (int pid : dead_pids) remove_pid_from_app(pid);
    }

    for(const auto& [pid, info_tuple] : current_pids) {
        if (pid_to_app_map_.find(pid) == pid_to_app_map_.end()) {
            changed = true;
            const auto& [pkg_name, user_id, uid] = info_tuple;
            add_pid_to_app(pid, pkg_name, user_id, uid);
        }
    }
    return changed;
}

void StateManager::load_all_configs() {
    auto configs = db_manager_->get_all_app_configs();
    for (const auto& db_config : configs) {
        get_or_create_app_state(db_config.package_name, db_config.user_id);
    }
}

std::string StateManager::get_package_name_from_pid(int pid, int& uid, int& user_id) {
    constexpr int PER_USER_RANGE = 100000;
    uid = -1; user_id = -1;

    char path_buffer[64];
    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d", pid);
    struct stat st;
    if (stat(path_buffer, &st) != 0) return "";
    uid = st.st_uid;
    if (uid < 10000) return "";
    user_id = uid / PER_USER_RANGE;

    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d/cmdline", pid);
    std::ifstream cmdline_file(path_buffer);
    if (!cmdline_file.is_open()) return "";

    std::string cmdline;
    std::getline(cmdline_file, cmdline, '\0');

    if (cmdline.empty() || cmdline.find('.') == std::string::npos) {
        return "";
    }

    size_t colon_pos = cmdline.find(':');
    if (colon_pos != std::string::npos) {
        return cmdline.substr(0, colon_pos);
    }

    return cmdline;
}

AppRuntimeState* StateManager::get_or_create_app_state(const std::string& package_name, int user_id) {
    if (package_name.empty()) return nullptr;
    AppInstanceKey key = {package_name, user_id};
    auto it = managed_apps_.find(key);
    if (it != managed_apps_.end()) return &it->second;

    AppRuntimeState new_state;
    new_state.package_name = package_name;
    new_state.user_id = user_id;
    new_state.app_name = package_name;

    auto config_opt = db_manager_->get_app_config(package_name, user_id);
    if (config_opt) {
        new_state.config = *config_opt;
    } else {
        LOGI("New app instance discovered: %s (user %d). Creating default DB entry.", package_name.c_str(), user_id);
        if (is_critical_system_app(package_name)) {
            new_state.config = AppConfig{package_name, user_id, AppPolicy::EXEMPTED};
        } else {
            new_state.config = AppConfig{package_name, user_id, AppPolicy::EXEMPTED};
        }
        db_manager_->set_app_config(new_state.config);
    }

    new_state.current_status = AppRuntimeState::Status::STOPPED;
    auto [map_iterator, success] = managed_apps_.emplace(key, new_state);
    return &map_iterator->second;
}

void StateManager::add_pid_to_app(int pid, const std::string& package_name, int user_id, int uid) {
    AppRuntimeState* app = get_or_create_app_state(package_name, user_id);
    if (!app) return;
    if (app->uid == -1) app->uid = uid;

    if (app->app_name == app->package_name) {
        std::string friendly_name = sys_monitor_->get_app_name_from_pid(pid);
        if (!friendly_name.empty()) {
            size_t colon_pos = friendly_name.find(':');
            if (colon_pos != std::string::npos) {
                app->app_name = friendly_name.substr(0, colon_pos);
            } else {
                app->app_name = friendly_name;
            }
        }
    }

    if (std::find(app->pids.begin(), app->pids.end(), pid) == app->pids.end()) {
        app->pids.push_back(pid);
        pid_to_app_map_[pid] = app;
        if (app->current_status == AppRuntimeState::Status::STOPPED) {
           app->current_status = AppRuntimeState::Status::RUNNING;
           logger_->log(LogLevel::INFO, "è¿›ç¨‹", "æ£€æµ‹åˆ°æ–°è¿›ç¨‹å¯åŠ¨", app->package_name, user_id);
        }
    }
}

void StateManager::remove_pid_from_app(int pid) {
    auto it = pid_to_app_map_.find(pid);
    if (it == pid_to_app_map_.end()) return;
    AppRuntimeState* app = it->second;
    pid_to_app_map_.erase(it);
    if (app) {
        auto& pids = app->pids;
        pids.erase(std::remove(pids.begin(), pids.end(), pid), pids.end());
        if (pids.empty()) {
            app->mem_usage_kb = 0;
            app->swap_usage_kb = 0;
            app->cpu_usage_percent = 0.0f;
            app->is_foreground = false;
            app->background_since = 0;
            app->observation_since = 0;
            app->freeze_retry_count = 0;
            app->undetected_since = 0;
            app->freeze_method = AppRuntimeState::FreezeMethod::NONE;
            cancel_timed_unfreeze(*app);
        }
    }
}

bool StateManager::is_critical_system_app(const std::string& package_name) const {
    return critical_system_apps_.count(package_name) > 0;
}
```

daemon/cpp/state_manager.h
```
// daemon/cpp/state_manager.h
#ifndef CERBERUS_STATE_MANAGER_H
#define CERBERUS_STATE_MANAGER_H

#include <nlohmann/json.hpp>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <mutex>
#include <unordered_set>
#include <set>
#include <chrono>
#include "database_manager.h"
#include "system_monitor.h"
#include "action_executor.h"
#include "logger.h"
#include "time_series_database.h"

using json = nlohmann::json;

enum class WakeupType {
    GENERIC_NOTIFICATION, // æ™®é€šé€šçŸ¥ï¼Œé‡å†»æ—¶é—´è¾ƒçŸ­
    FCM_PUSH,             // FCMæ¨é€ï¼Œé‡å†»æ—¶é—´è¾ƒé•¿
    PROACTIVE_START,      // ç”¨æˆ·ä¸»åŠ¨å¯åŠ¨
    OTHER                 // å…¶ä»–ç±»å‹
};

struct AppRuntimeState {
    enum class Status {
        STOPPED,
        RUNNING,
        FROZEN
    } current_status = Status::STOPPED;

    enum class FreezeMethod {
        NONE,
        CGROUP,
        SIG_STOP
    } freeze_method = FreezeMethod::NONE;

    std::string package_name;
    std::string app_name;
    int uid = -1;
    int user_id = 0;
    std::vector<int> pids;
    AppConfig config;

    bool is_foreground = false;
    time_t background_since = 0;
    time_t observation_since = 0;
    time_t undetected_since = 0;
    int freeze_retry_count = 0;

    bool has_rogue_structure = false;
    int rogue_puppet_pid = -1;
    int rogue_master_pid = -1;

    bool has_logged_rogue_warning = false;

    int scheduled_unfreeze_idx = -1;

    float cpu_usage_percent = 0.0f;
    long mem_usage_kb = 0;
    long swap_usage_kb = 0;
    long long last_foreground_timestamp_ms = 0;
    long long total_runtime_ms = 0;
};

class DozeManager {
public:
    enum class State { AWAKE, IDLE, INACTIVE, DEEP_DOZE };
    enum class DozeEvent { NONE, ENTERED_DEEP_DOZE, EXITED_DEEP_DOZE };

    DozeManager(std::shared_ptr<Logger> logger, std::shared_ptr<ActionExecutor> executor);
    DozeEvent process_metrics(const MetricsRecord& record);

private:
    void enter_state(State new_state, const MetricsRecord& record);

    State current_state_ = State::AWAKE;
    std::chrono::steady_clock::time_point state_change_timestamp_;
    std::chrono::steady_clock::time_point deep_doze_start_time_;
    std::shared_ptr<Logger> logger_;
    std::shared_ptr<ActionExecutor> action_executor_;
};

// [æ ¸å¿ƒé‡æ„] ä¸ºDozeæŠ¥å‘Šå¢åŠ ä¸€ä¸ªä¸“é—¨çš„ç»“æ„ä½“
struct DozeProcessRecord {
    long long start_jiffies;
    std::string process_name;
    std::string package_name;
    int user_id;
};

class StateManager {
public:
    StateManager(std::shared_ptr<DatabaseManager>, std::shared_ptr<SystemMonitor>, std::shared_ptr<ActionExecutor>,
                 std::shared_ptr<Logger>, std::shared_ptr<TimeSeriesDatabase>);

    void initial_full_scan_and_warmup();
    bool evaluate_and_execute_strategy();
    bool handle_top_app_change_fast();
    void process_new_metrics(const MetricsRecord& record);
    bool tick_state_machine();
    bool perform_deep_scan();
    bool on_config_changed_from_ui(const json& payload);
    void update_master_config(const MasterConfig& config);
    json get_dashboard_payload();
    json get_full_config_for_ui();
    json get_probe_config_payload();
    void on_app_foreground_event(const json& payload);
    void on_app_background_event(const json& payload);
    void on_proactive_unfreeze_request(const json& payload);
    void on_wakeup_request(const json& payload);
    void on_temp_unfreeze_request_by_pkg(const json& payload);
    void on_temp_unfreeze_request_by_uid(const json& payload);
    void on_temp_unfreeze_request_by_pid(const json& payload);
    bool perform_staggered_stats_scan();
    void on_wakeup_request_from_probe(const json& payload);

private:
    void handle_charging_state_change(const MetricsRecord& old_record, const MetricsRecord& new_record);
    void generate_doze_exit_report();
    void analyze_battery_change(const MetricsRecord& old_record, const MetricsRecord& new_record);
    bool unfreeze_and_observe_nolock(AppRuntimeState& app, const std::string& reason, WakeupType wakeup_type = WakeupType::OTHER);
    bool reconcile_process_state_full();
    void load_all_configs();
    std::string get_package_name_from_pid(int pid, int& uid, int& user_id);
    void add_pid_to_app(int pid, const std::string&, int user_id, int uid);
    void remove_pid_from_app(int pid);
    AppRuntimeState* get_or_create_app_state(const std::string&, int user_id);
    bool is_critical_system_app(const std::string&) const;
    bool is_app_playing_audio(const AppRuntimeState& app);
    void schedule_timed_unfreeze(AppRuntimeState& app);
    bool check_timed_unfreeze();
    void cancel_timed_unfreeze(AppRuntimeState& app);
    bool check_timers();
    bool update_foreground_state_from_pids(const std::set<int>& top_pids);
    bool update_foreground_state(const std::set<AppInstanceKey>& visible_app_keys);
    void audit_app_structures(const std::map<int, ProcessInfo>& process_tree);

    std::shared_ptr<DatabaseManager> db_manager_;
    std::shared_ptr<SystemMonitor> sys_monitor_;
    std::shared_ptr<ActionExecutor> action_executor_;
    std::shared_ptr<Logger> logger_;
    std::shared_ptr<TimeSeriesDatabase> ts_db_;

    MasterConfig master_config_;
    std::unique_ptr<DozeManager> doze_manager_;
    std::mutex state_mutex_;
    std::set<AppInstanceKey> last_known_visible_app_keys_;
    std::optional<MetricsRecord> last_metrics_record_;
    std::optional<std::pair<int, long long>> last_battery_level_info_;
    uint32_t timeline_idx_ = 0;
    std::vector<int> unfrozen_timeline_;
    
    // [æ ¸å¿ƒé‡æ„] ä¿®æ”¹Dozeæ•°æ®ç»“æ„ï¼Œä»¥PIDä¸ºkey
    std::map<int, DozeProcessRecord> doze_start_process_info_;

    std::map<AppInstanceKey, AppRuntimeState> managed_apps_;
    std::map<int, AppRuntimeState*> pid_to_app_map_;
    std::unordered_set<std::string> critical_system_apps_;
    std::map<AppInstanceKey, AppRuntimeState>::iterator next_scan_iterator_;
};

#endif //CERBERUS_STATE_MANAGER_H
```

daemon/cpp/system_monitor.cpp
```
// daemon/cpp/system_monitor.cpp
#include "system_monitor.h"
#include <fstream>
#include <sstream>
#include <android/log.h>
#include <unistd.h>
#include <filesystem>
#include <sys/inotify.h>
#include <sys/select.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <climits>
#include <vector>
#include <cstdio>
#include <array>
#include <cctype>
#include <ctime>
#include <algorithm>
#include <iterator>
#include <chrono>
#include <string>
#include <memory>
#include <map>
#include <unordered_set>
#include <numeric>

#define LOG_TAG "cerberusd_monitor_v32_multicore" // ç‰ˆæœ¬å·æ›´æ–°
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)

namespace fs = std::filesystem;

constexpr long long CACHE_DURATION_MS = 2000;

SystemMonitor::ProcFileReader::ProcFileReader(std::string path) : path_(std::move(path)) {}

SystemMonitor::ProcFileReader::~ProcFileReader() {
    if (fd_ != -1) {
        close(fd_);
    }
}

bool SystemMonitor::ProcFileReader::open_fd() {
    if (fd_ != -1) return true;
    fd_ = open(path_.c_str(), O_RDONLY | O_CLOEXEC);
    if (fd_ == -1) {
        // This can happen, not always an error worth logging loudly.
        return false;
    }
    return true;
}

bool SystemMonitor::ProcFileReader::read_contents(std::string& out_contents) {
    if (!open_fd()) return false;

    char buffer[4096];
    if (lseek(fd_, 0, SEEK_SET) != 0) {
        close(fd_);
        fd_ = -1;
        if (!open_fd()) return false;
    }
    
    ssize_t bytes_read = read(fd_, buffer, sizeof(buffer) - 1);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        out_contents = buffer;
        return true;
    }
    return false;
}

std::string SystemMonitor::read_file_once(const std::string& path, size_t max_size) {
    int fd = open(path.c_str(), O_RDONLY | O_CLOEXEC);
    if (fd == -1) return "";

    std::string content;
    content.resize(max_size);
    ssize_t bytes_read = read(fd, content.data(), max_size - 1);
    close(fd);

    if (bytes_read > 0) {
        content.resize(bytes_read);
        return content;
    }
    return "";
}

static std::optional<long> read_long_from_file_str(const std::string& content) {
    if (content.empty()) return std::nullopt;
    try {
        return std::stol(content);
    } catch (...) {
        return std::nullopt;
    }
}

std::string SystemMonitor::exec_shell_pipe_efficient(const std::vector<std::string>& args) {
    if (args.empty()) return "";

    int pipe_fd[2];
    if (pipe2(pipe_fd, O_CLOEXEC) == -1) {
        LOGE("pipe2 failed: %s", strerror(errno));
        return "";
    }

    pid_t pid = fork();
    if (pid == -1) {
        LOGE("fork failed: %s", strerror(errno));
        close(pipe_fd[0]);
        close(pipe_fd[1]);
        return "";
    }

    if (pid == 0) { 
        close(pipe_fd[0]); 
        dup2(pipe_fd[1], STDOUT_FILENO);
        close(pipe_fd[1]);
        
        std::vector<char*> c_args;
        for (const auto& arg : args) {
            c_args.push_back(const_cast<char*>(arg.c_str()));
        }
        c_args.push_back(nullptr);

        execvp(c_args[0], c_args.data());
        exit(127);
    }

    close(pipe_fd[1]);
    std::string result;
    result.reserve(65536);
    char buffer[4096];
    ssize_t count;

    while ((count = read(pipe_fd[0], buffer, sizeof(buffer))) > 0) {
        result.append(buffer, count);
    }
    close(pipe_fd[0]);

    int status;
    waitpid(pid, &status, 0);

    return result;
}

int get_uid_from_pid(int pid) {
    char path_buffer[64];
    snprintf(path_buffer, sizeof(path_buffer), "/proc/%d", pid);
    struct stat st;
    if (stat(path_buffer, &st) != 0) return -1;
    return st.st_uid;
}

SystemMonitor::SystemMonitor() : proc_stat_reader_("/proc/stat") {
    if (fs::exists("/dev/cpuset/top-app/tasks")) {
        top_app_tasks_path_ = "/dev/cpuset/top-app/tasks";
    } else if (fs::exists("/dev/cpuset/top-app/cgroup.procs")) {
        top_app_tasks_path_ = "/dev/cpuset/top-app/cgroup.procs";
    } else {
        LOGE("Could not find top-app tasks file. Active monitoring disabled.");
    }

    MetricsRecord dummy_record;
    update_cpu_usage(dummy_record); // Initial call to populate prev times
    
    last_screen_state_check_time_ = {};
    last_visible_apps_check_time_ = {};
}

SystemMonitor::~SystemMonitor() {
    stop_top_app_monitor();
    stop_network_snapshot_thread();
}

std::optional<MetricsRecord> SystemMonitor::collect_current_metrics() {
    MetricsRecord record;
    record.timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();
    
    update_cpu_usage(record);
    update_mem_info(record.mem_total_kb, record.mem_available_kb, record.swap_total_kb, record.swap_free_kb);
    
    get_battery_stats(record.battery_level, record.battery_temp_celsius, record.battery_power_watt, record.is_charging);
    record.is_screen_on = get_screen_state();

    {
        std::lock_guard<std::mutex> lock(audio_uids_mutex_);
        record.is_audio_playing = !uids_playing_audio_.empty();
    }
    {
        std::lock_guard<std::mutex> lock(location_uids_mutex_);
        record.is_location_active = !uids_using_location_.empty();
    }

    return record;
}

// [æ ¸å¿ƒä¿®æ”¹] update_cpu_usageç°åœ¨è®¡ç®—æ€»çš„å’Œæ¯ä¸ªæ ¸å¿ƒçš„ä½¿ç”¨ç‡
void SystemMonitor::update_cpu_usage(MetricsRecord& record) {
    std::string stat_content;
    if (!proc_stat_reader_.read_contents(stat_content) || stat_content.empty()) return;

    std::stringstream ss(stat_content);
    std::string line;
    std::vector<TotalCpuTimes> current_per_core_times;

    // Process total CPU (first line)
    std::getline(ss, line);
    std::string cpu_label;
    TotalCpuTimes current_total_times;
    std::stringstream total_ss(line);
    total_ss >> cpu_label >> current_total_times.user >> current_total_times.nice >> current_total_times.system >> current_total_times.idle
             >> current_total_times.iowait >> current_total_times.irq >> current_total_times.softirq >> current_total_times.steal;
    
    if (cpu_label == "cpu") {
        long long prev_total = prev_total_cpu_times_.total();
        long long current_total = current_total_times.total();
        long long delta_total = current_total - prev_total;
        if (delta_total > 0) {
            long long delta_idle = current_total_times.idle_total() - prev_total_cpu_times_.idle_total();
            float cpu_usage = 100.0f * static_cast<float>(delta_total - delta_idle) / static_cast<float>(delta_total);
            record.total_cpu_usage_percent = std::max(0.0f, std::min(100.0f, cpu_usage));
        } else {
            record.total_cpu_usage_percent = 0.0f;
        }
        prev_total_cpu_times_ = current_total_times;
    }

    // Process per-core CPUs
    while (std::getline(ss, line)) {
        if (line.rfind("cpu", 0) != 0) break; // Stop if not a cpu line
        std::stringstream core_ss(line);
        TotalCpuTimes core_times;
        core_ss >> cpu_label >> core_times.user >> core_times.nice >> core_times.system >> core_times.idle
                >> core_times.iowait >> core_times.irq >> core_times.softirq >> core_times.steal;
        current_per_core_times.push_back(core_times);
    }

    if (prev_per_core_cpu_times_.empty()) {
        LOGI("First CPU poll, found %zu cores. Storing initial values.", current_per_core_times.size());
        prev_per_core_cpu_times_ = current_per_core_times;
        record.per_core_cpu_usage.assign(current_per_core_times.size(), 0.0f);
        return;
    }

    size_t num_cores = std::min(prev_per_core_cpu_times_.size(), current_per_core_times.size());
    record.per_core_cpu_usage.resize(num_cores);

    for (size_t i = 0; i < num_cores; ++i) {
        const auto& prev = prev_per_core_cpu_times_[i];
        const auto& curr = current_per_core_times[i];
        long long delta_total = curr.total() - prev.total();
        if (delta_total > 0) {
            long long delta_idle = curr.idle_total() - prev.idle_total();
            float usage = 100.0f * static_cast<float>(delta_total - delta_idle) / static_cast<float>(delta_total);
            record.per_core_cpu_usage[i] = std::max(0.0f, std::min(100.0f, usage));
        } else {
            record.per_core_cpu_usage[i] = 0.0f;
        }
    }

    prev_per_core_cpu_times_ = current_per_core_times;
}

void SystemMonitor::update_mem_info(long& total, long& available, long& swap_total, long& swap_free) {
    std::string meminfo_content = read_file_once("/proc/meminfo");
    if (meminfo_content.empty()) return;

    std::stringstream ss(meminfo_content);
    std::string line;
    while (std::getline(ss, line)) {
        std::string key;
        long value;
        std::stringstream line_ss(line);
        line_ss >> key >> value;
        if (key == "MemTotal:") total = value;
        else if (key == "MemAvailable:") available = value;
        else if (key == "SwapTotal:") swap_total = value;
        else if (key == "SwapFree:") swap_free = value;
    }
}

void SystemMonitor::update_app_stats(const std::vector<int>& pids, long& total_mem_kb, long& total_swap_kb, float& total_cpu_percent) {
    total_mem_kb = 0;
    total_swap_kb = 0;
    total_cpu_percent = 0.0f;
    if (pids.empty()) return;

    for (int pid : pids) {
        std::string proc_path = "/proc/" + std::to_string(pid);
        if (!fs::exists(proc_path)) continue;
        
        std::string rollup_content = read_file_once(proc_path + "/smaps_rollup");
        if (!rollup_content.empty()) {
            std::stringstream ss(rollup_content);
            std::string line;
            while (std::getline(ss, line)) {
                std::stringstream line_ss(line);
                std::string key;
                long value;
                line_ss >> key >> value;
                if (key == "Pss:") total_mem_kb += value;
                else if (key == "Swap:") total_swap_kb += value;
            }
        }
        
        std::string stat_content = read_file_once(proc_path + "/stat");
        if (!stat_content.empty()) {
            std::stringstream ss(stat_content);
            std::string value;
            for(int i = 0; i < 13; ++i) ss >> value;
            long long utime, stime;
            ss >> utime >> stime;
            long long current_app_jiffies = utime + stime;
            long long current_total_jiffies;
            {
                std::lock_guard<std::mutex> lock(data_mutex_);
                current_total_jiffies = prev_total_cpu_times_.total();
            }
            auto& prev_times = app_cpu_times_[pid];
            if (prev_times.app_jiffies > 0 && prev_times.total_jiffies > 0) {
                long long app_delta = current_app_jiffies - prev_times.app_jiffies;
                long long total_delta = current_total_jiffies - prev_times.total_jiffies;
                if (total_delta > 0 && app_delta >= 0) {
                    total_cpu_percent += 100.0f * static_cast<float>(app_delta) / static_cast<float>(total_delta);
                }
            }
            prev_times.app_jiffies = current_app_jiffies;
            prev_times.total_jiffies = current_total_jiffies;
        }
    }
}
std::string SystemMonitor::get_app_name_from_pid(int pid) {
    std::string cmdline = read_file_once("/proc/" + std::to_string(pid) + "/cmdline");
    if (!cmdline.empty()) {
        size_t null_pos = cmdline.find('\0');
        if(null_pos != std::string::npos) cmdline.resize(null_pos);
        if(!cmdline.empty()) return cmdline;
    }
    std::string status_content = read_file_once("/proc/" + std::to_string(pid) + "/status");
    if (!status_content.empty()) {
        std::stringstream ss(status_content);
        std::string line;
        while (std::getline(ss, line)) {
            if (line.rfind("Name:", 0) == 0) {
                std::string name = line.substr(line.find(":") + 1);
                name.erase(0, name.find_first_not_of(" \t"));
                name.erase(name.find_last_not_of(" \t\n") + 1);
                return name;
            }
        }
    }
    return "Unknown";
}
long long SystemMonitor::get_total_cpu_jiffies_for_pids(const std::vector<int>& pids) {
    long long total_jiffies = 0;
    for (int pid : pids) {
        std::string stat_content = read_file_once(std::string("/proc/") + std::to_string(pid) + "/stat");
        if (!stat_content.empty()) {
            std::stringstream ss(stat_content);
            std::string value;
            for(int i = 0; i < 13; ++i) ss >> value;
            long long utime = 0, stime = 0;
            ss >> utime >> stime;
            total_jiffies += (utime + stime);
        }
    }
    return total_jiffies;
}
bool SystemMonitor::get_screen_state() {
    std::lock_guard<std::mutex> lock(screen_state_mutex_);
    auto now = std::chrono::steady_clock::now();
    auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_screen_state_check_time_).count();
    if (elapsed_ms < CACHE_DURATION_MS) {
        return cached_screen_on_state_;
    }
    LOGD("Screen state cache expired, executing dumpsys power...");
    last_screen_state_check_time_ = now;
    std::string result = exec_shell_pipe_efficient({"dumpsys", "power"});
    size_t pos = result.find("mWakefulness=");
    if(pos == std::string::npos) pos = result.find("mWakefulnessRaw=");
    if(pos != std::string::npos) {
        cached_screen_on_state_ = result.find("Awake", pos) != std::string::npos;
        return cached_screen_on_state_;
    }
    return cached_screen_on_state_;
}
void SystemMonitor::get_battery_stats(int& level, float& temp, float& power, bool& charging) {
    const std::string battery_path = "/sys/class/power_supply/battery/";
    const std::string bms_path = "/sys/class/power_supply/bms/";
    std::string final_path = fs::exists(battery_path) ? battery_path : (fs::exists(bms_path) ? bms_path : "");
    if (final_path.empty()) {
        level = -1; temp = 0.0f; power = 0.0f; charging = false;
        return;
    }
    level = read_long_from_file_str(read_file_once(final_path + "capacity")).value_or(-1);
    auto temp_raw = read_long_from_file_str(read_file_once(final_path + "temp"));
    if (temp_raw.has_value()) {
        temp = static_cast<float>(*temp_raw) / 10.0f;
    } else {
        temp = 0.0f;
    }
    auto current_now_ua = read_long_from_file_str(read_file_once(final_path + "current_now"));
    auto voltage_now_uv = read_long_from_file_str(read_file_once(final_path + "voltage_now"));
    if (current_now_ua.has_value() && voltage_now_uv.has_value()) {
        double current_a = static_cast<double>(*current_now_ua) / 1000.0;
        double voltage_v = static_cast<double>(*voltage_now_uv) / 1000000.0;
        power = static_cast<float>(std::abs(current_a * voltage_v));
    } else {
        power = 0.0f;
    }
    std::string status = read_file_once(final_path + "status");
    if(!status.empty()) {
        status.erase(status.find_last_not_of(" \n\r\t")+1);
        charging = (status == "Charging" || status == "Full");
    } else {
        charging = false;
    }
}
void SystemMonitor::start_top_app_monitor() {
    if (top_app_tasks_path_.empty()) return;
    monitoring_active_ = true;
    monitor_thread_ = std::thread(&SystemMonitor::top_app_monitor_thread, this);
    LOGI("Top-app monitor started for path: %s", top_app_tasks_path_.c_str());
}
void SystemMonitor::stop_top_app_monitor() {
    monitoring_active_ = false;
    if (monitor_thread_.joinable()) {
        monitor_thread_.join();
    }
}
std::set<int> SystemMonitor::read_top_app_pids() {
    std::set<int> pids;
    if (top_app_tasks_path_.empty()) return pids;
    std::string content = read_file_once(top_app_tasks_path_);
    if(content.empty()) return pids;
    std::stringstream ss(content);
    int pid;
    while (ss >> pid) {
        pids.insert(pid);
    }
    return pids;
}
void SystemMonitor::top_app_monitor_thread() {
    int fd = inotify_init1(IN_CLOEXEC);
    if (fd < 0) { LOGE("inotify_init1 failed: %s", strerror(errno)); return; }
    int wd = inotify_add_watch(fd, top_app_tasks_path_.c_str(), IN_CLOSE_WRITE | IN_OPEN | IN_MODIFY);
    if (wd < 0) { LOGE("inotify_add_watch failed for %s: %s", top_app_tasks_path_.c_str(), strerror(errno)); close(fd); return; }
    char buf[sizeof(struct inotify_event) + NAME_MAX + 1];
    while (monitoring_active_) {
        ssize_t len = read(fd, buf, sizeof(buf));
        if (!monitoring_active_) break;
        if (len < 0) {
            if (errno == EINTR) continue;
            break;
        }
        g_top_app_refresh_tickets = 2; 
    }
    inotify_rm_watch(fd, wd);
    close(fd);
    LOGI("Top-app monitor stopped.");
}
std::set<AppInstanceKey> SystemMonitor::get_visible_app_keys() {
    std::lock_guard<std::mutex> lock(visible_apps_mutex_);
    auto now = std::chrono::steady_clock::now();
    auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_visible_apps_check_time_).count();
    if (elapsed_ms < CACHE_DURATION_MS) {
        return cached_visible_app_keys_;
    }
    LOGD("Visible apps cache expired, executing dumpsys activity activities...");
    last_visible_apps_check_time_ = now;
    std::set<AppInstanceKey> visible_keys;
    std::string dumpsys_output = exec_shell_pipe_efficient({"dumpsys", "activity", "activities"});
    if (dumpsys_output.empty()) {
        cached_visible_app_keys_ = visible_keys;
        return visible_keys;
    }
    std::stringstream ss(dumpsys_output);
    std::string line;
    std::vector<std::string> lines;
    while(std::getline(ss, line)) {
        lines.push_back(line);
    }
    size_t start_index = (lines.size() > 15) ? (lines.size() - 15) : 0;
    for (size_t i = start_index; i < lines.size(); ++i) {
        const auto& current_line = lines[i];
        if (current_line.find("VisibleActivityProcess:") != std::string::npos) {
            std::stringstream line_ss(current_line);
            std::string token;
            while (line_ss >> token) {
                size_t u_pos = token.find("/u");
                if (u_pos != std::string::npos) {
                    try {
                        std::string package_name = token.substr(0, u_pos);
                        std::string user_part = token.substr(u_pos + 2);
                        size_t a_pos = user_part.find('a');
                        if (a_pos != std::string::npos) {
                            user_part = user_part.substr(0, a_pos);
                        }
                        int user_id = std::stoi(user_part);
                        visible_keys.insert({package_name, user_id});
                    } catch (...) { /* ignore parse errors */ }
                }
            }
            break;
        }
    }
    cached_visible_app_keys_ = visible_keys;
    return visible_keys;
}
std::map<int, ProcessInfo> SystemMonitor::get_full_process_tree() {
    std::map<int, ProcessInfo> process_map;
    constexpr int PER_USER_RANGE = 100000;
    for (const auto& entry : fs::directory_iterator("/proc")) {
        if (!entry.is_directory()) continue;
        int pid = 0;
        try {
            pid = std::stoi(entry.path().filename().string());
        } catch (...) { continue; }
        char path_buffer[256];
        snprintf(path_buffer, sizeof(path_buffer), "/proc/%d", pid);
        struct stat st;
        if (stat(path_buffer, &st) != 0 || st.st_uid < 10000) continue;
        ProcessInfo info;
        info.pid = pid;
        info.uid = st.st_uid;
        info.user_id = info.uid / PER_USER_RANGE;
        std::string stat_content = read_file_once(std::string("/proc/") + std::to_string(pid) + "/stat");
        if (!stat_content.empty()) {
            std::stringstream stat_ss(stat_content);
            std::string s;
            stat_ss >> s >> s >> s >> info.ppid;
        }
        info.oom_score_adj = read_long_from_file_str(read_file_once(std::string("/proc/") + std::to_string(pid) + "/oom_score_adj")).value_or(1001);
        info.pkg_name = read_file_once(std::string("/proc/") + std::to_string(pid) + "/cmdline");
        size_t null_pos = info.pkg_name.find('\0');
        if(null_pos != std::string::npos) info.pkg_name.resize(null_pos);
        if (!info.pkg_name.empty() && info.pkg_name.find('.') != std::string::npos) {
           size_t colon_pos = info.pkg_name.find(':');
           if (colon_pos != std::string::npos) {
               info.pkg_name = info.pkg_name.substr(0, colon_pos);
           }
           process_map[pid] = info;
        }
    }
    return process_map;
}
void SystemMonitor::update_audio_state() {
    std::map<int, std::vector<int>> uid_session_states;
    std::unordered_set<std::string> ignored_usages = {"USAGE_ASSISTANCE_SONIFICATION", "USAGE_TOUCH_INTERACTION_RESPONSE"};
    std::string dumpsys_output = exec_shell_pipe_efficient({"dumpsys", "audio"});
    std::stringstream ss(dumpsys_output);
    std::string line;
    bool in_players_section = false;
    while (std::getline(ss, line)) {
        if (!in_players_section) {
            if (line.find("players:") != std::string::npos) {
                in_players_section = true;
            }
            continue;
        }
        if (line.find("ducked players piids:") != std::string::npos) {
            break;
        }
        if (line.find("AudioPlaybackConfiguration") != std::string::npos) {
            try {
                bool is_ignored = false;
                for (const auto& usage : ignored_usages) {
                    if (line.find(usage) != std::string::npos) {
                        is_ignored = true;
                        break;
                    }
                }
                if (is_ignored) continue;
                int uid = -1;
                size_t upid_pos = line.find("u/pid:");
                if (upid_pos != std::string::npos) {
                    std::stringstream line_ss(line.substr(upid_pos + 6));
                    line_ss >> uid;
                }
                if (uid < 10000) continue;
                size_t state_pos = line.find(" state:");
                if (state_pos != std::string::npos) {
                    std::string state_str = line.substr(state_pos + 7);
                    if (state_str.rfind("started", 0) == 0) {
                        uid_session_states[uid].push_back(1);
                    } else if (state_str.rfind("paused", 0) == 0) {
                        uid_session_states[uid].push_back(0);
                    }
                }
            } catch (...) {}
        }
    }
    std::set<int> active_uids;
    for (const auto& [uid, states] : uid_session_states) {
        if (states.empty()) continue;
        int product = std::accumulate(states.begin(), states.end(), 1, std::multiplies<int>());
        if (product == 1) {
            active_uids.insert(uid);
        }
    }
    {
        std::lock_guard<std::mutex> lock(audio_uids_mutex_);
        if (uids_playing_audio_ != active_uids) {
            LOGI("Active audio UIDs changed. Old count: %zu, New count: %zu.", uids_playing_audio_.size(), active_uids.size());
            uids_playing_audio_ = active_uids;
        }
    }
}
bool SystemMonitor::is_uid_playing_audio(int uid) {
    std::lock_guard<std::mutex> lock(audio_uids_mutex_);
    return uids_playing_audio_.count(uid) > 0;
}
void SystemMonitor::start_network_snapshot_thread() {
    if (network_monitoring_active_) return;
    network_monitoring_active_ = true;
    {
        std::lock_guard<std::mutex> lock(traffic_mutex_);
        last_traffic_snapshot_ = read_current_traffic();
        last_snapshot_time_ = std::chrono::steady_clock::now();
    }
    network_thread_ = std::thread(&SystemMonitor::network_snapshot_thread_func, this);
    LOGI("Network snapshot thread started.");
}
void SystemMonitor::stop_network_snapshot_thread() {
    network_monitoring_active_ = false;
    if (network_thread_.joinable()) {
        network_thread_.join();
    }
}
void SystemMonitor::network_snapshot_thread_func() {
    while (network_monitoring_active_) {
        std::this_thread::sleep_for(std::chrono::seconds(5));
        if (!network_monitoring_active_) break;
        auto current_snapshot = read_current_traffic();
        auto current_time = std::chrono::steady_clock::now();
        std::map<int, TrafficStats> last_snapshot;
        std::chrono::steady_clock::time_point last_time;
        {
            std::lock_guard<std::mutex> lock(traffic_mutex_);
            last_snapshot = last_traffic_snapshot_;
            last_time = last_snapshot_time_;
        }
        double time_delta_sec = std::chrono::duration_cast<std::chrono::duration<double>>(current_time - last_time).count();
        if (time_delta_sec < 0.1) continue;
        {
            std::lock_guard<std::mutex> lock(speed_mutex_);
            const double DECAY_FACTOR = 0.5;
            for (auto& [uid, speed] : uid_network_speed_) {
                speed.download_kbps *= DECAY_FACTOR;
                speed.upload_kbps *= DECAY_FACTOR;
                if (speed.download_kbps < 0.1) speed.download_kbps = 0.0;
                if (speed.upload_kbps < 0.1) speed.upload_kbps = 0.0;
            }
            for (const auto& [uid, current_stats] : current_snapshot) {
                auto last_it = last_snapshot.find(uid);
                if (last_it != last_snapshot.end()) {
                    long long rx_delta = (current_stats.rx_bytes > last_it->second.rx_bytes) ? (current_stats.rx_bytes - last_it->second.rx_bytes) : 0;
                    long long tx_delta = (current_stats.tx_bytes > last_it->second.tx_bytes) ? (current_stats.tx_bytes - last_it->second.tx_bytes) : 0;
                    if (rx_delta > 0 || tx_delta > 0) {
                        uid_network_speed_[uid] = {
                            .download_kbps = (static_cast<double>(rx_delta) / 1024.0) / time_delta_sec,
                            .upload_kbps = (static_cast<double>(tx_delta) / 1024.0) / time_delta_sec
                        };
                    }
                }
            }
        }
        {
            std::lock_guard<std::mutex> lock(traffic_mutex_);
            last_traffic_snapshot_ = current_snapshot;
            last_snapshot_time_ = current_time;
        }
    }
    LOGI("Network snapshot thread stopped.");
}
NetworkSpeed SystemMonitor::get_cached_network_speed(int uid) {
    std::lock_guard<std::mutex> lock(speed_mutex_);
    auto it = uid_network_speed_.find(uid);
    if (it != uid_network_speed_.end()) {
        return it->second;
    }
    return NetworkSpeed();
}
std::map<int, TrafficStats> SystemMonitor::read_current_traffic() {
    std::map<int, TrafficStats> snapshot;
    const std::string qtaguid_path = "/proc/net/xt_qtaguid/stats";
    std::string qtaguid_content = read_file_once(qtaguid_path, 256 * 1024);
    if (!qtaguid_content.empty()) {
        std::stringstream ss(qtaguid_content);
        std::string line;
        std::getline(ss, line);
        while (std::getline(ss, line)) {
            std::stringstream line_ss(line);
            std::string idx, iface, acct_tag, set;
            int uid, cnt_set, protocol;
            long long rx_bytes, rx_packets, tx_bytes, tx_packets;
            line_ss >> idx >> iface >> acct_tag >> uid >> cnt_set >> set >> protocol >> rx_bytes >> rx_packets >> tx_bytes >> tx_packets;
            if (uid >= 10000) {
                snapshot[uid].rx_bytes += rx_bytes;
                snapshot[uid].tx_bytes += tx_bytes;
            }
        }
        if (!snapshot.empty()) {
            return snapshot;
        }
    }
    std::string result = exec_shell_pipe_efficient({"dumpsys", "netstats"});
    std::stringstream ss(result);
    std::string line;
    enum class ParseState { searching, in_mTun, in_mStatsFactory };
    ParseState state = ParseState::searching;
    while (std::getline(ss, line)) {
        if (state == ParseState::searching) {
            if (line.find("mTunAnd464xlatAdjustedStats ") != std::string::npos) {
                state = ParseState::in_mTun;
                continue;
            } else if (line.find("mStatsFactory:") != std::string::npos) {
                state = ParseState::in_mStatsFactory;
                continue;
            }
        }
        if (state == ParseState::in_mStatsFactory || state == ParseState::in_mTun) {
            if (line.find(" uid=") != std::string::npos && line.find(" rxBytes=") != std::string::npos) {
                try {
                    int uid = -1;
                    long long rx = -1, tx = -1;
                    std::string part;
                    std::stringstream line_ss(line);
                    while (line_ss >> part && part.find("uid=") == std::string::npos);
                    if (part.find("uid=") == 0) {
                        uid = std::stoi(part.substr(4));
                        while (line_ss >> part && part.find("rxBytes=") == std::string::npos);
                        if(part.find("rxBytes=") == 0) rx = std::stoll(part.substr(8));
                        while (line_ss >> part && part.find("txBytes=") == std::string::npos);
                        if(part.find("txBytes=") == 0) tx = std::stoll(part.substr(8));
                        if (uid >= 10000 && rx != -1 && tx != -1) {
                            snapshot[uid].rx_bytes += rx;
                            snapshot[uid].tx_bytes += tx;
                        }
                    }
                } catch (const std::exception& e) {}
            }
        }
    }
    if (snapshot.empty()) {
        LOGW("Both /proc and dumpsys netstats parsing failed to get any traffic data.");
    }
    return snapshot;
}
std::string SystemMonitor::get_current_ime_package() {
    std::lock_guard<std::mutex> lock(ime_mutex_);
    time_t now = time(nullptr);
    if (now - last_ime_check_time_ > 60 || current_ime_package_.empty()) {
        std::string result = exec_shell_pipe_efficient({"settings", "get", "secure", "default_input_method"});
        size_t slash_pos = result.find('/');
        if (slash_pos != std::string::npos) {
            current_ime_package_ = result.substr(0, slash_pos);
        } else {
            result.erase(std::remove(result.begin(), result.end(), '\n'), result.end());
            current_ime_package_ = result;
        }
        last_ime_check_time_ = now;
        LOGD("Checked default IME: '%s'", current_ime_package_.c_str());
    }
    return current_ime_package_;
}
void SystemMonitor::update_location_state() {
    std::set<int> active_uids;
    std::string result = exec_shell_pipe_efficient({"dumpsys", "location"});
    std::stringstream ss(result);
    std::string line;
    bool in_gps_provider_section = false;
    while (std::getline(ss, line)) {
        if (!in_gps_provider_section) {
            if (line.find("gps provider:") != std::string::npos) {
                in_gps_provider_section = true;
                if (line.find("[OFF]") != std::string::npos) {
                    in_gps_provider_section = false; 
                }
            }
            continue;
        }
        if (line.find("user 0:") != std::string::npos) {
            in_gps_provider_section = false;
            continue;
        }
        size_t ws_pos = line.find("WorkSource{");
        if (ws_pos != std::string::npos) {
            try {
                std::string ws_content = line.substr(ws_pos + 11);
                std::stringstream ws_ss(ws_content);
                int uid = -1;
                ws_ss >> uid;
                if (uid >= 10000) {
                    active_uids.insert(uid);
                }
            } catch (const std::exception& e) {
                 LOGW("Failed to parse WorkSource line: %s", line.c_str());
            }
        }
    }
    {
        std::lock_guard<std::mutex> lock(location_uids_mutex_);
        if (uids_using_location_ != active_uids) {
            std::stringstream log_ss;
            for(int uid : active_uids) { log_ss << uid << " "; }
            LOGI("Active location UIDs changed (gps provider policy). Old count: %zu, New count: %zu. Active UIDs: [ %s]", uids_using_location_.size(), active_uids.size(), log_ss.str().c_str());
            uids_using_location_ = active_uids;
        }
    }
}
bool SystemMonitor::is_uid_using_location(int uid) {
    std::lock_guard<std::mutex> lock(location_uids_mutex_);
    return uids_using_location_.count(uid) > 0;
}
int SystemMonitor::get_pid_from_pkg(const std::string& pkg_name) {
    for (const auto& entry : fs::directory_iterator("/proc")) {
        if (!entry.is_directory()) continue;
        try {
            int pid = std::stoi(entry.path().filename().string());
            std::string cmdline = read_file_once(std::string("/proc/") + std::to_string(pid) + "/cmdline");
            if (cmdline.rfind(pkg_name, 0) == 0) {
                return pid;
            }
        } catch (...) { continue; }
    }
    return -1;
}
```

daemon/cpp/system_monitor.h
```
// daemon/cpp/system_monitor.h
#ifndef CERBERUS_SYSTEM_MONITOR_H
#define CERBERUS_SYSTEM_MONITOR_H

#include "time_series_database.h"
#include <string>
#include <mutex>
#include <map>
#include <vector>
#include <set>
#include <thread>
#include <atomic>
#include <functional>
#include <optional>
#include <utility>
#include <chrono>

using AppInstanceKey = std::pair<std::string, int>;

struct CpuTimeSlice {
    long long app_jiffies = 0;
    long long total_jiffies = 0;
};

struct NetworkSpeed {
    double download_kbps = 0.0;
    double upload_kbps = 0.0;
};

struct TrafficStats {
    long long rx_bytes = 0;
    long long tx_bytes = 0;
};

struct ProcessInfo {
    int pid = 0;
    int ppid = 0;
    int oom_score_adj = 1001;
    std::string pkg_name;
    int user_id = -1;
    int uid = -1;
};

extern std::atomic<int> g_top_app_refresh_tickets;

class SystemMonitor {
public:
    SystemMonitor();
    ~SystemMonitor();

    std::optional<MetricsRecord> collect_current_metrics();

    void update_app_stats(const std::vector<int>& pids, long& mem_kb, long& swap_kb, float& cpu_percent);
    std::string get_app_name_from_pid(int pid);

    long long get_total_cpu_jiffies_for_pids(const std::vector<int>& pids);

    void start_top_app_monitor();
    void stop_top_app_monitor();
    std::set<int> read_top_app_pids();

    std::set<AppInstanceKey> get_visible_app_keys();
    std::map<int, ProcessInfo> get_full_process_tree();

    void update_audio_state();
    bool is_uid_playing_audio(int uid);

    void update_location_state();
    bool is_uid_using_location(int uid);

    std::string get_current_ime_package();

    void start_network_snapshot_thread();
    void stop_network_snapshot_thread();
    NetworkSpeed get_cached_network_speed(int uid);

private:
    class ProcFileReader {
    public:
        ProcFileReader(std::string path);
        ~ProcFileReader();
        bool read_contents(std::string& out_contents);

    private:
        int fd_ = -1;
        std::string path_;
        bool open_fd();
    };

    std::string exec_shell_pipe_efficient(const std::vector<std::string>& args);
    static std::string read_file_once(const std::string& path, size_t max_size = 4096);

    // [æ ¸å¿ƒä¿®æ”¹] update_cpu_usage ç°åœ¨å¡«å…… MetricsRecord
    void update_cpu_usage(MetricsRecord& record);
    void update_mem_info(long& total, long& available, long& swap_total, long& swap_free);
    bool get_screen_state();
    void get_battery_stats(int& level, float& temp, float& power, bool& charging);

    int get_pid_from_pkg(const std::string& pkg_name);

    void top_app_monitor_thread();

    struct TotalCpuTimes {
        long long user = 0, nice = 0, system = 0, idle = 0;
        long long iowait = 0, irq = 0, softirq = 0, steal = 0;
        long long total() const { return user + nice + system + idle + iowait + irq + softirq + steal; }
        long long idle_total() const { return idle + iowait; }
    };

    mutable std::mutex data_mutex_;
    // [æ ¸å¿ƒä¿®æ”¹] å­˜å‚¨ä¸Šä¸€æ¬¡æ€»CPUå’Œæ¯ä¸ªæ ¸å¿ƒçš„CPUæ—¶é—´
    TotalCpuTimes prev_total_cpu_times_;
    std::vector<TotalCpuTimes> prev_per_core_cpu_times_;
    std::map<int, CpuTimeSlice> app_cpu_times_;

    ProcFileReader proc_stat_reader_;

    std::set<int> last_known_top_pids_;
    std::thread monitor_thread_;
    std::atomic<bool> monitoring_active_{false};
    std::string top_app_tasks_path_;

    std::mutex audio_uids_mutex_;
    std::set<int> uids_playing_audio_;

    mutable std::mutex location_uids_mutex_;
    std::set<int> uids_using_location_;

    mutable std::mutex ime_mutex_;
    std::string current_ime_package_;
    time_t last_ime_check_time_ = 0;

    mutable std::mutex screen_state_mutex_;
    std::chrono::steady_clock::time_point last_screen_state_check_time_;
    bool cached_screen_on_state_ = true;

    mutable std::mutex visible_apps_mutex_;
    std::chrono::steady_clock::time_point last_visible_apps_check_time_;
    std::set<AppInstanceKey> cached_visible_app_keys_;

    void network_snapshot_thread_func();
    std::map<int, TrafficStats> read_current_traffic();

    std::thread network_thread_;
    std::atomic<bool> network_monitoring_active_{false};
    mutable std::mutex traffic_mutex_;
    std::map<int, TrafficStats> last_traffic_snapshot_;
    std::chrono::steady_clock::time_point last_snapshot_time_;
    mutable std::mutex speed_mutex_;
    std::map<int, NetworkSpeed> uid_network_speed_;
};

#endif //CERBERUS_SYSTEM_MONITOR_H
```

daemon/cpp/time_series_database.cpp
```
// daemon/cpp/time_series_database.cpp
#include "time_series_database.h"
#include "uds_server.h"

extern std::unique_ptr<UdsServer> g_server;

std::shared_ptr<TimeSeriesDatabase> TimeSeriesDatabase::instance_ = nullptr;
std::mutex TimeSeriesDatabase::instance_mutex_;

json MetricsRecord::to_json() const {
    return json{
        {"timestamp", timestamp_ms},
        // [æ ¸å¿ƒä¿®æ”¹] å­—æ®µé‡å‘½åä»¥ä¿æŒä¸€è‡´
        {"cpu_usage_percent", total_cpu_usage_percent},
        // [æ ¸å¿ƒæ–°å¢] åºåˆ—åŒ–æ¯æ ¸å¿ƒä½¿ç”¨ç‡
        {"per_core_cpu_usage_percent", per_core_cpu_usage},
        {"mem_total_kb", mem_total_kb},
        {"mem_available_kb", mem_available_kb},
        {"swap_total_kb", swap_total_kb},
        {"swap_free_kb", swap_free_kb},
        {"battery_level", battery_level},
        {"battery_temp_celsius", battery_temp_celsius},
        {"battery_power_watt", battery_power_watt},
        {"is_charging", is_charging},
        {"is_screen_on", is_screen_on},
        {"is_audio_playing", is_audio_playing},
        {"is_location_active", is_location_active}
    };
}

std::shared_ptr<TimeSeriesDatabase> TimeSeriesDatabase::get_instance(size_t max_size) {
    std::lock_guard<std::mutex> lock(instance_mutex_);
    if (!instance_) {
        struct make_shared_enabler : public TimeSeriesDatabase {
            make_shared_enabler(size_t size) : TimeSeriesDatabase(size) {}
        };
        instance_ = std::make_shared<make_shared_enabler>(max_size);
    }
    return instance_;
}

TimeSeriesDatabase::TimeSeriesDatabase(size_t max_size) : max_size_(max_size) {}

void TimeSeriesDatabase::add_record(const MetricsRecord& record) {
    {
        std::lock_guard<std::mutex> lock(db_mutex_);
        if (records_.size() >= max_size_) {
            records_.pop_front();
        }
        records_.push_back(record);
    }
    
    if (g_server) {
        g_server->broadcast_message(json{
            {"type", "stream.new_stats_record"},
            {"payload", record.to_json()}
        }.dump());
    }
}

std::vector<MetricsRecord> TimeSeriesDatabase::get_records_since(long long timestamp_ms) const {
    std::vector<MetricsRecord> result;
    std::lock_guard<std::mutex> lock(db_mutex_);
    for (const auto& record : records_) {
        if (record.timestamp_ms >= timestamp_ms) {
            result.push_back(record);
        }
    }
    return result;
}

std::vector<MetricsRecord> TimeSeriesDatabase::get_all_records() const {
    std::lock_guard<std::mutex> lock(db_mutex_);
    return std::vector<MetricsRecord>(records_.begin(), records_.end());
}

std::optional<MetricsRecord> TimeSeriesDatabase::get_latest_record() const {
    std::lock_guard<std::mutex> lock(db_mutex_);
    if (records_.empty()) {
        return std::nullopt;
    }
    return records_.back();
}
```

daemon/cpp/time_series_database.h
```
// daemon/cpp/time_series_database.h
#ifndef CERBERUS_TIME_SERIES_DATABASE_H
#define CERBERUS_TIME_SERIES_DATABASE_H

#include <vector>
#include <deque>
#include <mutex>
#include <chrono>
#include <nlohmann/json.hpp>
#include <memory>
#include <optional>

using json = nlohmann::json;

struct MetricsRecord {
    long long timestamp_ms;
    // [æ ¸å¿ƒä¿®æ”¹] total_cpu_usage_percent ç”¨äºä»ªè¡¨ç›˜å’Œæ—§é€»è¾‘
    float total_cpu_usage_percent = 0.0f; 
    // [æ ¸å¿ƒæ–°å¢] per_core_cpu_usage ç”¨äºæ–°çš„ç»Ÿè®¡å›¾è¡¨
    std::vector<float> per_core_cpu_usage; 
    long mem_total_kb = 0;
    long mem_available_kb = 0;
    long swap_total_kb = 0;
    long swap_free_kb = 0;
    int battery_level = -1;
    float battery_temp_celsius = 0.0f;
    float battery_power_watt = 0.0f;
    bool is_charging = false;
    bool is_screen_on = true;
    bool is_audio_playing = false;
    bool is_location_active = false;

    json to_json() const;
};

class TimeSeriesDatabase : public std::enable_shared_from_this<TimeSeriesDatabase> {
public:
    static std::shared_ptr<TimeSeriesDatabase> get_instance(size_t max_size = 900);
    ~TimeSeriesDatabase() = default;

    TimeSeriesDatabase(const TimeSeriesDatabase&) = delete;
    TimeSeriesDatabase& operator=(const TimeSeriesDatabase&) = delete;

    void add_record(const MetricsRecord& record);
    std::vector<MetricsRecord> get_records_since(long long timestamp_ms) const;
    std::vector<MetricsRecord> get_all_records() const;
    std::optional<MetricsRecord> get_latest_record() const;

private:
    explicit TimeSeriesDatabase(size_t max_size);

    static std::shared_ptr<TimeSeriesDatabase> instance_;
    static std::mutex instance_mutex_;

    size_t max_size_;
    std::deque<MetricsRecord> records_;
    mutable std::mutex db_mutex_;
};

#endif // CERBERUS_TIME_SERIES_DATABASE_H
```

daemon/cpp/uds_server.cpp
```
// daemon/cpp/uds_server.cpp
#include "uds_server.h"
#include <android/log.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h> // [æ–°å¢] For TCP_NODELAY
#include <arpa/inet.h>
#include <unistd.h>
#include <cerrno>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cstddef>
#include <sys/select.h>
#include <thread>

#define LOG_TAG "cerberusd_tcp_v3_nodelay" // ç‰ˆæœ¬å·æ›´æ–°
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

UdsServer::UdsServer(int port)
    : port_(port), server_fd_(-1), is_running_(false) {}

UdsServer::~UdsServer() {
    stop();
}

void UdsServer::set_message_handler(std::function<void(int, const std::string&)> handler) {
    on_message_received_ = std::move(handler);
}

void UdsServer::set_disconnect_handler(std::function<void(int)> handler) {
    on_disconnect_ = std::move(handler);
}

void UdsServer::identify_client_as_ui(int client_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    LOGI("Client fd %d identified as UI.", client_fd);
    ui_client_fds_.insert(client_fd);
}

void UdsServer::broadcast_message_to_ui(const std::string& message) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    if (ui_client_fds_.empty()) return;

    auto ui_clients_copy = ui_client_fds_;
    for (int fd : ui_clients_copy) {
        send_message(fd, message);
    }
}

bool UdsServer::has_clients() const {
    std::lock_guard<std::mutex> lock(client_mutex_);
    return !client_fds_.empty();
}

void UdsServer::add_client(int client_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    client_fds_.push_back(client_fd);
    client_buffers_[client_fd] = "";
    LOGI("Client connected, fd: %d. Total clients: %zu", client_fd, client_fds_.size());
}

void UdsServer::remove_client(int client_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    auto it = std::remove(client_fds_.begin(), client_fds_.end(), client_fd);
    if (it != client_fds_.end()) {
        client_fds_.erase(it, client_fds_.end());
        client_buffers_.erase(client_fd);
        ui_client_fds_.erase(client_fd);
        close(client_fd);
        LOGI("Client disconnected, fd: %d. Total clients: %zu, UI clients: %zu", client_fd, client_fds_.size(), ui_client_fds_.size());
        if (on_disconnect_) {
            on_disconnect_(client_fd);
        }
    }
}

void UdsServer::broadcast_message_except(const std::string& message, int excluded_fd) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    if (client_fds_.empty()) return;

    auto clients_copy = client_fds_;
    for (int fd : clients_copy) {
        if (fd != excluded_fd) {
            send_message(fd, message);
        }
    }
}

bool UdsServer::send_message(int client_fd, const std::string& message) {
    std::string line = message + "\n";
    ssize_t bytes_sent = send(client_fd, line.c_str(), line.length(), MSG_NOSIGNAL);
    if (bytes_sent < 0) {
        if (errno == EPIPE || errno == ECONNRESET) {
            LOGW("Send to fd %d failed (connection closed), removing client.", client_fd);
            std::thread([this, client_fd] { this->remove_client(client_fd); }).detach();
        } else {
            LOGE("Send to fd %d failed: %s", client_fd, strerror(errno));
        }
        return false;
    }
    return true;
}

void UdsServer::broadcast_message(const std::string& message) {
    std::lock_guard<std::mutex> lock(client_mutex_);
    if (client_fds_.empty()) return;

    auto clients_copy = client_fds_;
    for (int fd : clients_copy) {
        send_message(fd, message);
    }
}

void UdsServer::handle_client_data(int client_fd) {
    char buffer[4096];
    ssize_t bytes_read = recv(client_fd, buffer, sizeof(buffer), 0);

    if (bytes_read <= 0) {
        remove_client(client_fd);
        return;
    }

    std::string received_data(buffer, bytes_read);
    std::vector<std::string> messages_to_process;

    {
        std::lock_guard<std::mutex> lock(client_mutex_);
        auto buffer_it = client_buffers_.find(client_fd);
        if (buffer_it == client_buffers_.end()) return;
        
        buffer_it->second += received_data;
        std::string& client_buffer = buffer_it->second;

        size_t pos;
        while ((pos = client_buffer.find('\n')) != std::string::npos) {
            std::string message = client_buffer.substr(0, pos);
            if (!message.empty()) {
                messages_to_process.push_back(message);
            }
            client_buffer.erase(0, pos + 1);
        }
    }

    if (on_message_received_ && !messages_to_process.empty()) {
        for (const auto& msg : messages_to_process) {
            on_message_received_(client_fd, msg);
        }
    }
}

void UdsServer::stop() {
    if (!is_running_.exchange(false)) return;
    LOGI("Stopping TCP server...");
    
    if (server_fd_ != -1) {
        shutdown(server_fd_, SHUT_RDWR);
        close(server_fd_);
        server_fd_ = -1;
    }

    std::lock_guard<std::mutex> lock(client_mutex_);
    for (int fd : client_fds_) {
        close(fd);
    }
    client_fds_.clear();
    ui_client_fds_.clear();
    client_buffers_.clear();
    LOGI("TCP Server stopped and all clients disconnected.");
}

void UdsServer::run() {
    server_fd_ = socket(AF_INET, SOCK_STREAM | SOCK_CLOEXEC, 0);
    if (server_fd_ == -1) {
        LOGE("Failed to create TCP socket: %s", strerror(errno));
        return;
    }

    int opt = 1;
    if (setsockopt(server_fd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        LOGE("setsockopt(SO_REUSEADDR) failed: %s", strerror(errno));
        close(server_fd_);
        return;
    }

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons(port_);

    if (bind(server_fd_, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        LOGE("Failed to bind TCP socket to 127.0.0.1:%d : %s", port_, strerror(errno));
        close(server_fd_);
        return;
    }

    if (listen(server_fd_, 5) == -1) {
        LOGE("Failed to listen on TCP socket: %s", strerror(errno));
        close(server_fd_);
        return;
    }

    LOGI("Server listening on TCP 127.0.0.1:%d", port_);
    is_running_ = true;

    while (is_running_) {
        fd_set read_fds;
        FD_ZERO(&read_fds);
        FD_SET(server_fd_, &read_fds);
        int max_fd = server_fd_;

        {
            std::lock_guard<std::mutex> lock(client_mutex_);
            for (int fd : client_fds_) {
                FD_SET(fd, &read_fds);
                max_fd = std::max(max_fd, fd);
            }
        }
        
        struct timeval tv { .tv_sec = 1, .tv_usec = 0 };
        int activity = select(max_fd + 1, &read_fds, nullptr, nullptr, &tv);

        if (activity < 0) {
            if (errno == EINTR) continue;
            LOGE("select() error: %s", strerror(errno));
            break;
        }
        if (!is_running_) break;
        if (activity == 0) continue;

        if (FD_ISSET(server_fd_, &read_fds)) {
            struct sockaddr_in client_addr;
            socklen_t client_len = sizeof(client_addr);
            int new_socket = accept(server_fd_, (struct sockaddr*)&client_addr, &client_len);
            if (new_socket >= 0) {
                // [é€šä¿¡ä¼˜åŒ–] ç¦ç”¨Nagleç®—æ³•
                int nodelay_opt = 1;
                if (setsockopt(new_socket, IPPROTO_TCP, TCP_NODELAY, &nodelay_opt, sizeof(nodelay_opt)) < 0) {
                    LOGW("setsockopt(TCP_NODELAY) failed for client fd %d: %s", new_socket, strerror(errno));
                }
                add_client(new_socket);
            }
        }
        
        std::vector<int> clients_to_check;
        {
            std::lock_guard<std::mutex> lock(client_mutex_);
            clients_to_check = client_fds_;
        }
        for (int fd : clients_to_check) {
            if (FD_ISSET(fd, &read_fds)) {
                handle_client_data(fd);
            }
        }
    }
    LOGI("Server event loop terminated.");
}
```

daemon/cpp/uds_server.h
```
// daemon/cpp/uds_server.h
#ifndef CERBERUSD_UDS_SERVER_H
#define CERBERUSD_UDS_SERVER_H

#include <string>
#include <vector>
#include <mutex>
#include <atomic>
#include <functional>
#include <map>
#include <set> // [æ–°å¢] ç”¨äºå­˜æ”¾UIå®¢æˆ·ç«¯

// ä¸ºäº†å‡å°‘æ–‡ä»¶é‡å‘½åï¼Œæˆ‘ä»¬ç»§ç»­ä½¿ç”¨è¿™ä¸ªç±»åï¼Œä½†å®ƒç°åœ¨æ˜¯ä¸€ä¸ªTCPæœåŠ¡å™¨
class UdsServer {
public:
    // æ„é€ å‡½æ•°ç°åœ¨æ¥å—ä¸€ä¸ªç«¯å£å·
    explicit UdsServer(int port);
    ~UdsServer();

    UdsServer(const UdsServer&) = delete;
    UdsServer& operator=(const UdsServer&) = delete;

    void run();
    void stop();
    
    void broadcast_message(const std::string& message);
    void set_message_handler(std::function<void(int client_fd, const std::string&)> handler);
    bool send_message(int client_fd, const std::string& message);
    bool has_clients() const;
    void broadcast_message_except(const std::string& message, int excluded_fd);
    void set_disconnect_handler(std::function<void(int client_fd)> handler);

    // [æ–°å¢] ä¸“é—¨ç”¨äºå¿ƒè·³ç­‰UIç‰¹å®šå¹¿æ’­
    void broadcast_message_to_ui(const std::string& message);
    // [æ–°å¢] å¤–éƒ¨è°ƒç”¨çš„æ–¹æ³•ï¼Œç”¨äºè¯†åˆ«å®¢æˆ·ç«¯ç±»å‹
    void identify_client_as_ui(int client_fd);

private:
    void add_client(int client_fd);
    void remove_client(int client_fd);
    void handle_client_data(int client_fd);

    int port_;
    int server_fd_;
    std::atomic<bool> is_running_;
    
    std::vector<int> client_fds_;
    // [æ–°å¢] ä¸“é—¨å­˜æ”¾UIå®¢æˆ·ç«¯çš„fdï¼Œç”¨äºå‘é€å¿ƒè·³
    std::set<int> ui_client_fds_;
    mutable std::mutex client_mutex_;

    std::function<void(int, const std::string&)> on_message_received_;
    std::function<void(int)> on_disconnect_;
    std::map<int, std::string> client_buffers_;
};

#endif //CERBERUSD_UDS_SERVER_H
```



gradle.properties

# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true

gradlew

#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"


gradlew.bat

@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega


local.properties

## This file is automatically generated by Android Studio.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file should *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
sdk.dir=C\:\\Users\\zeaol\\AppData\\Local\\Android\\Sdk

project_context.txt

build.gradle.kts
```
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    // æ­£ç¡®å¼•ç”¨åœ¨ toml ä¸­å®šä¹‰çš„ compose æ’ä»¶
    alias(libs.plugins.jetbrains.compose) apply false
}
```

settings.gradle.kts
```
// D:/project/Cerberus/settings.gradle.kts

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}

// æ ¸å¿ƒï¼šè¿™é‡Œæ˜¯å”¯ä¸€ä¸”åˆå¹¶åçš„ dependencyResolutionManagement å—
dependencyResolutionManagement {
    // ä»“åº“ç®¡ç†æ¨¡å¼è®¾ç½®ï¼Œä¿æŒä¸å˜
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)

    // ğŸ‡¨ğŸ‡³ æŠŠæ‰€æœ‰ä»“åº“éƒ½æ”¾åœ¨è¿™ä¸€ä¸ª repositories å—é‡Œ
    repositories {
        google()
        mavenCentral()
        // ğŸ‡¨ğŸ‡³ æŠŠ Xposed çš„ä»“åº“ä¹ŸåŠ åˆ°è¿™é‡Œ
        maven { url = uri("https://api.xposed.info/") }
    }
}

rootProject.name = "CRFzit" // æ‚¨å¯ä»¥ä¿®æ”¹ä¸º "Cerberus"
include(":app")
```

gradle/libs.versions.toml
```
[versions]
# ç‰ˆæœ¬å·å‡ä¿æŒä¸å˜
agp = "8.11.1"
kotlin = "2.2.0"
composeCompiler = "1.5.14"
coreKtx = "1.16.0"
activityCompose = "1.10.1"
composeBom = "2025.06.01"
lifecycleRuntimeKtx = "2.9.1"
lifecycleViewmodelCompose = "2.9.1"
lifecycleKtx = "2.9.1"
navigation = "2.9.1"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
annotation = "1.9.1"
gson = "2.13.1"
materialIconsCore = "1.7.8" # [æ ¸å¿ƒä¼˜åŒ–] æ–°å¢ç‰ˆæœ¬å·ï¼Œç”¨äºæ ¸å¿ƒå›¾æ ‡åº“
androidxMaterial3 = "1.3.2"
accompanist = "0.34.0"

[libraries]
accompanist-swiperefresh = { group = "com.google.accompanist", name = "accompanist-swiperefresh", version.ref = "accompanist" }
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleKtx" }
androidx-lifecycle-viewmodel-compose = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-compose", version.ref = "lifecycleViewmodelCompose" }
androidx-annotation = { group = "androidx.annotation", name = "annotation", version.ref = "annotation" }
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigation" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-material-icons-extended = { group = "androidx.compose.material", name = "material-icons-extended" }
# [æ ¸å¿ƒä¼˜åŒ–] æ–°å¢ core å›¾æ ‡åº“çš„ä¾èµ–å¼•ç”¨
androidx-material-icons-core = { group = "androidx.compose.material", name = "material-icons-core", version.ref = "materialIconsCore" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", "name" = "ui-test-junit4" }
gson = { group = "com.google.code.gson", name = "gson", version.ref = "gson" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
jetbrains-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin"}
```

app/build.gradle.kts
```
// app/build.gradle.kts
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.jetbrains.compose)
}

android {
    namespace = "com.crfzit.crfzit"
    compileSdk = 36

    defaultConfig {
        applicationId = "com.crfzit.crfzit"
        minSdk = 30
        targetSdk = 36
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
        ndk {
            abiFilters.addAll(listOf("arm64-v8a", "armeabi-v7a"))
        }
        buildConfigField("long", "BUILD_TIME", "${System.currentTimeMillis()}L")
    }

    buildTypes {
        release {
            // [æ ¸å¿ƒä¼˜åŒ–] å¼€å¯ä»£ç æ··æ·†å’Œèµ„æºå‹ç¼©ï¼Œå‡å°æœ€ç»ˆAPKä½“ç§¯
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
            proguardFile("proguard-rules-disabler.pro")
            signingConfig = signingConfigs.getByName("debug")
        }
        debug {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    kotlin {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_1_8)
            allWarningsAsErrors.set(false)
        }
        jvmToolchain(17)
    }

    buildFeatures {
        compose = true
        buildConfig = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
    androidResources {
        localeFilters.addAll(listOf("en", "zh-rCN", "zh"))
    }
}
dependencies {
    implementation(libs.accompanist.swiperefresh)
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.lifecycle.viewmodel.ktx)

    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)

    // [æ ¸å¿ƒä¼˜åŒ–] ç§»é™¤å®Œæ•´çš„ extended ä¾èµ–ï¼Œæ”¹ä¸ºä¾èµ–æ›´å°çš„ core æ ¸å¿ƒåº“
    // implementation(libs.androidx.material.icons.extended)
    implementation(libs.androidx.material.icons.core)


    implementation(libs.androidx.lifecycle.viewmodel.compose)
    implementation(libs.androidx.annotation)
    implementation(libs.androidx.navigation.compose)

    implementation(libs.gson)
    implementation("io.coil-kt:coil-compose:2.7.0")

    // Xposed API ä¾èµ–ä¿æŒä¸å˜
    compileOnly("de.robv.android.xposed:api:82")
    compileOnly("de.robv.android.xposed:api:82:sources")

    testImplementation(libs.junit)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
}
```

app/src/main/AndroidManifest.xml
```
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- æ ¸å¿ƒä¿®æ”¹ï¼šæ·»åŠ  INTERNET æƒé™ï¼Œç”¨äºTCPé€šä¿¡ -->
    <uses-permission android:name="android.permission.INTERNET" />

    <!-- å£°æ˜æŸ¥è¯¢æ‰€æœ‰åº”ç”¨çš„æƒé™ -->
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission" />

    <!-- æ¶æ„é‡æ„ï¼šä½¿ç”¨æˆ‘ä»¬è‡ªå®šä¹‰çš„Applicationç±» -->
    <application
        android:name=".CerberusApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Cerberus"
        tools:targetApi="36">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.Cerberus">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <meta-data
            android:name="xposedmodule"
            android:value="true" />
        <meta-data
            android:name="xposeddescription"
            android:value="Project Cerberus - UI &amp; System Probe" />
        <meta-data
            android:name="xposedminversion"
            android:value="82" />
        <meta-data
            android:name="xposedscope"
            android:resource="@array/xposed_scope" />

    </application>
</manifest>
```

app/src/main/java/com/crfzit/crfzit/CerberusApp.kt
```
// app/src/main/java/com/crfzit/crfzit/CerberusApp.kt
package com.crfzit.crfzit

import android.app.Application
import coil.ImageLoader
import coil.ImageLoaderFactory
import coil.request.CachePolicy
import com.crfzit.crfzit.coil.AppIcon
import com.crfzit.crfzit.coil.AppIconFetcher
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob

/**
 * [å†…å­˜ä¼˜åŒ–] è®©æˆ‘ä»¬çš„Applicationç±»å®ç°ImageLoaderFactoryæ¥å£ï¼Œ
 * ä»¥ä¾¿ä¸ºæ•´ä¸ªåº”ç”¨æä¾›ä¸€ä¸ªè‡ªå®šä¹‰é…ç½®çš„Coil ImageLoaderå®ä¾‹ã€‚
 */
class CerberusApp : Application(), ImageLoaderFactory {

    // åˆ›å»ºä¸€ä¸ªè´¯ç©¿æ•´ä¸ªAppç”Ÿå‘½å‘¨æœŸçš„åç¨‹ä½œç”¨åŸŸ
    val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)

    override fun onCreate() {
        super.onCreate()
        // åœ¨Appå¯åŠ¨æ—¶ï¼Œå°±åˆå§‹åŒ–ï¼ˆé¢„çƒ­ï¼‰DaemonRepositoryå•ä¾‹
        DaemonRepository.getInstance(applicationScope)
    }

    /**
     * [å†…å­˜ä¼˜åŒ–] å®ç°ImageLoaderFactoryçš„æ ¸å¿ƒæ–¹æ³•ã€‚
     * åœ¨è¿™é‡Œæˆ‘ä»¬æ„å»ºä¸€ä¸ªåŒ…å«äº†è‡ªå®šä¹‰AppIconFetcherçš„ImageLoaderã€‚
     */
    override fun newImageLoader(): ImageLoader {
        return ImageLoader.Builder(this)
            // æ·»åŠ æˆ‘ä»¬çš„è‡ªå®šä¹‰Fetcherã€‚Coilä¼šæŒ‰é¡ºåºæ£€æŸ¥ç»„ä»¶ã€‚
            .components {
                add(AppIconFetcher.Factory())
            }
            // å¼€å¯å†…å­˜ç¼“å­˜
            .memoryCachePolicy(CachePolicy.ENABLED)
            .memoryCache {
                // é…ç½®å†…å­˜ç¼“å­˜å¤§å°ï¼Œä¾‹å¦‚ï¼Œæœ€å¤§ä¸ºå¯ç”¨å†…å­˜çš„15%
                coil.memory.MemoryCache.Builder(this)
                    .maxSizePercent(0.15)
                    .build()
            }
            // å¼€å¯ç£ç›˜ç¼“å­˜
            .diskCachePolicy(CachePolicy.ENABLED)
            .diskCache {
                // é…ç½®ç£ç›˜ç¼“å­˜
                coil.disk.DiskCache.Builder()
                    .directory(this.cacheDir.resolve("image_cache"))
                    .maxSizePercent(0.02) // ç£ç›˜ç©ºé—´çš„2%
                    .build()
            }
            // å…¨å±€é…ç½®ï¼Œæ‰€æœ‰è¯·æ±‚é»˜è®¤éƒ½å°†äº¤å‰æ·¡å…¥æ•ˆæœ
            .crossfade(true)
            .build()
    }
}
```

app/src/main/java/com/crfzit/crfzit/coil/AppIconFetcher.kt
```
// app/src/main/java/com/crfzit/crfzit/coil/AppIconFetcher.kt
package com.crfzit.crfzit.coil

import android.content.pm.PackageManager
import coil.ImageLoader
import coil.decode.DataSource
import coil.fetch.DrawableResult
import coil.fetch.FetchResult
import coil.fetch.Fetcher
import coil.request.Options

/**
 * [å†…å­˜ä¼˜åŒ–] è‡ªå®šä¹‰æ•°æ®ç±»ï¼Œç”¨äºå‘Coilæ¸…æ™°åœ°è¡¨è¾¾â€œæˆ‘æƒ³è¦åŠ è½½ä¸€ä¸ªåº”ç”¨å›¾æ ‡â€çš„æ„å›¾ã€‚
 * @param packageName è¦åŠ è½½å›¾æ ‡çš„åº”ç”¨åŒ…åã€‚
 */
data class AppIcon(val packageName: String)

/**
 * [å†…å­˜ä¼˜åŒ–] Coilçš„è‡ªå®šä¹‰Fetcherï¼Œå®ƒçŸ¥é“å¦‚ä½•å¤„ç† AppIcon æ•°æ®ç±»ã€‚
 * å½“Coilçœ‹åˆ°ä¸€ä¸ªç±»å‹ä¸ºAppIconçš„è¯·æ±‚æ—¶ï¼Œå®ƒä¼šä½¿ç”¨è¿™ä¸ªFetcheræ¥æ‰§è¡ŒåŠ è½½é€»è¾‘ã€‚
 */
class AppIconFetcher(
    private val options: Options,
    private val data: AppIcon
) : Fetcher {

    override suspend fun fetch(): FetchResult {
        val context = options.context
        val packageManager = context.packageManager

        // ä»PackageManagerè·å–åº”ç”¨å›¾æ ‡çš„Drawable
        val drawable = try {
            packageManager.getApplicationIcon(data.packageName)
        } catch (e: PackageManager.NameNotFoundException) {
            // å¦‚æœåº”ç”¨ä¸å­˜åœ¨ï¼Œè¿”å›nullï¼ŒCoilä¼šä½¿ç”¨errorå ä½ç¬¦
            null
        }

        // å¿…é¡»è¿”å›ä¸€ä¸ªDrawableResult
        return DrawableResult(
            drawable = drawable ?: packageManager.defaultActivityIcon, // å¦‚æœæ‰¾ä¸åˆ°ï¼Œä½¿ç”¨ç³»ç»Ÿé»˜è®¤å›¾æ ‡
            isSampled = false, // æˆ‘ä»¬æ²¡æœ‰å¯¹å®ƒè¿›è¡Œé‡‡æ ·
            dataSource = DataSource.DISK // å›¾æ ‡æ¥è‡ªè®¾å¤‡å­˜å‚¨ï¼Œæ‰€ä»¥æ˜¯DISK
        )
    }

    /**
     * Factoryæ˜¯å¿…éœ€çš„ï¼Œå®ƒå‘Šè¯‰Coilåœ¨ä½•æ—¶ä½¿ç”¨æˆ‘ä»¬çš„AppIconFetcherã€‚
     */
    class Factory : Fetcher.Factory<AppIcon> {
        override fun create(data: AppIcon, options: Options, imageLoader: ImageLoader): Fetcher {
            return AppIconFetcher(options, data)
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/model/AppModels.kt
```
// app/src/main/java/com/crfzit/crfzit/data/model/AppModels.kt
package com.crfzit.crfzit.data.model

enum class Policy(val value: Int) {
    EXEMPTED(0),
    IMPORTANT(1),
    STANDARD(2),
    STRICT(3);

    companion object {
        fun fromInt(value: Int) = entries.find { it.value == value } ?: EXEMPTED
    }
}

data class AppInfo(
    val packageName: String,
    val appName: String,
    val isSystemApp: Boolean,
    val userId: Int = 0,

    var policy: Policy = Policy.EXEMPTED,
    var forcePlaybackExemption: Boolean = false,
    var forceNetworkExemption: Boolean = false
)

enum class LogLevel(val value: Int) {
    INFO(0),
    SUCCESS(1),
    WARN(2),
    ERROR(3),
    EVENT(4),
    DOZE(5),
    BATTERY(6),
    REPORT(7),
    ACTION_OPEN(8),
    ACTION_CLOSE(9),
    ACTION_FREEZE(10),
    ACTION_UNFREEZE(11),
    ACTION_DELAY(12),
    TIMER(13),
    BATCH_PARENT(14);

    companion object {
        fun fromInt(value: Int) = entries.find { it.value == value } ?: INFO
    }
}

data class LogEntry(
    val timestamp: Long,
    val level: LogLevel,
    val category: String,
    val message: String,
    val packageName: String?,
    val userId: Int = -1
)

data class MetricsRecord(
    val timestamp: Long,
    val totalCpuUsagePercent: Float, // [æ ¸å¿ƒä¿®æ”¹] é‡å‘½å
    val perCoreCpuUsagePercent: List<Float>, // [æ ¸å¿ƒæ–°å¢]
    val memTotalKb: Long,
    val memAvailableKb: Long,
    val swapTotalKb: Long,
    val swapFreeKb: Long,
    val batteryLevel: Int,
    val batteryTempCelsius: Float,
    val batteryPowerWatt: Float,
    val isCharging: Boolean,
    val isScreenOn: Boolean,
    val isAudioPlaying: Boolean,
    val isLocationActive: Boolean
)
```

app/src/main/java/com/crfzit/crfzit/data/model/IPCModels.kt
```
// app/src/main/java/com/crfzit/crfzit/data/model/IPCModels.kt
package com.crfzit.crfzit.data.model

import com.google.gson.annotations.SerializedName

data class CerberusMessage<T>(
    @SerializedName("v")
    val version: Int = 12,
    val type: String,
    @SerializedName("req_id")
    val requestId: String? = null,
    val payload: T
)

data class DashboardPayload(
    @SerializedName("global_stats")
    val globalStats: GlobalStats,
    @SerializedName("apps_runtime_state")
    val appsRuntimeState: List<AppRuntimeState>
)

data class GlobalStats(
    @SerializedName("total_cpu_usage_percent")
    val totalCpuUsagePercent: Float = 0f,
    @SerializedName("total_mem_kb")
    val totalMemKb: Long = 0L,
    @SerializedName("avail_mem_kb")
    val availMemKb: Long = 0L,
    @SerializedName("swap_total_kb")
    val swapTotalKb: Long = 0L,
    @SerializedName("swap_free_kb")
    val swapFreeKb: Long = 0L
)

data class AppRuntimeState(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("app_name")
    val appName: String,
    @SerializedName("user_id")
    val userId: Int = 0,
    @SerializedName("display_status")
    val displayStatus: String = "UNKNOWN",
    @SerializedName("mem_usage_kb")
    val memUsageKb: Long = 0L,
    @SerializedName("swap_usage_kb")
    val swapUsageKb: Long = 0L,
    @SerializedName("cpu_usage_percent")
    val cpuUsagePercent: Float = 0f,
    @SerializedName("is_whitelisted")
    val isWhitelisted: Boolean = false,
    @SerializedName("is_foreground")
    val isForeground: Boolean = false
)

// --- Probe -> Daemon äº‹ä»¶æ¨¡å‹ ---
data class AppStateEventPayload(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("user_id")
    val userId: Int
)

// --- é…ç½®æ¨¡å‹ (UI -> Daemon -> Probe) ---
data class FullConfigPayload(
    @SerializedName("master_config")
    val masterConfig: MasterConfig,
    @SerializedName("exempt_config")
    val exemptConfig: ExemptConfig,
    @SerializedName("policies")
    val policies: List<AppPolicyPayload>,
    @SerializedName("frozen_uids")
    val frozenUids: List<Int>? = null
)

data class MasterConfig(
    @SerializedName("is_enabled")
    val isEnabled: Boolean = true,
    @SerializedName("freeze_on_screen_off")
    val freezeOnScreenOff: Boolean = true,
    @SerializedName("standard_timeout_sec")
    val standardTimeoutSec: Int = 90,
    @SerializedName("is_timed_unfreeze_enabled")
    val isTimedUnfreezeEnabled: Boolean = true,
    @SerializedName("timed_unfreeze_interval_sec")
    val timedUnfreezeIntervalSec: Int = 1800
)

data class ExemptConfig(
    @SerializedName("exempt_foreground_services")
    val exemptForegroundServices: Boolean = true
)

data class AppPolicyPayload(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("user_id")
    val userId: Int,
    val policy: Int // Corresponds to AppPolicy enum
)

data class AppInstanceKey(
    @SerializedName("package_name")
    val packageName: String,
    @SerializedName("user_id")
    val userId: Int
)

data class LogEntryPayload(
    val timestamp: Long,
    val level: Int,
    val category: String,
    val message: String,
    @SerializedName("package_name") val packageName: String?,
    @SerializedName("user_id") val userId: Int?
)

data class MetricsRecordPayload(
    val timestamp: Long,
    @SerializedName("cpu_usage_percent") val totalCpuUsagePercent: Float, // [æ ¸å¿ƒä¿®æ”¹] é‡å‘½å
    @SerializedName("per_core_cpu_usage_percent") val perCoreCpuUsagePercent: List<Float>?, // [æ ¸å¿ƒæ–°å¢]
    @SerializedName("mem_total_kb") val memTotalKb: Long,
    @SerializedName("mem_available_kb") val memAvailableKb: Long,
    @SerializedName("swap_total_kb") val swapTotalKb: Long,
    @SerializedName("swap_free_kb") val swapFreeKb: Long,
    @SerializedName("battery_level") val batteryLevel: Int,
    @SerializedName("battery_temp_celsius") val batteryTempCelsius: Float,
    @SerializedName("battery_power_watt") val batteryPowerWatt: Float,
    @SerializedName("is_charging") val isCharging: Boolean,
    @SerializedName("is_screen_on") val isScreenOn: Boolean,
    @SerializedName("is_audio_playing") val isAudioPlaying: Boolean,
    @SerializedName("is_location_active") val isLocationActive: Boolean
)

data class GetLogsPayload(
    val since: Long? = null,
    val before: Long? = null,
    val limit: Int? = null
)
```

app/src/main/java/com/crfzit/crfzit/data/repository/AppInfoRepository.kt
```
// app/src/main/java/com/crfzit/crfzit/data/repository/AppInfoRepository.kt
package com.crfzit.crfzit.data.repository

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import com.crfzit.crfzit.data.model.AppInfo
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import java.util.concurrent.ConcurrentHashMap

class AppInfoRepository private constructor(private val context: Context) {

    private val packageManager: PackageManager = context.packageManager
    // ç¼“å­˜åªä½¿ç”¨åŒ…åä½œä¸ºKeyï¼Œå› ä¸ºæ­¤ä»“åº“åªå¤„ç†ä¸»ç”¨æˆ·çš„åº”ç”¨å…ƒæ•°æ®
    private val appInfoCache: ConcurrentHashMap<String, AppInfo> = ConcurrentHashMap()
    private val cacheMutex = Mutex()

    suspend fun getAllApps(forceRefresh: Boolean = false): List<AppInfo> {
        cacheMutex.withLock {
            if (appInfoCache.isNotEmpty() && !forceRefresh) {
                return appInfoCache.values.toList()
            }
            loadAllInstalledApps()
            return appInfoCache.values.toList()
        }
    }

    suspend fun getAppInfo(packageName: String): AppInfo? {
        appInfoCache[packageName]?.let { return it }

        return cacheMutex.withLock {
            // åŒé‡æ£€æŸ¥é”å®š
            appInfoCache[packageName]?.let { return@withLock it }

            val app = loadSingleApp(packageName)
            app?.let { appInfoCache[packageName] = it }
            app
        }
    }

    private suspend fun loadAllInstalledApps() {
        withContext(Dispatchers.IO) {
            appInfoCache.clear()
            val apps = packageManager.getInstalledApplications(PackageManager.GET_META_DATA)
                .filterNotNull()
                .mapNotNull { appInfo ->
                    try {
                        createAppInfoFrom(appInfo)
                    } catch (e: Exception) {
                        null
                    }
                }

            appInfoCache.putAll(apps.associateBy { it.packageName })
        }
    }

    private suspend fun loadSingleApp(packageName: String): AppInfo? = withContext(Dispatchers.IO) {
        try {
            val appInfo = packageManager.getApplicationInfo(packageName, PackageManager.GET_META_DATA)
            createAppInfoFrom(appInfo)
        } catch (e: PackageManager.NameNotFoundException) {
            null
        }
    }

    private fun createAppInfoFrom(appInfo: ApplicationInfo): AppInfo {
        return AppInfo(
            packageName = appInfo.packageName,
            appName = appInfo.loadLabel(packageManager).toString(),
            // [å†…å­˜ä¼˜åŒ–] ä¸å†åŠ è½½å’Œå­˜å‚¨Drawableå¯¹è±¡
            // icon = appInfo.loadIcon(packageManager),
            isSystemApp = (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0,
            userId = 0 // è¿™ä¸ªä»“åº“è·å–çš„éƒ½æ˜¯ä¸»ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ï¼Œå› æ­¤userIdå›ºå®šä¸º0
        )
    }

    companion object {
        @Volatile
        private var INSTANCE: AppInfoRepository? = null

        fun getInstance(context: Context): AppInfoRepository {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: AppInfoRepository(context.applicationContext).also { INSTANCE = it }
            }
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/repository/DaemonRepository.kt
```
// app/src/main/java/com/crfzit/crfzit/data/repository/DaemonRepository.kt
package com.crfzit.crfzit.data.repository

import android.util.Log
import com.crfzit.crfzit.data.model.*
import com.crfzit.crfzit.data.uds.TcpClient
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import java.util.*
import java.util.concurrent.ConcurrentHashMap

data class GetLogFilesPayload(val placeholder: Int = 0)
data class GetLogsByFilePayload(
    val filename: String?,
    val before: Long?,
    val since: Long?,
    val limit: Int?
)

class DaemonRepository private constructor(
    private val scope: CoroutineScope
) {
    private val tcpClient = TcpClient(scope)
    private val gson = Gson()
    private val pendingRequests = ConcurrentHashMap<String, CompletableDeferred<String>>()

    init {
        tcpClient.start()
        scope.launch(Dispatchers.IO) {
            tcpClient.incomingMessages.collect { jsonLine ->
                try {
                    val baseMsg = gson.fromJson(jsonLine, BaseMessage::class.java)
                    if ((baseMsg.type.startsWith("resp.") || baseMsg.type.startsWith("error.")) && baseMsg.requestId != null) {
                        pendingRequests.remove(baseMsg.requestId)?.complete(jsonLine)
                    }
                } catch (e: JsonSyntaxException) {
                    // Ignore, not a response message
                }
            }
        }
    }

    private fun mapPayloadToMetricsRecord(p: MetricsRecordPayload): MetricsRecord {
        return MetricsRecord(
            timestamp = p.timestamp,
            totalCpuUsagePercent = p.totalCpuUsagePercent, // [æ ¸å¿ƒä¿®æ”¹]
            perCoreCpuUsagePercent = p.perCoreCpuUsagePercent ?: emptyList(), // [æ ¸å¿ƒæ–°å¢]
            memTotalKb = p.memTotalKb,
            memAvailableKb = p.memAvailableKb,
            swapTotalKb = p.swapTotalKb,
            swapFreeKb = p.swapFreeKb,
            batteryLevel = p.batteryLevel,
            batteryTempCelsius = p.batteryTempCelsius,
            batteryPowerWatt = p.batteryPowerWatt,
            isCharging = p.isCharging,
            isScreenOn = p.isScreenOn,
            isAudioPlaying = p.isAudioPlaying,
            isLocationActive = p.isLocationActive
        )
    }

    fun getDashboardStream(): Flow<DashboardPayload> = tcpClient.incomingMessages
        .mapNotNull { jsonLine ->
            try {
                val type = object : TypeToken<CerberusMessage<DashboardPayload>>() {}.type
                val msg = gson.fromJson<CerberusMessage<DashboardPayload>>(jsonLine, type)
                if (msg?.type == "stream.dashboard_update") msg.payload else null
            } catch (e: Exception) {
                Log.w("DaemonRepository", "Failed to parse DashboardPayload: ${e.message}")
                null
            }
        }

    suspend fun getLogFiles(): List<String>? {
        return query("query.get_log_files", GetLogFilesPayload()) { responseJson ->
            val responseType = object : TypeToken<CerberusMessage<List<String>>>() {}.type
            val message = gson.fromJson<CerberusMessage<List<String>>>(responseJson, responseType)
            if (message?.type == "resp.get_log_files") {
                message.payload
            } else {
                null
            }
        }
    }

    suspend fun getLogs(
        filename: String,
        before: Long? = null,
        since: Long? = null,
        limit: Int? = null
    ): List<LogEntry>? {
        val payload = GetLogsByFilePayload(filename = filename, before = before, since = since, limit = limit)
        return query("query.get_logs", payload) { responseJson ->
            val responseType = object : TypeToken<CerberusMessage<List<LogEntryPayload>>>() {}.type
            val message = gson.fromJson<CerberusMessage<List<LogEntryPayload>>>(responseJson, responseType)
            if (message?.type == "resp.get_logs") {
                message.payload.map { p ->
                    LogEntry(p.timestamp, LogLevel.fromInt(p.level), p.category, p.message, p.packageName, p.userId ?: -1)
                }
            } else {
                Log.e("DaemonRepository", "Query 'get_logs' received unexpected response type '${message?.type}'")
                null
            }
        }
    }

    fun getStatsStream(): Flow<MetricsRecord> = tcpClient.incomingMessages
        .mapNotNull { jsonLine ->
            try {
                val type = object : TypeToken<CerberusMessage<MetricsRecordPayload>>() {}.type
                val msg = gson.fromJson<CerberusMessage<MetricsRecordPayload>>(jsonLine, type)
                if (msg?.type == "stream.new_stats_record") {
                    msg.payload?.let { mapPayloadToMetricsRecord(it) } // [æ ¸å¿ƒä¿®æ”¹]
                } else null
            } catch (e: Exception) {
                Log.w("DaemonRepository", "Failed to parse MetricsRecordPayload: ${e.message}")
                null
            }
        }

    suspend fun getHistoryStats(): List<MetricsRecord>? = query("query.get_history_stats", EmptyPayload) { responseJson ->
        val type = object : TypeToken<CerberusMessage<List<MetricsRecordPayload>>>() {}.type
        val message = gson.fromJson<CerberusMessage<List<MetricsRecordPayload>>>(responseJson, type)
        if (message?.type == "resp.history_stats") {
            message.payload.map { mapPayloadToMetricsRecord(it) } // [æ ¸å¿ƒä¿®æ”¹]
        } else {
            null
        }
    }

    private suspend fun <ReqT, RespT> query(
        queryType: String,
        payload: ReqT,
        responseParser: (String) -> RespT?
    ): RespT? {
        val reqId = UUID.randomUUID().toString()
        val deferred = CompletableDeferred<String>()
        pendingRequests[reqId] = deferred
        val requestMsg = CerberusMessage(type = queryType, requestId = reqId, payload = payload)
        tcpClient.sendMessage(gson.toJson(requestMsg))
        return try {
            withTimeout(5000) { deferred.await() }.let(responseParser)
        } catch (e: Exception) {
            Log.e("DaemonRepository", "Failed to query '$queryType': ${e.message}")
            pendingRequests.remove(reqId)
            null
        }
    }

    fun setPolicy(config: FullConfigPayload) {
        val message = CerberusMessage(type = "cmd.set_policy", payload = config)
        tcpClient.sendMessage(gson.toJson(message))
    }

    suspend fun getAllPolicies(): FullConfigPayload? {
        return query("query.get_all_policies", EmptyPayload) { responseJson ->
            val type = object : TypeToken<CerberusMessage<FullConfigPayload>>() {}.type
            val message = gson.fromJson<CerberusMessage<FullConfigPayload>>(responseJson, type)
            if (message?.type == "resp.all_policies") message.payload else null
        }
    }

    fun requestDashboardRefresh() {
        val message = CerberusMessage(type = "query.refresh_dashboard", payload = EmptyPayload)
        tcpClient.sendMessage(gson.toJson(message))
    }

    fun stop() {
        tcpClient.stop()
        pendingRequests.values.forEach { it.cancel("Repository is stopping.") }
        pendingRequests.clear()
    }

    fun setMasterConfig(payload: Map<String, Any>) {
        val message = CerberusMessage(type = "cmd.set_master_config", payload = payload)
        tcpClient.sendMessage(gson.toJson(message))
    }

    private data class BaseMessage(val type: String, @SerializedName("req_id") val requestId: String?)
    private object EmptyPayload

    companion object {
        @Volatile private var INSTANCE: DaemonRepository? = null
        fun getInstance(scope: CoroutineScope? = null): DaemonRepository {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: scope?.let {
                    DaemonRepository(it).also { INSTANCE = it }
                } ?: throw IllegalStateException("CoroutineScope must be provided for the first initialization")
            }
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/system/NetworkMonitor.kt
```
// app/src/main/java/com/crfzit/crfzit/data/system/NetworkMonitor.kt
package com.crfzit.crfzit.data.system

import android.net.TrafficStats
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

data class NetworkSpeed(
    val downloadSpeedBps: Long = 0,
    val uploadSpeedBps: Long = 0
)

class NetworkMonitor {

    private var lastTotalRxBytes: Long = 0
    private var lastTotalTxBytes: Long = 0
    private var lastTimestamp: Long = 0

    init {
        // åˆå§‹åŒ–æ—¶è·å–ä¸€æ¬¡åŸºå‡†å€¼
        lastTotalRxBytes = TrafficStats.getTotalRxBytes()
        lastTotalTxBytes = TrafficStats.getTotalTxBytes()
        lastTimestamp = System.currentTimeMillis()
    }

    fun getSpeedStream(): Flow<NetworkSpeed> = flow {
        while (true) {
            val currentRxBytes = TrafficStats.getTotalRxBytes()
            val currentTxBytes = TrafficStats.getTotalTxBytes()
            val currentTimestamp = System.currentTimeMillis()

            val durationMs = currentTimestamp - lastTimestamp
            // ç¡®ä¿æŒç»­æ—¶é—´å¤§äº0ï¼Œä¸”åˆå§‹å€¼æœ‰æ•ˆ
            if (durationMs > 0 && lastTotalRxBytes != TrafficStats.UNSUPPORTED.toLong()) {
                val deltaRx = currentRxBytes - lastTotalRxBytes
                val deltaTx = currentTxBytes - lastTotalTxBytes

                // æ¯ç§’æ¯”ç‰¹æ•° = (å­—èŠ‚å·® * 1000 / æ¯«ç§’å·®) * 8
                val downSpeed = if (deltaRx >= 0) (deltaRx * 1000 / durationMs) * 8 else 0
                val upSpeed = if (deltaTx >= 0) (deltaTx * 1000 / durationMs) * 8 else 0

                emit(NetworkSpeed(downloadSpeedBps = downSpeed, uploadSpeedBps = upSpeed))
            } else {
                 emit(NetworkSpeed(0, 0))
            }

            // æ›´æ–°åŸºå‡†å€¼
            lastTotalRxBytes = currentRxBytes
            lastTotalTxBytes = currentTxBytes
            lastTimestamp = currentTimestamp

            // [FIX] åˆ·æ–°é—´éš”æ”¹ä¸º5ç§’
            delay(5000)
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/data/uds/TcpClient.kt
```
// app/src/main/java/com/crfzit/crfzit/data/uds/TcpClient.kt
package com.crfzit.crfzit.data.uds

import android.util.Log
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import java.io.IOException
import java.io.OutputStream
import java.net.Socket
import java.net.SocketTimeoutException
import java.nio.charset.StandardCharsets

class TcpClient(private val scope: CoroutineScope) {

    private enum class ConnectionState { DISCONNECTED, CONNECTING, CONNECTED }

    @Volatile
    private var socket: Socket? = null
    @Volatile
    private var outputStream: OutputStream? = null

    private var connectionJob: Job? = null

    // [ä¿®æ”¹] å°† incomingMessages çš„ replay ç¼“å­˜å¢åŠ ï¼Œä»¥é˜²UIé‡å»ºæ—¶ä¸¢å¤±å°‘é‡æ•°æ®
    private val _incomingMessages = MutableSharedFlow<String>(replay = 20, extraBufferCapacity = 64)
    val incomingMessages = _incomingMessages.asSharedFlow()

    // [æ–°å¢] æš´éœ²è¿æ¥çŠ¶æ€ç»™å¤–éƒ¨
    private val _isConnected = MutableStateFlow(false)
    val isConnected = _isConnected.asStateFlow()

    companion object {
        private const val TAG = "CerberusTcpClient"
        private const val HOST = "127.0.0.1"
        private const val PORT = 28900
        private const val RECONNECT_DELAY_MS = 3000L
        private const val READ_TIMEOUT_MS = 30_000 // 30ç§’è¯»è¶…æ—¶
    }

    fun start() {
        if (connectionJob?.isActive == true) {
            Log.d(TAG, "TCP client is already running.")
            return
        }
        Log.i(TAG, "TCP client start() called.")

        connectionJob = scope.launch(Dispatchers.IO) {
            // [æ ¸å¿ƒé‡æ„] ä½¿ç”¨æ— é™å¾ªç¯æ¥ç»´æŒè¿æ¥
            while (isActive) {
                var currentState = ConnectionState.DISCONNECTED
                try {
                    // çŠ¶æ€: DISCONNECTED -> CONNECTING
                    currentState = ConnectionState.CONNECTING
                    _isConnected.value = false
                    Log.i(TAG, "Attempting to connect to TCP server: $HOST:$PORT...")
                    
                    val newSocket = Socket(HOST, PORT)
                    newSocket.soTimeout = READ_TIMEOUT_MS // è®¾ç½®è¯»è¶…æ—¶

                    socket = newSocket
                    outputStream = newSocket.outputStream

                    // çŠ¶æ€: CONNECTING -> CONNECTED
                    currentState = ConnectionState.CONNECTED
                    _isConnected.value = true
                    Log.i(TAG, "Successfully connected to daemon via TCP.")

                    // [æ–°å¢] å‘é€ä¸€ä¸ª "hello" æ¶ˆæ¯ï¼Œè®©åç«¯è¯†åˆ«æˆ‘ä»¬æ˜¯UIå®¢æˆ·ç«¯
                    sendMessage("{\"type\":\"hello.ui\"}")

                    listenForMessages()

                } catch (e: Exception) {
                    when (e) {
                        is SocketTimeoutException -> {
                            Log.w(TAG, "Connection timed out (no heartbeat from daemon). Reconnecting...")
                        }
                        is IOException -> {
                            Log.w(TAG, "Connection failed or lost: ${e.message}. Retrying in ${RECONNECT_DELAY_MS}ms...")
                        }
                        else -> {
                            Log.e(TAG, "Unhandled exception in connection loop: ${e.message}", e)
                        }
                    }
                } finally {
                    // ç¡®ä¿æ— è®ºå¦‚ä½•éƒ½æ¸…ç†èµ„æºå¹¶è¿›å…¥é‡è¯•ç­‰å¾…
                    cleanupSocket()
                    _isConnected.value = false
                    if (isActive) {
                        delay(RECONNECT_DELAY_MS)
                    }
                }
            }
        }
    }
    
    fun sendMessage(message: String) {
        // sendMessage é€»è¾‘ä¿æŒä¸å˜ï¼Œä½†ç°åœ¨æ›´å¥å£®ï¼Œå› ä¸ºè¿æ¥å±‚ä¼šè‡ªåŠ¨æ¢å¤
        scope.launch(Dispatchers.IO) {
            val stream = outputStream
            if (stream == null || socket?.isConnected != true) {
                Log.w(TAG, "Cannot send message, socket is not connected.")
                return@launch
            }
            try {
                // åŠ é”ä»¥é˜²æ­¢å¤šçº¿ç¨‹å†™ç«äº‰ï¼Œè™½ç„¶å½“å‰åœºæ™¯ä¸æ˜æ˜¾ï¼Œä½†è¿™æ˜¯ä¸ªå¥½ä¹ æƒ¯
                synchronized(this) {
                    stream.write((message + "\n").toByteArray(StandardCharsets.UTF_8))
                    stream.flush()
                }
                Log.d(TAG, "Sent: $message")
            } catch (e: IOException) {
                Log.e(TAG, "Failed to send message: ${e.message}")
                // è§¦å‘è¿æ¥æ–­å¼€
                cleanupSocket()
            }
        }
    }

    private suspend fun listenForMessages() {
        // è¿™ä¸ªå‡½æ•°ç°åœ¨åªè´Ÿè´£åœ¨å·²è¿æ¥çš„çŠ¶æ€ä¸‹è¯»å–æ•°æ®
        val currentSocket = socket ?: return
        Log.d(TAG, "Starting to listen for messages...")
        currentSocket.getInputStream().bufferedReader(StandardCharsets.UTF_8).use { reader ->
            while (currentSocket.isConnected && scope.isActive) {
                // readLine() ä¼šéµå®ˆ soTimeout è®¾ç½®
                val line = reader.readLine() ?: break // å¦‚æœæµå…³é—­ï¼ŒreadLineè¿”å›null
                if (line.isNotBlank()) {
                     Log.d(TAG, "Rcvd: $line")
                    _incomingMessages.emit(line)
                }
            }
        }
    }

    fun stop() {
        connectionJob?.cancel()
        connectionJob = null
        cleanupSocket()
        Log.i(TAG, "TCP client stopped.")
    }

    private fun cleanupSocket() {
        try { outputStream?.close() } catch (_: IOException) {}
        try { socket?.close() } catch (_: IOException) {}
        socket = null
        outputStream = null
    }
}
```

app/src/main/java/com/crfzit/crfzit/lsp/ProbeHook.kt
```
// app/src/main/java/com/crfzit/crfzit/lsp/ProbeHook.kt
package com.crfzit.crfzit.lsp

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.content.pm.ResolveInfo
import android.os.Process
import com.crfzit.crfzit.data.model.CerberusMessage
import com.google.gson.Gson
import com.google.gson.JsonParser
import de.robv.android.xposed.IXposedHookLoadPackage
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XC_MethodReplacement
import de.robv.android.xposed.XposedBridge
import de.robv.android.xposed.XposedHelpers
import de.robv.android.xposed.callbacks.XC_LoadPackage
import java.io.IOException
import java.io.OutputStreamWriter
import java.net.Socket
import java.nio.charset.StandardCharsets

class ProbeHook : IXposedHookLoadPackage {

    private val gson = Gson()
    @Volatile private var nmsInstance: Any? = null
    @Volatile private var packageManager: PackageManager? = null

    companion object {
        // [æ ¸å¿ƒä¿®æ”¹] æ›´æ–°TAGï¼Œç‰ˆæœ¬å·+1
        private const val TAG = "CerberusProbe_v40_DynamicBqHook"
        const val FLAG_INCLUDE_STOPPED_PACKAGES = 32
        private const val DAEMON_HOST = "127.0.0.1"
        private const val DAEMON_PORT = 28900
        private const val USAGE_EVENT_ACTIVITY_RESUMED = 1
        private const val USAGE_EVENT_ACTIVITY_PAUSED = 2
    }

    private enum class WakeupType(val value: Int) {
        GENERIC_NOTIFICATION(0),
        FCM_PUSH(1),
        PROACTIVE_START(2),
        OTHER(3)
    }

    override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam) {
        if (lpparam.packageName != "android") return
        log("Loading into system_server (PID: ${Process.myPid()}). HookSet active: $TAG")
        sendEventToDaemon("event.probe_hello", mapOf("pid" to Process.myPid(), "version" to TAG))

        try {
            val classLoader = lpparam.classLoader
            // [æ ¸å¿ƒä¿®æ”¹] hookAmsLifecycle çš„èŒè´£æ”¹å˜äº†
            hookAmsLifecycle(classLoader)
            hookNmsConstructor(classLoader)
            hookActivitySwitchEvents(classLoader)
            hookTaskTrimming(classLoader)
            hookSystemFreezer(classLoader)
            hookAnrHelper(classLoader)
            hookWakelocksAndAlarms(classLoader)
            hookActivityStarter(classLoader)
            hookNotificationService(classLoader)
            hookServices(classLoader)
        } catch (t: Throwable) {
            logError("CRITICAL: Failed during hook placement: $t")
        }
    }

    // [æ ¸å¿ƒé‡æ„] hookAmsLifecycle çš„æ–°èŒè´£ï¼šåŠ¨æ€æ‹¦æˆªå¹¿æ’­é˜Ÿåˆ—
    private fun hookAmsLifecycle(classLoader: ClassLoader) {
        try {
            val amsClass = XposedHelpers.findClass("com.android.server.am.ActivityManagerService", classLoader)

            // æ‰¾åˆ° broadcastIntentLocked æˆ–ç±»ä¼¼æ–¹æ³•ä½œä¸ºå…¥å£ç‚¹
            val broadcastIntentMethod = amsClass.declaredMethods.find {
                it.name == "broadcastIntentLocked" || it.name == "broadcastIntent"
            }
            if (broadcastIntentMethod == null) {
                logError("FATAL: Could not find AMS#broadcastIntentLocked method.")
                return
            }

            XposedBridge.hookMethod(broadcastIntentMethod, object : XC_MethodHook() {
                // æˆ‘ä»¬åœ¨æ–¹æ³•æ‰§è¡Œå‰Hookï¼Œç¡®ä¿åªHookä¸€æ¬¡
                override fun beforeHookedMethod(param: MethodHookParam) {
                    if (ConfigManager.isBqHooked) return

                    val amsInstance = param.thisObject
                    val bqFieldNames = listOf("mFgBroadcastQueue", "mBgBroadcastQueue", "mBroadcastQueues")
                    var bqObject: Any? = null

                    // å†æ¬¡å°è¯•æŸ¥æ‰¾å­—æ®µï¼Œå› ä¸ºæ­¤æ—¶å®ƒä»¬å¾ˆå¯èƒ½å·²ç»è¢«åˆå§‹åŒ–äº†
                    for (fieldName in bqFieldNames) {
                        try {
                            val field = XposedHelpers.findFieldIfExists(amsClass, fieldName) ?: continue
                            val value = field.get(amsInstance) ?: continue
                            val candidate = if (value is List<*> && value.isNotEmpty()) value.first() else value
                            if (candidate != null && candidate !is List<*>) {
                                bqObject = candidate
                                log("Found BroadcastQueue object in field on-demand: $fieldName")
                                break
                            }
                        } catch (t: Throwable) { /* ignore */ }
                    }

                    if (bqObject == null) {
                        // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œæ‰“å°ä¸€ä¸ªè­¦å‘Šï¼Œä½†è¿™æ¬¡ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œå› ä¸ºé€šçŸ¥å”¤é†’ä»ç„¶å¯ä»¥å·¥ä½œ
                        logError("WARN: Could not find BroadcastQueue instance on-demand. FCM wakeup might be affected.")
                        // æ ‡è®°ä¸ºå·²å°è¯•ï¼Œé¿å…é‡å¤æ‰§è¡Œ
                        ConfigManager.isBqHooked = true
                        return
                    }

                    val concreteBqClass = bqObject.javaClass
                    log("Dynamically found BroadcastQueue class: ${concreteBqClass.name}")
                    findAndHookBroadcastMethod(concreteBqClass)
                    // æ ‡è®°ä¸ºæˆåŠŸï¼Œè¿™ä¸ªbeforeHookedMethodå°†ä¸å†æ‰§è¡ŒæŸ¥æ‰¾é€»è¾‘
                    ConfigManager.isBqHooked = true
                }
            })
            log("SUCCESS: Placed dynamic hook on AMS#broadcastIntent for on-demand BQ hooking.")
        } catch (t: Throwable) {
            logError("Could not hook AMS lifecycle for dynamic BQ hooking: ${t.message}")
        }
    }

    // findAndHookBroadcastMethod ä¿æŒä¸å˜ï¼Œå®ƒçš„é€»è¾‘æ˜¯æ­£ç¡®çš„
    private fun findAndHookBroadcastMethod(concreteBqClass: Class<*>) {
        val classLoader = concreteBqClass.classLoader ?: run {
            logError("FATAL: ClassLoader for ${concreteBqClass.name} is null!")
            return
        }
        val brClass = findClass("com.android.server.am.BroadcastRecord", classLoader) ?: run {
            logError("FATAL: Could not find BroadcastRecord class!")
            return
        }

        val hook = object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam) {
                try {
                    val record = param.args.firstOrNull { it != null && brClass.isInstance(it) } ?: return
                    val intent = XposedHelpers.getObjectField(record, "intent") as? Intent ?: return

                    if (isGcmOrFcmIntent(intent)) {
                        intent.flags = intent.flags or FLAG_INCLUDE_STOPPED_PACKAGES
                        (XposedHelpers.getObjectField(record, "receivers") as? List<*>)?.forEach { receiver ->
                            try {
                                val uid = (XposedHelpers.getObjectField(receiver, "app") as? Any)?.let { XposedHelpers.getIntField(it, "uid") }
                                    ?: (receiver as? ResolveInfo)?.activityInfo?.applicationInfo?.uid
                                uid?.let { requestWakeupForUid(it, WakeupType.FCM_PUSH) }
                            } catch (ignored: Throwable) {}
                        }
                    }
                } catch (t: Throwable) { logError("Error in BroadcastQueue hook: ${t.message}") }
            }
        }

        // å°è¯•çš„æ–¹æ³•ååˆ—è¡¨ä¿æŒä¸å˜
        val potentialMethodNames = listOf("processNextBroadcast", "processNextBroadcastLocked", "scheduleReceiverLocked", "scheduleReceiverColdLocked")
        var hookedCount = 0
        for (methodName in potentialMethodNames) {
            concreteBqClass.declaredMethods.filter { it.name == methodName }.forEach {
                try {
                    XposedBridge.hookMethod(it, hook)
                    log("SUCCESS: Hooked ${concreteBqClass.simpleName}#${it.name} for robust FCM capture.")
                    hookedCount++
                } catch (t: Throwable) {
                    log("WARN: Failed to hook ${concreteBqClass.simpleName}#${it.name}: ${t.message}")
                }
            }
        }

        if (hookedCount == 0) {
            logError("FATAL: Could not hook any broadcast processing method in ${concreteBqClass.name}.")
        }
    }


    // --- å…¶ä»–æ‰€æœ‰æ–¹æ³•ä¿æŒä¸å˜ ---
    // (æ­¤å¤„çœç•¥äº†æ‰€æœ‰æœªæ”¹åŠ¨çš„å‡½æ•°ï¼Œä»¥ä¿æŒç®€æ´ï¼Œå®é™…ä½¿ç”¨æ—¶è¯·ä¿ç•™å®ƒä»¬)

    private fun hookNmsConstructor(classLoader: ClassLoader) {
        try {
            val nmsClass = XposedHelpers.findClass("com.android.server.notification.NotificationManagerService", classLoader)
            XposedBridge.hookAllConstructors(nmsClass, object : XC_MethodHook() {
                override fun afterHookedMethod(param: MethodHookParam) {
                    if (nmsInstance == null) {
                        nmsInstance = param.thisObject
                        try {
                            val context = XposedHelpers.callMethod(nmsInstance, "getContext") as Context
                            packageManager = context.packageManager
                            log("SUCCESS: Captured NotificationManagerService instance and PackageManager.")
                        } catch (t: Throwable) {
                            logError("Failed to get Context or PackageManager from NMS instance: $t")
                        }
                    }
                }
            })
        } catch (t: Throwable) { logError("Could not hook NMS constructor: ${t.message}") }
    }

    private fun hookNotificationService(classLoader: ClassLoader) {
        val nmsClass = findClass("com.android.server.notification.NotificationManagerService", classLoader) ?: run {
            logError("FATAL: Could not find NotificationManagerService class!")
            return
        }

        val hook = object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam) {
                val pm = packageManager ?: return
                try {
                    val pkg = param.args.firstOrNull { it is String } as? String ?: return
                    val notification = param.args.find { it is Notification } as? Notification ?: return

                    val targetUid: Int
                    try {
                        targetUid = pm.getApplicationInfo(pkg, 0).uid
                    } catch (e: PackageManager.NameNotFoundException) { return }
                    catch (t: Throwable) {
                        logError("Unexpected error while getting UID for package '$pkg': ${t.message}")
                        return
                    }

                    if (ConfigManager.isUidFrozen(targetUid)) {
                        val channel = try {
                            nmsInstance?.let { XposedHelpers.callMethod(it, "getNotificationChannelForPackage", pkg, targetUid, notification.channelId, false) as? NotificationChannel }
                        } catch (t: Throwable) { null }

                        if (channel != null && channel.importance < NotificationManager.IMPORTANCE_DEFAULT) {
                            log("Ignoring low-importance notification for frozen UID $targetUid")
                            return
                        }

                        requestWakeupForUid(targetUid, WakeupType.GENERIC_NOTIFICATION)
                    }
                } catch (t: Throwable) { logError("CRITICAL Error in NMS hook: ${t.javaClass.simpleName} - ${t.message}") }
            }
        }

        var hookCount = 0
        nmsClass.declaredMethods.filter { it.name == "enqueueNotificationInternal" }.forEach {
            try { XposedBridge.hookMethod(it, hook); hookCount++ }
            catch (t: Throwable) { logError("Failed to hook a variant of enqueueNotificationInternal: $t") }
        }

        if (hookCount > 0) log("SUCCESS: Hooked $hookCount NMS#enqueueNotificationInternal methods.")
        else logError("FATAL: No NMS#enqueueNotificationInternal methods were hooked.")
    }

    private fun requestWakeupForUid(uid: Int, type: WakeupType) {
        if (uid >= Process.FIRST_APPLICATION_UID && ConfigManager.isUidFrozen(uid)) {
            val reason = when(type) {
                WakeupType.FCM_PUSH -> "FCM"
                WakeupType.GENERIC_NOTIFICATION -> "Notification"
                else -> "Wakeup"
            }
            log("WAKEUP: Requesting temporary unfreeze for UID $uid, Reason: $reason")
            sendEventToDaemon("event.app_wakeup_request_v2", mapOf("uid" to uid, "type_int" to type.value))
        }
    }

    private fun sendEventToDaemon(type: String, payload: Any) {
        Thread {
            val message = CerberusMessage(type = type, payload = payload)
            val jsonMessage = gson.toJson(message)
            try {
                Socket(DAEMON_HOST, DAEMON_PORT).use { socket ->
                    socket.soTimeout = 2000
                    OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8).use { writer ->
                        writer.write(jsonMessage + "\n"); writer.flush()
                        if (type == "event.probe_hello") {
                            try {
                                socket.getInputStream().bufferedReader(StandardCharsets.UTF_8).readLine()?.let {
                                    ConfigManager.updateConfig(it)
                                }
                            } catch (e: Exception) { logError("Failed to read config response after hello: $e") }
                        }
                    }
                }
            } catch (e: IOException) {
                if (e.message?.contains("ECONNREFUSED") != true) { logError("Daemon short-conn send error for $type: ${e.message}") }
            } catch (e: Exception) { logError("Unexpected error during short-conn send for $type: $e") }
        }.start()
    }

    private object ConfigManager {
        @Volatile var isBqHooked = false
        @Volatile private var frozenUids = emptySet<Int>()
        fun updateConfig(jsonString: String) {
            try {
                val payload = JsonParser.parseString(jsonString).asJsonObject.getAsJsonObject("payload")
                if (payload.has("frozen_uids")) {
                    frozenUids = payload.getAsJsonArray("frozen_uids").map { it.asInt }.toSet()
                }
                if (frozenUids.isNotEmpty()) XposedBridge.log("[$TAG]: Config updated. Tracking ${frozenUids.size} UIDs.")
            } catch (e: Exception) { XposedBridge.log("[$TAG]: [ERROR] Failed to parse probe config: $e") }
        }
        fun isUidFrozen(uid: Int): Boolean = frozenUids.contains(uid)
    }

    private fun log(message: String) = XposedBridge.log("[$TAG] $message")
    private fun logError(message: String) = XposedBridge.log("[$TAG] [ERROR] $message")
    private fun findClass(className: String, classLoader: ClassLoader): Class<*>? = XposedHelpers.findClassIfExists(className, classLoader)
    private fun hookActivitySwitchEvents(classLoader: ClassLoader) {
        findClass("com.android.server.am.ActivityManagerService", classLoader)?.let { clazz ->
            val hook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    try {
                        val componentName = param.args[0] as? ComponentName ?: return
                        val userId = param.args[1] as Int
                        val event = param.args[2] as Int
                        sendEventToDaemon(
                            if (event == USAGE_EVENT_ACTIVITY_RESUMED) "event.app_foreground" else "event.app_background",
                            AppInstanceKey(componentName.packageName, userId)
                        )
                    } catch (t: Throwable) { logError("Error in hookActivitySwitchEvents: ${t.message}") }
                }
            }
            clazz.declaredMethods.find { it.name == "updateActivityUsageStats" && it.parameterCount >= 3 }
                ?.let { XposedBridge.hookMethod(it, hook); log("SUCCESS: Hooked ActivityManagerService#updateActivityUsageStats.") }
                ?: logError("FATAL: Could not find ActivityManagerService#updateActivityUsageStats method!")
        } ?: logError("FATAL: Could not find com.android.server.am.ActivityManagerService class!")
    }
    private fun hookTaskTrimming(classLoader: ClassLoader) {
        findClass("com.android.server.wm.RecentTasks", classLoader)?.let {
            XposedBridge.hookAllMethods(it, "trimInactiveRecentTasks", XC_MethodReplacement.DO_NOTHING)
            log("SUCCESS: Hooked and disabled RecentTasks#trimInactiveRecentTasks.")
        } ?: logError("WARN: Could not find com.android.server.wm.RecentTasks class.")
    }
    private fun hookSystemFreezer(classLoader: ClassLoader) {
        findClass("com.android.server.am.CachedAppOptimizer", classLoader)?.let {
            XposedBridge.hookAllMethods(it, "useFreezer", XC_MethodReplacement.returnConstant(false))
            log("SUCCESS: Hooked and disabled system's CachedAppOptimizer freezer.")
        } ?: log("INFO: Did not find com.android.server.am.CachedAppOptimizer (normal on older Android).")
    }
    private fun hookAnrHelper(classLoader: ClassLoader) {
        findClass("com.android.server.am.AnrHelper", classLoader)?.let { clazz ->
            val anrHook = object: XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val processRecord = param.args.find { it != null && it.javaClass.name.endsWith("ProcessRecord") } ?: return
                    if (ConfigManager.isUidFrozen(XposedHelpers.getIntField(processRecord, "uid"))) {
                        log("PROTECT: Suppressing ANR for frozen UID: ${XposedHelpers.getIntField(processRecord, "uid")}")
                        param.result = null
                    }
                }
            }
            clazz.declaredMethods.filter { it.name.contains("appNotResponding") }.forEach { XposedBridge.hookMethod(it, anrHook) }
            log("SUCCESS: Hooked all ANR methods in AnrHelper.")
        }
    }
    private fun hookWakelocksAndAlarms(classLoader: ClassLoader) {
        findClass("com.android.server.power.PowerManagerService", classLoader)?.let { pmsClass ->
            val wlHook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val uidArg = param.args.find { it is Int && it >= Process.FIRST_APPLICATION_UID } as? Int
                    if (uidArg != null && ConfigManager.isUidFrozen(uidArg)) {
                        log("DEFENSE: Blocked acquireWakeLock for frozen uid: $uidArg")
                        param.result = null
                    }
                }
            }
            pmsClass.declaredMethods.filter { it.name.startsWith("acquireWakeLock") }.forEach { XposedBridge.hookMethod(it, wlHook) }
            log("SUCCESS: Hooked PowerManagerService wakelock acquisition methods.")
        }
        findClass("com.android.server.alarm.AlarmManagerService", classLoader)?.let { amsClass ->
            val alarmHook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    (param.args.firstOrNull { it is ArrayList<*> } as? ArrayList<*>)?.removeIf { alarm ->
                        ConfigManager.isUidFrozen(XposedHelpers.getIntField(alarm!!, "uid")).also {
                            if (it) log("DEFENSE: Blocked alarm for frozen UID: ${XposedHelpers.getIntField(alarm, "uid")}")
                        }
                    }
                }
            }
            amsClass.declaredMethods.filter { it.name.contains("triggerAlarms") }.forEach { XposedBridge.hookMethod(it, alarmHook) }
            log("SUCCESS: Hooked AlarmManagerService alarm trigger methods.")
        }
    }
    private fun hookActivityStarter(classLoader: ClassLoader) {
        findClass("com.android.server.wm.ActivityStarter", classLoader)?.let { clazz ->
            val executeHook = object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    try {
                        val request = param.args.find { it != null && it.javaClass.name == "com.android.server.wm.ActivityStarter\$Request" } ?: return
                        if (XposedHelpers.getIntField(request, "callingUid") >= Process.FIRST_APPLICATION_UID) {
                            (XposedHelpers.getObjectField(request, "intent") as? Intent)?.component?.packageName?.let { pkg ->
                                val userId = XposedHelpers.getIntField(request, "userId")
                                log("PROACTIVE: Activity start for $pkg (user $userId). Requesting unfreeze.")
                                sendEventToDaemon("cmd.proactive_unfreeze", AppInstanceKey(pkg, userId))
                            }
                        }
                    } catch (t: Throwable) { logError("Error in ActivityStarter#execute hook: $t") }
                }
            }
            XposedBridge.hookAllMethods(clazz, "execute", executeHook)
            log("SUCCESS: Hooked ActivityStarter#execute for proactive unfreezing.")
        } ?: logError("FATAL: Could not find ActivityStarter class!")
    }
    private fun hookServices(classLoader: ClassLoader) {
        findClass("com.android.server.am.ActiveServices", classLoader)?.let { clazz ->
            val hook = object: XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val serviceRecord = param.args.find { it != null && it.javaClass.name.endsWith("ServiceRecord") } ?: return
                    val appInfo = XposedHelpers.getObjectField(serviceRecord, "appInfo") as? ApplicationInfo ?: return
                    if (ConfigManager.isUidFrozen(appInfo.uid)) {
                        log("DEFENSE: Blocked service startup for frozen app: ${appInfo.packageName}")
                        param.result = null
                    }
                }
            }
            clazz.declaredMethods.filter { it.name.contains("bringUpService") }.forEach { XposedBridge.hookMethod(it, hook) }
            log("SUCCESS: Hooked ActiveServices service startup methods.")
        }
    }
    private fun isGcmOrFcmIntent(intent: Intent): Boolean {
        return intent.action?.let { it == "com.google.android.c2dm.intent.RECEIVE" || it == "com.google.firebase.MESSAGING_EVENT" } ?: false
    }
    private data class AppInstanceKey(val package_name: String, val user_id: Int)
}
```

app/src/main/java/com/crfzit/crfzit/MainActivity.kt
```
// app/src/main/java/com/crfzit/crfzit/MainActivity.kt
package com.crfzit.crfzit

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import com.crfzit.crfzit.ui.theme.CRFzitTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            CRFzitTheme {
               Surface(
                   modifier = Modifier.fillMaxSize(),
                   color = MaterialTheme.colorScheme.background
               ) {
                   MainScreen()
               }
            }
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/MainScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/MainScreen.kt
package com.crfzit.crfzit

import androidx.compose.foundation.layout.padding
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import com.crfzit.crfzit.navigation.Screen
import com.crfzit.crfzit.ui.configuration.ConfigurationScreen
import com.crfzit.crfzit.ui.configuration.ConfigurationViewModel
import com.crfzit.crfzit.ui.dashboard.DashboardScreen
import com.crfzit.crfzit.ui.dashboard.DashboardViewModel
import com.crfzit.crfzit.ui.logs.LogsScreen
import com.crfzit.crfzit.ui.settings.SettingsScreen
import com.crfzit.crfzit.ui.settings.SettingsViewModel

@Composable
fun MainScreen() {
    val navController = rememberNavController()
    val screens = listOf(
        Screen.Dashboard,
        Screen.Configuration,
        Screen.Logs,
        Screen.Settings
    )

    Scaffold(
        bottomBar = {
            NavigationBar {
                val navBackStackEntry by navController.currentBackStackEntryAsState()
                val currentDestination = navBackStackEntry?.destination

                screens.forEach { screen ->
                    NavigationBarItem(
                        icon = { Icon(screen.icon, contentDescription = screen.label) },
                        label = { Text(screen.label) },
                        selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,
                        onClick = {
                            navController.navigate(screen.route) {
                                popUpTo(navController.graph.findStartDestination().id) {
                                    saveState = true
                                }
                                launchSingleTop = true
                                restoreState = true
                            }
                        }
                    )
                }
            }
        }
    ) { innerPadding ->
        NavHost(
            navController = navController,
            startDestination = Screen.Dashboard.route,
            modifier = Modifier.padding(innerPadding)
        ) {
            composable(Screen.Dashboard.route) {
                // ViewModel åœ¨æ­¤çº§åˆ«åˆ›å»ºï¼Œå¯ä»¥å®ç°è·¨å±å¹•å…±äº«
                val dashboardViewModel: DashboardViewModel = viewModel()
                DashboardScreen(viewModel = dashboardViewModel)
            }
            composable(Screen.Configuration.route) {
                val configViewModel: ConfigurationViewModel = viewModel()
                ConfigurationScreen(navController = navController, viewModel = configViewModel)
            }
            composable(Screen.Logs.route) { LogsScreen() }
            composable(Screen.Settings.route) { 
                val settingsViewModel: SettingsViewModel = viewModel()
                SettingsScreen(viewModel = settingsViewModel)
             }
            // composable(Screen.ProfileManagement.route) { ... } // æœªæ¥å®ç°
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/navigation/Screen.kt
```
// app/src/main/java/com/crfzit/crfzit/navigation/Screen.kt
package com.crfzit.crfzit.navigation

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Settings
import androidx.compose.ui.graphics.vector.ImageVector
import com.crfzit.crfzit.ui.icons.AppIcons

sealed class Screen(val route: String, val label: String, val icon: ImageVector) {
    data object Dashboard : Screen("dashboard", "ä¸»é¡µ", AppIcons.Dashboard)
    data object Configuration : Screen("configuration", "é…ç½®", AppIcons.Tune)
    data object Logs : Screen("logs", "æ—¥å¿—", AppIcons.ListAlt)
    data object Settings : Screen("settings", "è®¾ç½®", Icons.Default.Settings)
    // [FIX] Correctly refer to the icon defined in AppIcons
    data object ProfileManagement : Screen("profile_management", "æƒ…æ™¯æ¨¡å¼", AppIcons.Style)
}
```

app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationScreen.kt
package com.crfzit.crfzit.ui.configuration

import android.graphics.Bitmap
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import com.crfzit.crfzit.R
import com.crfzit.crfzit.coil.AppIcon
import com.crfzit.crfzit.data.model.AppInfo
import com.crfzit.crfzit.data.model.AppInstanceKey
import com.crfzit.crfzit.data.model.AppPolicyPayload

enum class Policy(val value: Int, val displayName: String) {
    EXEMPTED(0, "è±å…"),
    STANDARD(2, "æ™ºèƒ½"),
    STRICT(3, "ä¸¥æ ¼");

    companion object {
        fun fromInt(value: Int) = entries.find { it.value == value } ?: EXEMPTED
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ConfigurationScreen(
    navController: NavController,
    viewModel: ConfigurationViewModel
) {
    val uiState by viewModel.uiState.collectAsState()

    val filteredApps = remember(uiState.searchQuery, uiState.showSystemApps, uiState.policies) {
        viewModel.getFilteredAndSortedApps()
    }

    Scaffold(
        topBar = { TopAppBar(title = { Text("åº”ç”¨é…ç½®") }) }
    ) { padding ->
        Column(Modifier.padding(padding)) {
            OutlinedTextField(
                value = uiState.searchQuery,
                onValueChange = viewModel::onSearchQueryChanged,
                modifier = Modifier.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp),
                label = { Text("æœç´¢åº”ç”¨æˆ–åŒ…å") },
                leadingIcon = { Icon(Icons.Default.Search, null) },
                singleLine = true
            )

            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
                    .clickable { viewModel.onShowSystemAppsChanged(!uiState.showSystemApps) },
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text("æ˜¾ç¤ºç³»ç»Ÿåº”ç”¨", modifier = Modifier.weight(1f))
                Switch(
                    checked = uiState.showSystemApps,
                    onCheckedChange = viewModel::onShowSystemAppsChanged
                )
            }

            if (uiState.isLoading) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                }
            } else {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(filteredApps, key = { "${it.packageName}-${it.userId}" }) { appInfo ->
                        val key = AppInstanceKey(appInfo.packageName, appInfo.userId)
                        val policyPayload = uiState.policies[key]
                            ?: AppPolicyPayload(appInfo.packageName, appInfo.userId, Policy.EXEMPTED.value)

                        AppPolicyItem(
                            appInfo = appInfo,
                            policy = Policy.fromInt(policyPayload.policy),
                            onPolicyChange = { newPolicy ->
                                viewModel.setAppPolicy(appInfo.packageName, appInfo.userId, newPolicy.value)
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun AppPolicyItem(
    appInfo: AppInfo,
    policy: Policy,
    onPolicyChange: (Policy) -> Unit
) {
    var showMenu by remember { mutableStateOf(false) }
    val itemAlpha = if (policy == Policy.EXEMPTED) 0.7f else 1.0f

    Card(modifier = Modifier.fillMaxWidth().alpha(itemAlpha)) {
        Row(
            modifier = Modifier
                .padding(16.dp)
                .clickable { showMenu = true },
            verticalAlignment = Alignment.CenterVertically
        ) {
            Image(
                // [å†…å­˜ä¼˜åŒ–] ä¸DashboardScreenåŒæ ·çš„æ ¸å¿ƒæ”¹åŠ¨ï¼Œä½¿ç”¨CoilæŒ‰éœ€åŠ è½½
                painter = rememberAsyncImagePainter(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(AppIcon(appInfo.packageName))
                        .size(73)
                        .bitmapConfig(Bitmap.Config.RGB_565)
                        .placeholder(R.drawable.ic_launcher_foreground)
                        .error(R.drawable.ic_launcher_foreground)
                        .build()
                ),
                contentDescription = appInfo.appName,
                modifier = Modifier.size(40.dp)
            )
            Column(Modifier.weight(1f).padding(start = 16.dp)) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(appInfo.appName, fontWeight = FontWeight.Bold)
                    if (appInfo.userId != 0) {
                        Spacer(Modifier.width(4.dp))
                        Icon(
                            painter = painterResource(id = R.drawable.ic_clone),
                            contentDescription = "åˆ†èº«åº”ç”¨ (User ${appInfo.userId})",
                            modifier = Modifier.size(16.dp),
                            tint = MaterialTheme.colorScheme.secondary
                        )
                    }
                }
                Text(appInfo.packageName, style = MaterialTheme.typography.bodySmall)
            }

            Box {
                val (label, icon) = getPolicyLabelAndIcon(policy)
                Text(
                    text = "$icon $label",
                    color = if (policy == Policy.EXEMPTED) MaterialTheme.colorScheme.onSurfaceVariant else MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )

                DropdownMenu(
                    expanded = showMenu,
                    onDismissRequest = { showMenu = false }
                ) {
                    listOf(Policy.EXEMPTED, Policy.STANDARD, Policy.STRICT).forEach { p ->
                        DropdownMenuItem(
                            text = {
                                val (policyLabel, policyIcon) = getPolicyLabelAndIcon(p)
                                Text("$policyIcon $policyLabel")
                            },
                            onClick = {
                                onPolicyChange(p)
                                showMenu = false
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun getPolicyLabelAndIcon(policy: Policy): Pair<String, String> {
    return when (policy) {
        Policy.EXEMPTED -> policy.displayName to "ğŸ›¡ï¸"
        Policy.STANDARD -> policy.displayName to "âš™ï¸"
        Policy.STRICT -> policy.displayName to "ğŸ§Š"
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/configuration/ConfigurationViewModel.kt
package com.crfzit.crfzit.ui.configuration

import android.app.Application
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.*
import com.crfzit.crfzit.data.repository.AppInfoRepository
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

data class ConfigurationUiState(
    val isLoading: Boolean = true,
    // [å†…å­˜ä¼˜åŒ–] allInstalledApps åˆ—è¡¨ç°åœ¨éå¸¸è½»é‡ï¼Œå› ä¸ºå®ƒä¸åŒ…å«å›¾æ ‡
    val allInstalledApps: List<AppInfo> = emptyList(),
    val policies: Map<AppInstanceKey, AppPolicyPayload> = emptyMap(),
    val fullConfig: FullConfigPayload? = null,
    val searchQuery: String = "",
    val showSystemApps: Boolean = false
)

class ConfigurationViewModel(application: Application) : AndroidViewModel(application) {

    private val daemonRepository = DaemonRepository.getInstance()
    private val appInfoRepository = AppInfoRepository.getInstance(application)
    private val packageManager: PackageManager = application.packageManager

    private val _uiState = MutableStateFlow(ConfigurationUiState())
    val uiState: StateFlow<ConfigurationUiState> = _uiState.asStateFlow()

    init {
        loadConfiguration()
    }

    fun getFilteredAndSortedApps(): List<AppInfo> {
        val state = _uiState.value
        return state.allInstalledApps
            .filter { appInfo ->
                (state.showSystemApps || !appInfo.isSystemApp) &&
                        (appInfo.appName.contains(state.searchQuery, ignoreCase = true) ||
                                appInfo.packageName.contains(state.searchQuery, ignoreCase = true))
            }
            .sortedWith(
                compareByDescending<AppInfo> {
                    val key = AppInstanceKey(it.packageName, it.userId)
                    state.policies[key]?.policy ?: 0
                }.thenBy { it.appName.lowercase() }
            )
    }

    fun loadConfiguration() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }

            // [å†…å­˜ä¼˜åŒ–] è¿™ä¸¤ä¸ªè°ƒç”¨ç°åœ¨éƒ½éå¸¸å¿«ä¸”å†…å­˜å ç”¨ä½
            val launchableApps = getAllLaunchableApps()
            val configPayload = daemonRepository.getAllPolicies()
            val daemonPolicyMap = configPayload?.policies?.associateBy {
                AppInstanceKey(it.packageName, it.userId)
            } ?: emptyMap()

            val finalAppMap = launchableApps.associateBy {
                AppInstanceKey(it.packageName, it.userId)
            }.toMutableMap()

            daemonPolicyMap.values.forEach { policy ->
                val key = AppInstanceKey(policy.packageName, policy.userId)
                if (!finalAppMap.containsKey(key) && policy.userId != 0) {
                    val baseAppInfo = appInfoRepository.getAppInfo(policy.packageName)
                    finalAppMap[key] = AppInfo(
                        packageName = policy.packageName,
                        appName = baseAppInfo?.appName ?: policy.packageName,
                        // [å†…å­˜ä¼˜åŒ–] ä¸å†åŠ è½½å’Œå­˜å‚¨Drawableå¯¹è±¡
                        isSystemApp = baseAppInfo?.isSystemApp ?: false,
                        userId = policy.userId
                    )
                }
            }

            _uiState.update {
                it.copy(
                    isLoading = false,
                    allInstalledApps = finalAppMap.values.toList(),
                    policies = daemonPolicyMap,
                    fullConfig = configPayload
                )
            }
        }
    }

    private suspend fun getAllLaunchableApps(): List<AppInfo> = withContext(Dispatchers.IO) {
        val intent = Intent(Intent.ACTION_MAIN, null).apply {
            addCategory(Intent.CATEGORY_LAUNCHER)
        }
        packageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL)
            .mapNotNull { resolveInfo ->
                try {
                    val appInfo: ApplicationInfo = resolveInfo.activityInfo.applicationInfo
                    AppInfo(
                        packageName = appInfo.packageName,
                        appName = appInfo.loadLabel(packageManager).toString(),
                        isSystemApp = (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0,
                        userId = 0
                    )
                } catch (e: Exception) {
                    null
                }
            }
    }

    fun setAppPolicy(packageName: String, userId: Int, newPolicyValue: Int) {
        val currentConfig = _uiState.value.fullConfig ?: return

        val newPolicies = currentConfig.policies.toMutableList()
        val existingPolicyIndex = newPolicies.indexOfFirst { it.packageName == packageName && it.userId == userId }

        if (existingPolicyIndex != -1) {
            newPolicies[existingPolicyIndex] = newPolicies[existingPolicyIndex].copy(policy = newPolicyValue)
        } else {
            newPolicies.add(AppPolicyPayload(packageName, userId, newPolicyValue))
        }

        val newConfig = currentConfig.copy(policies = newPolicies)
        _uiState.update {
            it.copy(
                policies = newPolicies.associateBy { p -> AppInstanceKey(p.packageName, p.userId) },
                fullConfig = newConfig
            )
        }
        daemonRepository.setPolicy(newConfig)
    }

    fun onSearchQueryChanged(query: String) {
        _uiState.update { it.copy(searchQuery = query) }
    }

    fun onShowSystemAppsChanged(show: Boolean) {
        _uiState.update { it.copy(showSystemApps = show) }
    }

    override fun onCleared() {
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardScreen.kt
package com.crfzit.crfzit.ui.dashboard

import android.graphics.Bitmap
import androidx.compose.animation.Crossfade
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import coil.compose.rememberAsyncImagePainter
import coil.request.ImageRequest
import com.crfzit.crfzit.R
import com.crfzit.crfzit.coil.AppIcon
import com.crfzit.crfzit.data.model.AppRuntimeState
import com.crfzit.crfzit.data.model.GlobalStats
import com.crfzit.crfzit.data.system.NetworkSpeed
import com.crfzit.crfzit.ui.icons.AppIcons
import com.crfzit.crfzit.ui.theme.CRFzitTheme
import com.google.accompanist.swiperefresh.SwipeRefresh
import com.google.accompanist.swiperefresh.rememberSwipeRefreshState
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardScreen(viewModel: DashboardViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    var showMenu by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("ä¸»é¡µ") },
                actions = {
                    IconButton(onClick = { showMenu = true }) {
                        Icon(Icons.Default.MoreVert, contentDescription = "æ›´å¤š")
                    }
                    DropdownMenu(
                        expanded = showMenu,
                        onDismissRequest = { showMenu = false }
                    ) {
                        DropdownMenuItem(
                            text = { Text(if (uiState.showSystemApps) "éšè—ç³»ç»Ÿåº”ç”¨" else "æ˜¾ç¤ºç³»ç»Ÿåº”ç”¨") },
                            onClick = {
                                viewModel.onShowSystemAppsChanged(!uiState.showSystemApps)
                                showMenu = false
                            }
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        Crossfade(
            targetState = uiState.isConnected,
            modifier = Modifier.padding(paddingValues),
            label = "ConnectionState"
        ) { isConnected ->
            if (isConnected) {
                SwipeRefresh(
                    state = rememberSwipeRefreshState(isRefreshing = uiState.isRefreshing),
                    onRefresh = { viewModel.refresh() }
                ) {
                    DashboardContent(
                        globalStats = uiState.globalStats,
                        networkSpeed = uiState.networkSpeed,
                        apps = uiState.apps
                    )
                }
            } else {
                ConnectionLoadingIndicator()
            }
        }
    }
}


@Composable
fun DashboardContent(
    globalStats: GlobalStats,
    networkSpeed: NetworkSpeed,
    apps: List<UiAppRuntime>
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        item {
            GlobalStatusArea(stats = globalStats, speed = networkSpeed)
        }
        item {
            Text(
                text = "è¿è¡ŒçŠ¶æ€åˆ—è¡¨",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(top = 8.dp, bottom = 4.dp)
            )
        }
        items(apps, key = { "${it.runtimeState.packageName}-${it.runtimeState.userId}" }) { app ->
            AppRuntimeCard(app = app)
        }
    }
}

@Composable
fun AppRuntimeCard(app: UiAppRuntime) {
    val state = app.runtimeState
    Card {
        Row(
            modifier = Modifier.padding(12.dp).fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Image(
                // [å†…å­˜ä¼˜åŒ–] è¿™é‡Œæ˜¯æ ¸å¿ƒæ”¹åŠ¨ã€‚æˆ‘ä»¬ä¸å†ç›´æ¥ä½¿ç”¨Drawableï¼Œ
                // è€Œæ˜¯è®©Coilé€šè¿‡æˆ‘ä»¬è‡ªå®šä¹‰çš„AppIconæ•°æ®ç±»å’ŒFetcheræ¥åŠ è½½å›¾æ ‡ã€‚
                // è¿™å®ç°äº†æŒ‰éœ€åŠ è½½ã€ç¼“å­˜ã€åˆ†è¾¨ç‡å’Œè‰²æ·±æ§åˆ¶ç­‰æ‰€æœ‰ä¼˜åŒ–ã€‚
                painter = rememberAsyncImagePainter(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(AppIcon(state.packageName)) // ä½¿ç”¨è‡ªå®šä¹‰æ•°æ®ç±»ä½œä¸ºè¯·æ±‚æ¨¡å‹
                        .size(73) // é™åˆ¶å›¾ç‰‡åŠ è½½çš„æœ€å¤§å°ºå¯¸ä¸º73x73åƒç´ 
                        .bitmapConfig(Bitmap.Config.RGB_565)
                        .placeholder(R.drawable.ic_launcher_foreground) // ä½¿ç”¨ä¸€ä¸ªè½»é‡çº§å ä½ç¬¦
                        .error(R.drawable.ic_launcher_foreground)
                        .build()
                ),
                contentDescription = app.appName,
                modifier = Modifier.size(48.dp)
            )
            
            Column(
                modifier = Modifier.weight(1f).padding(horizontal = 12.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(
                        text = app.appName,
                        fontWeight = FontWeight.Bold,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis,
                        modifier = Modifier.weight(1f, fill = false)
                    )
                    if (app.userId != 0) {
                        Spacer(Modifier.width(4.dp))
                        Icon(
                            painter = painterResource(id = R.drawable.ic_clone),
                            contentDescription = "åˆ†èº«åº”ç”¨ (User ${app.userId})",
                            modifier = Modifier.size(16.dp),
                            tint = MaterialTheme.colorScheme.secondary
                        )
                    }
                    Spacer(Modifier.weight(1f))
                    AppStatusIcons(state = state)
                }
                
                val resourceText = buildAnnotatedString {
                    append("MEM: ${formatMemory(state.memUsageKb)}")
                    if (state.swapUsageKb > 1024) {
                        withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f))) {
                            append(" (+${formatMemory(state.swapUsageKb)} S)")
                        }
                    }
                    append(" | CPU: ${"%.1f".format(state.cpuUsagePercent)}%")
                }

                Text(
                    text = resourceText,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                Text(
                    text = "çŠ¶æ€ï¼š${formatStatus(state)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
fun GlobalStatusArea(stats: GlobalStats, speed: NetworkSpeed) {
    val memUsedPercent = if (stats.totalMemKb > 0) {
        (stats.totalMemKb - stats.availMemKb).toFloat() / stats.totalMemKb
    } else 0f
    
    val swapUsedPercent = if (stats.swapTotalKb > 0) {
        (stats.swapTotalKb - stats.swapFreeKb).toFloat() / stats.swapTotalKb
    } else 0f
    
    val cpuUsedPercent = stats.totalCpuUsagePercent / 100f
    
    val downSpeed = formatSpeed(speed.downloadSpeedBps)
    val upSpeed = formatSpeed(speed.uploadSpeedBps)

    Column(modifier = Modifier.padding(bottom = 8.dp)) {
        Text(
            text = "ç³»ç»ŸçŠ¶æ€",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold,
            modifier = Modifier
                .align(Alignment.CenterHorizontally)
                .padding(bottom = 12.dp)
        )
        
        LazyVerticalGrid(
            columns = GridCells.Fixed(2),
            modifier = Modifier.height(180.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            userScrollEnabled = false
        ) {
            item {
                StatusGridItem(
                    label = "CPU",
                    value = "%.1f".format(Locale.US, stats.totalCpuUsagePercent) + "%",
                    progress = cpuUsedPercent,
                    icon = AppIcons.Memory
                )
            }
            item {
                StatusGridItem(
                    label = "å†…å­˜ (MEM)",
                    value = formatMemory(stats.totalMemKb - stats.availMemKb),
                    progress = memUsedPercent,
                    icon = AppIcons.SdStorage
                )
            }
            item {
                 StatusGridItem(
                    label = "äº¤æ¢ (SWAP)",
                    value = formatMemory(stats.swapTotalKb - stats.swapFreeKb),
                    progress = swapUsedPercent,
                    icon = AppIcons.SwapHoriz
                )
            }
            item {
                StatusGridItem(
                    label = "ç½‘ç»œ",
                    value = "â†“${downSpeed.first} | â†‘${upSpeed.first}",
                    subValue = "${downSpeed.second} / ${upSpeed.second}",
                    icon = AppIcons.Wifi
                )
            }
        }
    }
}

@Composable
fun StatusGridItem(
    label: String,
    value: String,
    subValue: String? = null,
    progress: Float? = null,
    icon: ImageVector
) {
    Card(
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant),
        shape = MaterialTheme.shapes.large
    ) {
        Column(Modifier.padding(12.dp).fillMaxSize()) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(icon, contentDescription = label, modifier = Modifier.size(18.dp))
                Spacer(Modifier.width(8.dp))
                Text(label, style = MaterialTheme.typography.labelLarge)
            }
            Spacer(Modifier.weight(1f))
            if (subValue != null) {
                 Text(value, style = MaterialTheme.typography.titleMedium)
                 Text(subValue, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurfaceVariant)
            } else {
                Text(value, style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.SemiBold)
            }
            if (progress != null) {
                Spacer(Modifier.height(4.dp))
                LinearProgressIndicator(
                    progress = { progress ?: 0f },
                    modifier = Modifier.fillMaxWidth().height(6.dp).clip(CircleShape)
                )
            }
        }
    }
}

@Composable
fun AppStatusIcons(state: AppRuntimeState) {
    Row {
        val iconModifier = Modifier.padding(horizontal = 2.dp)
        if (state.isForeground) Text("â–¶ï¸", iconModifier)
        if (state.isWhitelisted) Text("ğŸ›¡ï¸", iconModifier)
        if (state.displayStatus.uppercase() == "FROZEN") {
            Text("â„ï¸", iconModifier)
        }
    }
}

@Composable
fun ConnectionLoadingIndicator() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            CircularProgressIndicator()
            Spacer(Modifier.height(16.dp))
            Text("æ­£åœ¨è¿æ¥åˆ°å®ˆæŠ¤è¿›ç¨‹...")
        }
    }
}

private fun formatMemory(kb: Long): String {
    if (kb <= 0) return "0 KB"
    val mb = kb / 1024.0
    val gb = mb / 1024.0
    return when {
        gb >= 1 -> "%.1f GB".format(Locale.US, gb)
        mb >= 1 -> "%.1f MB".format(Locale.US, mb)
        else -> "$kb KB"
    }
}

private fun formatSpeed(bitsPerSecond: Long): Pair<String, String> {
    if (bitsPerSecond < 50000) return Pair("0.0", "Kbps")
    return when {
        bitsPerSecond < 1_000_000 -> Pair("%.1f".format(Locale.US, bitsPerSecond / 1000.0), "Kbps")
        else -> Pair("%.1f".format(Locale.US, bitsPerSecond / 1_000_000.0), "Mbps")
    }
}

private fun formatStatus(state: AppRuntimeState): String {
    val status = state.displayStatus.uppercase()
    return when {
        status.startsWith("PENDING_FREEZE") -> {
            val time = status.substringAfter("(").substringBefore("s")
            "ç­‰å¾…å†»ç»“ (${time}s)"
        }
        status.startsWith("OBSERVING") -> {
            val time = status.substringAfter("(").substringBefore("s")
            "åå°è§‚å¯Ÿä¸­ (${time}s)"
        }
        status == "STOPPED" -> "æœªè¿è¡Œ"
        status == "FROZEN" -> "å·²å†»ç»“"
        status == "FOREGROUND" -> "å‰å°è¿è¡Œ"
        status == "EXEMPTED_BACKGROUND" -> "åå°è¿è¡Œ (å·²è±å…)"
        status == "BACKGROUND" -> "åå°è¿è¡Œ"
        else -> state.displayStatus
    }
}

@Preview(showBackground = true)
@Composable
fun DashboardPreview() {
    CRFzitTheme {
        DashboardContent(
            globalStats = GlobalStats(),
            networkSpeed = NetworkSpeed(),
            apps = emptyList()
        )
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/dashboard/DashboardViewModel.kt
package com.crfzit.crfzit.ui.dashboard

import android.app.Application
// [å†…å­˜ä¼˜åŒ–] ä¸å†éœ€è¦Drawable
// import android.graphics.drawable.Drawable
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.AppRuntimeState
import com.crfzit.crfzit.data.model.GlobalStats
import com.crfzit.crfzit.data.repository.AppInfoRepository
import com.crfzit.crfzit.data.repository.DaemonRepository
import com.crfzit.crfzit.data.system.NetworkMonitor
import com.crfzit.crfzit.data.system.NetworkSpeed
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class UiAppRuntime(
    val runtimeState: AppRuntimeState,
    val appName: String,
    // [å†…å­˜ä¼˜åŒ–] ç§»é™¤ icon å­—æ®µ
    // val icon: Drawable?,
    val isSystem: Boolean,
    val userId: Int
)

data class DashboardUiState(
    val isConnected: Boolean = false,
    val isRefreshing: Boolean = false,
    val globalStats: GlobalStats = GlobalStats(),
    val networkSpeed: NetworkSpeed = NetworkSpeed(),
    val apps: List<UiAppRuntime> = emptyList(),
    val showSystemApps: Boolean = false
)

class DashboardViewModel(application: Application) : AndroidViewModel(application) {

    private val daemonRepository = DaemonRepository.getInstance()
    private val appInfoRepository = AppInfoRepository.getInstance(application)
    private val networkMonitor = NetworkMonitor()

    private val _uiState = MutableStateFlow(DashboardUiState())
    val uiState: StateFlow<DashboardUiState> = _uiState.asStateFlow()

    init {
        viewModelScope.launch {
            // é¢„çƒ­åº”ç”¨ä¿¡æ¯ç¼“å­˜ï¼Œä½†ä¸åŠ è½½å›¾æ ‡
            appInfoRepository.getAllApps(forceRefresh = true)

            combine(
                daemonRepository.getDashboardStream(),
                networkMonitor.getSpeedStream(),
                _uiState.map { it.showSystemApps }.distinctUntilChanged()
            ) { dashboardPayload, speed, showSystem ->
                
                val uiAppRuntimes = dashboardPayload.appsRuntimeState
                    .mapNotNull { runtimeState ->
                        // appInfoRepository ç°åœ¨è¿”å›ä¸å«å›¾æ ‡çš„è½»é‡çº§å¯¹è±¡
                        val appInfo = appInfoRepository.getAppInfo(runtimeState.packageName)
                        appInfo?.let {
                            UiAppRuntime(
                                runtimeState = runtimeState,
                                appName = it.appName,
                                // [å†…å­˜ä¼˜åŒ–] ä¸å†ä¼ é€’ icon
                                // icon = it.icon,
                                isSystem = it.isSystemApp,
                                userId = runtimeState.userId
                            )
                        }
                    }
                    .filter { showSystem || !it.isSystem }
                    .sortedWith(
                        compareBy<UiAppRuntime> { !it.runtimeState.isForeground }
                            .thenByDescending { it.runtimeState.memUsageKb }
                    )

                _uiState.value.copy(
                    isConnected = true,
                    isRefreshing = false,
                    globalStats = dashboardPayload.globalStats,
                    networkSpeed = speed,
                    apps = uiAppRuntimes,
                    showSystemApps = showSystem
                )
            }
                .onStart { _uiState.update { it.copy(isConnected = false) } }
                .catch { emit(_uiState.value.copy(isConnected = false)) }
                .collect { newState ->
                    _uiState.value = newState
                }
        }
    }

    fun refresh() {
        viewModelScope.launch {
            _uiState.update { it.copy(isRefreshing = true) }
            daemonRepository.requestDashboardRefresh()
        }
    }

    fun onShowSystemAppsChanged(show: Boolean) {
        _uiState.update { it.copy(showSystemApps = show) }
    }

    override fun onCleared() {
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/icons/AppIcons.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/icons/AppIcons.kt
package com.crfzit.crfzit.ui.icons

import androidx.compose.material.icons.materialIcon
import androidx.compose.material.icons.materialPath
import androidx.compose.ui.graphics.vector.ImageVector

/**
 * å•ä¾‹å¯¹è±¡ï¼Œç”¨äºå­˜æ”¾æ‰€æœ‰æ‰‹åŠ¨æå–çš„ Material Design å›¾æ ‡ã€‚
 * è¿™æ ·åšå¯ä»¥é¿å…å¯¹ material-icons-extended åº“çš„ä¾èµ–ï¼Œç¡®ä¿ç¼–è¯‘ç¨³å®šæ€§å’ŒUIä¸€è‡´æ€§ã€‚
 */
object AppIcons {

    val Dashboard: ImageVector by lazy { materialIcon("Filled.Dashboard") {
        materialPath {
            moveTo(3.0f, 13.0f); horizontalLineToRelative(8.0f); lineTo(11.0f, 3.0f); lineTo(3.0f, 3.0f); verticalLineToRelative(10.0f); close()
            moveTo(3.0f, 21.0f); horizontalLineToRelative(8.0f); verticalLineToRelative(-6.0f); lineTo(3.0f, 15.0f); verticalLineToRelative(6.0f); close()
            moveTo(13.0f, 21.0f); horizontalLineToRelative(8.0f); lineTo(21.0f, 11.0f); horizontalLineToRelative(-8.0f); verticalLineToRelative(10.0f); close()
            moveTo(13.0f, 3.0f); verticalLineToRelative(6.0f); horizontalLineToRelative(8.0f); lineTo(21.0f, 3.0f); horizontalLineToRelative(-8.0f); close()
        }
    } }

    val Tune: ImageVector by lazy { materialIcon("Filled.Tune") {
        materialPath {
            moveTo(3.0f, 17.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(6.0f); verticalLineToRelative(-2.0f); lineTo(3.0f, 17.0f); close()
            moveTo(3.0f, 5.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(10.0f); lineTo(13.0f, 5.0f); lineTo(3.0f, 5.0f); close()
            moveTo(13.0f, 21.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(8.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(-8.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(-2.0f); verticalLineToRelative(6.0f); horizontalLineToRelative(2.0f); close()
            moveTo(7.0f, 9.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(-4.0f); lineTo(3.0f, 9.0f); lineTo(7.0f, 9.0f); close()
            moveTo(21.0f, 13.0f); verticalLineToRelative(-2.0f); lineTo(11.0f, 11.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(10.0f); close()
            moveTo(15.0f, 9.0f); horizontalLineToRelative(6.0f); lineTo(21.0f, 7.0f); horizontalLineToRelative(-6.0f); verticalLineToRelative(2.0f); close()
        }
    } }

    val ListAlt: ImageVector by lazy { materialIcon("AutoMirrored.Filled.ListAlt") {
        materialPath {
            moveTo(19.0f, 5.0f); verticalLineTo(3.0f); horizontalLineTo(5.0f); curveTo(3.9f, 3.0f, 3.0f, 3.9f, 3.0f, 5.0f); verticalLineToRelative(14.0f); curveToRelative(0.0f, 1.1f, 0.9f, 2.0f, 2.0f, 2.0f); horizontalLineToRelative(14.0f); curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f); verticalLineTo(5.0f); horizontalLineTo(19.0f); close()
            moveTo(11.0f, 17.0f); horizontalLineTo(7.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(11.0f, 13.0f); horizontalLineTo(7.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(11.0f, 9.0f); horizontalLineTo(7.0f); verticalLineTo(7.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(17.0f, 17.0f); horizontalLineToRelative(-4.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(17.0f, 13.0f); horizontalLineToRelative(-4.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
            moveTo(17.0f, 9.0f); horizontalLineToRelative(-4.0f); verticalLineTo(7.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(2.0f); close()
        }
    } }

    val Style: ImageVector by lazy { materialIcon("Filled.Style") {
        materialPath {
            moveTo(2.53f, 19.65f); lineToRelative(1.34f, -1.34f); curveTo(4.96f, 17.7f, 6.0f, 17.21f, 7.0f, 17.21f); curveToRelative(0.53f, 0.0f, 1.04f, 0.11f, 1.5f, 0.31f); lineTo(12.0f, 14.0f); lineTo(3.0f, 5.0f); verticalLineTo(2.0f); horizontalLineToRelative(3.0f); lineToRelative(1.5f, 1.5f); curveTo(8.66f, 2.34f, 10.27f, 2.0f, 12.0f, 2.0f); curveToRelative(2.21f, 0.0f, 4.0f, 1.79f, 4.0f, 4.0f); curveToRelative(0.0f, 1.19f, -0.52f, 2.25f, -1.33f, 3.0f); lineToRelative(2.45f, 2.45f); curveTo(17.63f, 11.23f, 18.0f, 10.64f, 18.0f, 10.0f); curveToRelative(0.0f, -0.12f, -0.01f, -0.23f, -0.02f, -0.34f); curveToRelative(0.42f, -0.23f, 0.81f, -0.53f, 1.15f, -0.89f); lineToRelative(1.34f, 1.34f); curveToRelative(-0.56f, 0.56f, -1.24f, 1.0f, -1.97f, 1.29f); curveToRelative(0.01f, 0.12f, 0.01f, 0.24f, 0.01f, 0.36f); curveToRelative(0.0f, 1.3f, -0.83f, 2.4f, -2.0f, 2.83f); verticalLineTo(23.0f); horizontalLineToRelative(-3.0f); verticalLineTo(15.0f); horizontalLineToRelative(1.0f); curveToRelative(0.55f, 0.0f, 1.0f, -0.45f, 1.0f, -1.0f); reflectiveCurveToRelative(-0.45f, -1.0f, -1.0f, -1.0f); horizontalLineTo(9.41f); lineTo(7.91f, 14.5f); curveToRelative(-0.2f, 0.45f, -0.31f, 0.96f, -0.31f, 1.5f); curveToRelative(0.0f, 1.0f, 0.3f, 1.96f, 0.84f, 2.79f); lineToRelative(-1.34f, 1.34f); curveTo(6.01f, 19.06f, 5.76f, 18.15f, 5.76f, 17.21f); curveToRelative(0.0f, -1.08f, 0.33f, -2.09f, 0.89f, -2.93f); lineTo(2.53f, 10.15f); curveToRelative(-0.56f, 0.84f, -0.89f, 1.85f, -0.89f, 2.93f); curveToRelative(0.0f, 0.94f, 0.25f, 1.85f, 0.71f, 2.65f); lineTo(2.53f, 19.65f); close()
            moveTo(12.0f, 8.0f); curveToRelative(-1.1f, 0.0f, -2.0f, -0.9f, -2.0f, -2.0f); reflectiveCurveToRelative(0.9f, -2.0f, 2.0f, -2.0f); reflectiveCurveToRelative(2.0f, 0.9f, 2.0f, 2.0f); reflectiveCurveToRelative(-0.9f, 2.0f, -2.0f, 2.0f); close()
        }
    } }

    val Memory: ImageVector by lazy { materialIcon(name = "Filled.Memory") {
        materialPath {
            moveTo(15.0f, 9.0f); lineTo(9.0f, 9.0f); verticalLineToRelative(6.0f); horizontalLineToRelative(6.0f); lineTo(15.0f, 9.0f); close()
            moveTo(21.0f, 11.0f); lineTo(21.0f, 9.0f); horizontalLineToRelative(-2.0f); lineTo(19.0f, 7.0f); curveToRelative(0.0f, -1.1f, -0.9f, -2.0f, -2.0f, -2.0f); horizontalLineToRelative(-2.0f); lineTo(15.0f, 3.0f); horizontalLineToRelative(-2.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(-2.0f); lineTo(11.0f, 3.0f); lineTo(9.0f, 3.0f); verticalLineToRelative(2.0f); lineTo(7.0f, 5.0f); curveToRelative(-1.1f, 0.0f, -2.0f, 0.9f, -2.0f, 2.0f); verticalLineToRelative(2.0f); lineTo(3.0f, 9.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); lineTo(3.0f, 13.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); curveToRelative(0.0f, 1.1f, 0.9f, 2.0f, 2.0f, 2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(-2.0f); verticalLineToRelative(-2.0f); horizontalLineToRelative(2.0f); close()
            moveTo(17.0f, 17.0f); lineTo(7.0f, 17.0f); lineTo(7.0f, 7.0f); horizontalLineToRelative(10.0f); verticalLineToRelative(10.0f); close()
        }
    } }
    val SdStorage: ImageVector by lazy { materialIcon(name = "Filled.SdStorage") {
        materialPath {
            moveTo(18.0f, 2.0f); lineTo(10.0f, 2.0f); lineTo(4.0f, 8.0f); verticalLineToRelative(12.0f); curveToRelative(0.0f, 1.1f, 0.9f, 2.0f, 2.0f, 2.0f); horizontalLineToRelative(12.0f); curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f); lineTo(20.0f, 4.0f); curveToRelative(0.0f, -1.1f, -0.9f, -2.0f, -2.0f, -2.0f); close()
            moveTo(12.0f, 4.0f); horizontalLineToRelative(4.0f); verticalLineToRelative(4.0f); horizontalLineToRelative(-4.0f); lineTo(12.0f, 4.0f); close()
        }
    } }
    val SwapHoriz: ImageVector by lazy { materialIcon(name = "Filled.SwapHoriz") {
        materialPath {
            moveTo(6.99f, 11.0f); lineTo(3.0f, 15.0f); lineToRelative(3.99f, 4.0f); verticalLineToRelative(-3.0f); horizontalLineTo(14.0f); verticalLineToRelative(-2.0f); horizontalLineTo(6.99f); verticalLineToRelative(-3.0f); close()
            moveTo(21.0f, 9.0f); lineToRelative(-3.99f, -4.0f); verticalLineToRelative(3.0f); horizontalLineTo(10.0f); verticalLineToRelative(2.0f); horizontalLineToRelative(7.01f); verticalLineToRelative(3.0f); lineTo(21.0f, 9.0f); close()
        }
    } }
    val Wifi: ImageVector by lazy { materialIcon(name = "Filled.Wifi") {
        materialPath {
            moveTo(1.0f, 9.0f); lineToRelative(2.0f, 2.0f); curveToRelative(4.97f, -4.97f, 13.03f, -4.97f, 18.0f, 0.0f); lineToRelative(2.0f, -2.0f); curveTo(16.93f, 2.93f, 7.07f, 2.93f, 1.0f, 9.0f); close()
            moveTo(9.0f, 17.0f); lineToRelative(3.0f, 3.0f); lineToRelative(3.0f, -3.0f); curveToRelative(-1.65f, -1.66f, -4.34f, -1.66f, -6.0f, 0.0f); close()
            moveTo(5.0f, 13.0f); lineToRelative(2.0f, 2.0f); curveToRelative(2.76f, -2.76f, 7.24f, -2.76f, 10.0f, 0.0f); lineToRelative(2.0f, -2.0f); curveTo(15.14f, 9.14f, 8.86f, 9.14f, 5.0f, 13.0f); close()
        }
    } }
    val GitHub: ImageVector by lazy { materialIcon(name = "Custom.GitHub") {
        materialPath {
            moveTo(12f, 2f)
            curveTo(6.48f, 2f, 2f, 6.48f, 2f, 12f)
            curveToRelative(0f, 4.42f, 2.87f, 8.17f, 6.84f, 9.5f)
            curveToRelative(0.5f, 0.09f, 0.68f, -0.22f, 0.68f, -0.48f)
            curveToRelative(0f, -0.24f, -0.01f, -0.82f, -0.01f, -1.6f)
            curveToRelative(-2.78f, 0.6f, -3.37f, -1.34f, -3.37f, -1.34f)
            curveToRelative(-0.45f, -1.16f, -1.11f, -1.47f, -1.11f, -1.47f)
            curveToRelative(-0.91f, -0.62f, 0.07f, -0.61f, 0.07f, -0.61f)
            curveToRelative(1f, 0.07f, 1.53f, 1.03f, 1.53f, 1.03f)
            curveToRelative(0.9f, 1.52f, 2.34f, 1.08f, 2.91f, 0.83f)
            curveToRelative(0.09f, -0.65f, 0.35f, -1.08f, 0.63f, -1.33f)
            curveToRelative(-2.22f, -0.25f, -4.55f, -1.11f, -4.55f, -4.94f)
            curveToRelative(0f, -1.1f, 0.39f, -1.99f, 1.03f, -2.69f)
            curveToRelative(-0.1f, -0.25f, -0.45f, -1.27f, 0.1f, -2.65f)
            curveToRelative(0f, 0f, 0.84f, -0.27f, 2.75f, 1.02f)
            curveToRelative(0.8f, -0.22f, 1.65f, -0.33f, 2.5f, -0.33f)
            curveToRelative(0.85f, 0f, 1.7f, 0.11f, 2.5f, 0.33f)
            curveToRelative(1.91f, -1.29f, 2.75f, -1.02f, 2.75f, -1.02f)
            curveToRelative(0.55f, 1.38f, 0.2f, 2.4f, 0.1f, 2.65f)
            curveToRelative(0.64f, 0.7f, 1.03f, 1.6f, 1.03f, 2.69f)
            curveToRelative(0f, 3.84f, -2.34f, 4.68f, -4.57f, 4.93f)
            curveToRelative(0.36f, 0.31f, 0.68f, 0.92f, 0.68f, 1.85f)
            curveToRelative(0f, 1.34f, -0.01f, 2.42f, -0.01f, 2.75f)
            curveToRelative(0f, 0.27f, 0.18f, 0.58f, 0.69f, 0.48f)
            curveTo(19.13f, 20.17f, 22f, 16.42f, 22f, 12f)
            curveTo(22f, 6.48f, 17.52f, 2f, 12f, 2f)
            close()
        }
    } }
}
```

app/src/main/java/com/crfzit/crfzit/ui/logs/LogsScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/logs/LogsScreen.kt
package com.crfzit.crfzit.ui.logs

import android.graphics.RenderEffect
import android.graphics.Shader
import android.os.Build
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.PathEffect
import androidx.compose.ui.graphics.asComposeRenderEffect
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.crfzit.crfzit.data.model.LogLevel
import com.crfzit.crfzit.ui.stats.StatisticsScreen
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LogsScreen(viewModel: LogsViewModel = viewModel()) {
    var selectedTab by remember { mutableIntStateOf(0) }
    val tabs = listOf("äº‹ä»¶æ—¶é—´çº¿", "èµ„æºç»Ÿè®¡")

    Scaffold(topBar = { TopAppBar(title = { Text("æ—¥å¿—ä¸ç»Ÿè®¡") }) }) { padding ->
        Column(Modifier.padding(padding)) {
            PrimaryTabRow(selectedTabIndex = selectedTab) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = selectedTab == index,
                        onClick = { selectedTab = index },
                        text = { Text(title) }
                    )
                }
            }
            when (selectedTab) {
                0 -> EventTimelineTab(viewModel)
                1 -> StatisticsScreen()
            }
        }
    }
}

@Composable
fun EventTimelineTab(viewModel: LogsViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    val listState = rememberLazyListState()

    // [æ ¸å¿ƒä¿®å¤] 2. ä¿®æ­£è‡ªåŠ¨æ»šåŠ¨é€»è¾‘ï¼Œé˜²æ­¢å¹²æ‰°ç”¨æˆ·æ“ä½œ
    LaunchedEffect(viewModel, listState) {
        snapshotFlow { uiState.timelineItems.firstOrNull()?.id }
            .distinctUntilChanged()
            .collect { newId ->
                // åªæœ‰å½“æ–°æ—¥å¿—åˆ°æ¥ï¼Œä¸”ç”¨æˆ·å½“å‰å®Œå…¨åœ¨åˆ—è¡¨é¡¶éƒ¨æ—¶ï¼Œæ‰è‡ªåŠ¨æ»šåŠ¨
                if (newId != null && listState.firstVisibleItemIndex == 0) {
                    listState.animateScrollToItem(0)
                }
            }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        MaterialTheme.colorScheme.surface,
                        MaterialTheme.colorScheme.surfaceContainerLow
                    )
                )
            )
    ) {
        if (uiState.isLoading && uiState.timelineItems.isEmpty()) {
            CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
        } else {
            LazyColumn(
                state = listState,
                modifier = Modifier.fillMaxSize(),
                contentPadding = PaddingValues(horizontal = 12.dp, vertical = 8.dp),
                verticalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                items(items = uiState.timelineItems, key = { it.id }) { item ->
                    when (item) {
                        is SingleLogItem -> LogCard(item.log)
                        is LogGroupItem -> ReportGroupCard(item)
                    }
                }
                if (uiState.isLoadingMore) {
                    item {
                        Row(modifier = Modifier.fillMaxWidth().padding(8.dp), horizontalArrangement = Arrangement.Center) {
                            CircularProgressIndicator()
                        }
                    }
                }
            }

            val shouldLoadMore by remember {
                derivedStateOf {
                    val li = listState.layoutInfo
                    val isAtBottom = li.visibleItemsInfo.lastOrNull()?.index == li.totalItemsCount - 1
                    isAtBottom && !uiState.isLoadingMore && !uiState.hasReachedEnd
                }
            }
            LaunchedEffect(shouldLoadMore) {
                if (shouldLoadMore) {
                    viewModel.loadMoreLogs()
                }
            }
        }
    }
}

// æ­£ç¡®å®ç°é«˜æ–¯æ¨¡ç³Šæ¯›ç»ç’ƒæ•ˆæœçš„åŸºç±»
@Composable
fun GlassmorphicCard(
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit
) {
    val shape = RoundedCornerShape(16.dp)
    Box(modifier = modifier.clip(shape)) {
        Box(
            modifier = Modifier
                .matchParentSize()
                .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f))
                .then(
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                        Modifier.graphicsLayer(
                            renderEffect = RenderEffect
                                .createBlurEffect(25f, 25f, Shader.TileMode.DECAL)
                                .asComposeRenderEffect()
                        )
                    } else {
                        Modifier
                    }
                )
        )
        content()
    }
}

// æ™®é€šæ—¥å¿—å¡ç‰‡
@Composable
fun LogCard(log: UiLogEntry) {
    GlassmorphicCard {
        LogItemContent(log = log)
    }
}

// [æ ¸å¿ƒä¿®å¤] 1. å®ç°äº†ç»Ÿä¸€æŠ¥å‘Šåœ¨ä¸€ä¸ªå¡ç‰‡ä¸­çš„å¸ƒå±€
@Composable
fun ReportGroupCard(group: LogGroupItem) {
    GlassmorphicCard {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            ReportHeader(log = group.parentLog)
            HorizontalDivider(
                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
                color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.2f)
            )
            Column(
                verticalArrangement = Arrangement.spacedBy(8.dp),
                modifier = Modifier.padding(bottom = 8.dp)
            ) {
                group.childLogs.forEach { childLog ->
                    LogItemContent(log = childLog)
                }
            }
        }
    }
}

@Composable
private fun ReportHeader(log: UiLogEntry) {
    val (icon, color) = getLogAppearance(log.originalLog.level)
    val formatter = remember { SimpleDateFormat("HH:mm:ss", Locale.getDefault()) }
    Column(
        modifier = Modifier.padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = icon,
            fontSize = 28.sp,
            color = color.takeIf { it != Color.Unspecified } ?: MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(4.dp))
        Text(
            text = log.originalLog.message,
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(Modifier.height(4.dp))
        Text(
            text = formatter.format(Date(log.originalLog.timestamp)),
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

@Composable
fun DashedVerticalDivider() {
    val pathEffect = PathEffect.dashPathEffect(floatArrayOf(10f, 10f), 0f)
    val color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.4f)
    Canvas(Modifier.fillMaxHeight().width(1.dp)) {
        drawLine(
            color = color,
            start = Offset(0f, 0f),
            end = Offset(0f, size.height),
            pathEffect = pathEffect
        )
    }
}

@Composable
fun LogItemContent(log: UiLogEntry) {
    val originalLog = log.originalLog
    val formatter = remember { SimpleDateFormat("HH:mm:ss", Locale.getDefault()) }
    val (icon, color) = getLogAppearance(originalLog.level)

    val annotatedString = buildAnnotatedString {
        if (originalLog.level == LogLevel.REPORT) {
            val messageParts = originalLog.message.split('\n')
            val title = log.appName ?: messageParts.firstOrNull() ?: ""
            val details = messageParts.drop(1).joinToString("\n")
            withStyle(style = SpanStyle(fontWeight = FontWeight.SemiBold, color = MaterialTheme.colorScheme.primary)) { append(title) }
            if (details.isNotEmpty()) {
                withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onSurfaceVariant, fontSize = 13.sp)) { append("\n$details") }
            }
        } else if (originalLog.category != "æŠ¥å‘Š" && !log.appName.isNullOrEmpty()) {
            append("åº”ç”¨ â€˜")
            withStyle(style = SpanStyle(fontWeight = FontWeight.SemiBold, color = MaterialTheme.colorScheme.primary)) { append(log.appName) }
            append("â€™ "); append(originalLog.message)
        } else {
            append(originalLog.message)
        }
    }

    Row(
        modifier = Modifier.fillMaxWidth().height(IntrinsicSize.Min).padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier.width(90.dp).padding(horizontal = 8.dp)
        ) {
            Text(
                text = icon,
                fontSize = 24.sp,
                color = color.takeIf { it != Color.Unspecified } ?: MaterialTheme.colorScheme.onSurface
            )
            Spacer(Modifier.height(4.dp))
            Text(
                text = formatter.format(Date(originalLog.timestamp)),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                fontSize = 11.sp
            )
        }
        DashedVerticalDivider()
        Column(modifier = Modifier.padding(start = 12.dp, end = 16.dp).weight(1f)) {
            Text(
                text = "[${originalLog.category}]",
                style = MaterialTheme.typography.labelMedium,
                fontWeight = FontWeight.Bold,
                color = color.takeIf { it != Color.Unspecified } ?: MaterialTheme.colorScheme.primary,
                fontFamily = FontFamily.Monospace
            )
            Spacer(Modifier.height(4.dp))
            Text(
                text = annotatedString,
                style = MaterialTheme.typography.bodyMedium.copy(lineHeight = 20.sp)
            )
        }
    }
}

@Composable
fun getLogAppearance(level: LogLevel): Pair<String, Color> {
    return when (level) {
        LogLevel.INFO -> "â„¹ï¸" to MaterialTheme.colorScheme.outline
        LogLevel.SUCCESS -> "âœ…" to Color(0xFF34A853)
        LogLevel.WARN -> "âš ï¸" to Color(0xFFFBBC05)
        LogLevel.ERROR -> "âŒ" to MaterialTheme.colorScheme.error
        LogLevel.EVENT -> "âš¡" to MaterialTheme.colorScheme.primary
        LogLevel.DOZE -> "ğŸŒ™" to Color(0xFF6650a4)
        LogLevel.BATTERY -> "ğŸ”‹" to Color(0xFF0B8043)
        LogLevel.REPORT -> "ğŸ“Š" to Color(0xFF1A73E8)
        LogLevel.ACTION_OPEN -> "â–¶ï¸" to Color.Unspecified
        LogLevel.ACTION_CLOSE -> "â¹ï¸" to MaterialTheme.colorScheme.onSurfaceVariant
        LogLevel.ACTION_FREEZE -> "â„ï¸" to Color(0xFF4285F4)
        LogLevel.ACTION_UNFREEZE -> "â˜€ï¸" to Color(0xFFF4B400)
        LogLevel.ACTION_DELAY -> "â³" to Color(0xFFE52592)
        LogLevel.TIMER -> "â°" to Color(0xFFF25622)
        LogLevel.BATCH_PARENT -> "ğŸ“¦" to Color.Unspecified
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/logs/LogsViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/logs/LogsViewModel.kt
package com.crfzit.crfzit.ui.logs

import android.app.Application
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.LogEntry
import com.crfzit.crfzit.data.model.LogLevel
import com.crfzit.crfzit.data.repository.AppInfoRepository
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.UUID

// æ•°æ®æ¨¡å‹ä¿æŒä¸å˜
sealed interface TimelineItem {
    val id: String
    val timestamp: Long
}
data class SingleLogItem(val log: UiLogEntry) : TimelineItem {
    override val id: String = "${log.originalLog.timestamp}-${log.originalLog.level}-${log.originalLog.message}-${UUID.randomUUID()}"
    override val timestamp: Long = log.originalLog.timestamp
}
data class LogGroupItem(val parentLog: UiLogEntry, val childLogs: List<UiLogEntry>) : TimelineItem {
    override val id: String = "${parentLog.originalLog.timestamp}-group-${UUID.randomUUID()}"
    override val timestamp: Long = parentLog.originalLog.timestamp
}
data class UiLogEntry(val originalLog: LogEntry, val appName: String?)

data class LogsUiState(
    val isLoading: Boolean = true,
    val rawLogs: List<UiLogEntry> = emptyList(),
    val timelineItems: List<TimelineItem> = emptyList(),
    val isLoadingMore: Boolean = false,
    val hasReachedEnd: Boolean = false,
    val logFiles: List<String> = emptyList(),
    val currentFileIndex: Int = 0
)

class LogsViewModel(application: Application) : AndroidViewModel(application) {
    companion object {
        private const val PAGE_SIZE = 50
        // [æ ¸å¿ƒæ–°å¢] æ§åˆ¶å†…å­˜ä¸­æœ€å¤šä¿ç•™çš„æ—¥å¿—æ¡æ•°
        private const val MAX_LOGS_IN_MEMORY = 1000
    }

    private val daemonRepository = DaemonRepository.getInstance()
    private val appInfoRepository = AppInfoRepository.getInstance(application)

    private val _uiState = MutableStateFlow(LogsUiState())
    val uiState: StateFlow<LogsUiState> = _uiState.asStateFlow()

    private var pollingJob: Job? = null
    private val uiStateUpdateMutex = Mutex()

    init {
        viewModelScope.launch {
            appInfoRepository.getAllApps(forceRefresh = true)
            loadInitialLogs()
            startPollingForNewLogs()
        }
    }

    private fun loadInitialLogs() {
        viewModelScope.launch {
            uiStateUpdateMutex.withLock {
                _uiState.value = LogsUiState(isLoading = true)
            }
            val files = daemonRepository.getLogFiles() ?: emptyList()
            if (files.isEmpty()) {
                _uiState.update { it.copy(isLoading = false, hasReachedEnd = true) }
                return@launch
            }
            val initialLogs = daemonRepository.getLogs(filename = files[0], limit = PAGE_SIZE) ?: emptyList()
            val uiHistory = initialLogs.map { mapToUiLog(it) }
            _uiState.update {
                it.copy(
                    isLoading = false,
                    rawLogs = uiHistory,
                    timelineItems = processLogsIntoTimelineItems(uiHistory),
                    logFiles = files,
                    currentFileIndex = 0,
                    hasReachedEnd = initialLogs.size < PAGE_SIZE && files.size <= 1
                )
            }
        }
    }

    fun loadMoreLogs() {
        viewModelScope.launch {
            if (_uiState.value.isLoadingMore || _uiState.value.hasReachedEnd) return@launch
            uiStateUpdateMutex.withLock {
                val currentState = _uiState.value
                if (currentState.isLoadingMore || currentState.hasReachedEnd) return@withLock
                _uiState.update { it.copy(isLoadingMore = true) }
                val lastLogTimestamp = currentState.rawLogs.lastOrNull()?.originalLog?.timestamp
                val currentFilename = currentState.logFiles.getOrNull(currentState.currentFileIndex)
                if (currentFilename == null || lastLogTimestamp == null) {
                    _uiState.update { it.copy(isLoadingMore = false, hasReachedEnd = true) }
                    return@withLock
                }
                var olderLogs = daemonRepository.getLogs(filename = currentFilename, before = lastLogTimestamp, limit = PAGE_SIZE) ?: emptyList()
                var nextFileIndex = currentState.currentFileIndex
                if (olderLogs.isEmpty() && currentState.currentFileIndex + 1 < currentState.logFiles.size) {
                    nextFileIndex = currentState.currentFileIndex + 1
                    olderLogs = daemonRepository.getLogs(filename = currentState.logFiles[nextFileIndex], limit = PAGE_SIZE) ?: emptyList()
                }
                val newUiLogs = if (olderLogs.isNotEmpty()) olderLogs.map { mapToUiLog(it) } else emptyList()

                // [æ ¸å¿ƒä¿®æ”¹] ç¡®ä¿åŠ è½½æ›´å¤šæ—¶ä¹Ÿä¸ä¼šè¶…è¿‡å†…å­˜ä¸Šé™
                val combinedRawLogs = (currentState.rawLogs + newUiLogs).takeLast(MAX_LOGS_IN_MEMORY)

                _uiState.update {
                    it.copy(
                        isLoadingMore = false,
                        rawLogs = combinedRawLogs,
                        timelineItems = processLogsIntoTimelineItems(combinedRawLogs),
                        currentFileIndex = nextFileIndex,
                        hasReachedEnd = olderLogs.size < PAGE_SIZE && nextFileIndex >= it.logFiles.size - 1
                    )
                }
            }
        }
    }

    private fun startPollingForNewLogs() {
        pollingJob?.cancel()
        pollingJob = viewModelScope.launch {
            while (true) {
                delay(3000)
                try {
                    val latestTimestamp = _uiState.value.rawLogs.firstOrNull()?.originalLog?.timestamp
                    val files = daemonRepository.getLogFiles() ?: emptyList()
                    if (files.isEmpty()) continue
                    val newLogs = daemonRepository.getLogs(filename = files[0], since = latestTimestamp)
                    if (!newLogs.isNullOrEmpty()) {
                        val newUiLogs = newLogs.map { mapToUiLog(it) }
                        uiStateUpdateMutex.withLock {
                            val currentState = _uiState.value
                            // [æ ¸å¿ƒä¿®æ”¹] åˆå¹¶å¹¶æˆªæ–­ï¼Œç¡®ä¿å†…å­˜å ç”¨å¯æ§
                            val combinedRawLogs = (newUiLogs + currentState.rawLogs)
                                .distinctBy { log -> "${log.originalLog.timestamp}-${log.originalLog.message}-${log.originalLog.level}" }
                                .sortedByDescending { log -> log.originalLog.timestamp }
                                .take(MAX_LOGS_IN_MEMORY)
                            _uiState.update {
                                it.copy(
                                    rawLogs = combinedRawLogs,
                                    timelineItems = processLogsIntoTimelineItems(combinedRawLogs),
                                    logFiles = if (files != currentState.logFiles) files else currentState.logFiles
                                )
                            }
                        }
                    } else if (files != _uiState.value.logFiles) {
                        _uiState.update { it.copy(logFiles = files) }
                    }
                } catch (e: Exception) {
                    Log.w("LogsViewModel", "Error polling for new logs: ${e.message}")
                }
            }
        }
    }

    private fun processLogsIntoTimelineItems(logs: List<UiLogEntry>): List<TimelineItem> {
        if (logs.isEmpty()) return emptyList()
        val result = mutableListOf<TimelineItem>()
        val sortedLogs = logs.sortedBy { it.originalLog.timestamp }
        var i = 0
        while (i < sortedLogs.size) {
            val currentLog = sortedLogs[i]
            if (currentLog.originalLog.level == LogLevel.BATCH_PARENT) {
                val children = mutableListOf<UiLogEntry>()
                var j = i + 1
                while (j < sortedLogs.size &&
                    sortedLogs[j].originalLog.level == LogLevel.REPORT &&
                    sortedLogs[j].originalLog.timestamp == currentLog.originalLog.timestamp
                ) {
                    children.add(sortedLogs[j])
                    j++
                }
                result.add(LogGroupItem(currentLog, children))
                i = if (children.isNotEmpty()) j else i + 1
            } else {
                result.add(SingleLogItem(currentLog))
                i++
            }
        }
        return result.asReversed()
    }

    private suspend fun mapToUiLog(log: LogEntry): UiLogEntry {
        val appName = log.packageName?.let { pkg ->
            val baseName = appInfoRepository.getAppInfo(pkg)?.appName
            if (log.userId != 0 && log.userId != -1) "$baseName (åˆ†èº«)" else baseName
        }
        if (log.level == LogLevel.REPORT) {
            val originalMessageTitle = log.message.substringBefore(" æ€»è®¡:")
            return UiLogEntry(originalLog = log, appName = appName ?: originalMessageTitle)
        }
        return UiLogEntry(originalLog = log, appName = appName ?: log.packageName)
    }

    override fun onCleared() {
        pollingJob?.cancel()
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/profiles/ProfileManagementScreen.kt
```
package com.crfzit.crfzit.ui.profiles

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProfileManagementScreen(onNavigateBack: () -> Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("æƒ…æ™¯æ¨¡å¼ç®¡ç†") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "è¿”å›")
                    }
                }
            )
        }
    ) { padding ->
        Box(
            modifier = Modifier.padding(padding).fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text("æƒ…æ™¯æ¨¡å¼ç®¡ç†åŠŸèƒ½ (å¾…å®ç°)")
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsScreen.kt
package com.crfzit.crfzit.ui.settings

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.crfzit.crfzit.ui.icons.AppIcons
import kotlin.math.roundToInt

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(viewModel: SettingsViewModel = viewModel()) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = { TopAppBar(title = { Text("è®¾ç½®") }) }
    ) { padding ->
        LazyColumn(
            modifier = Modifier.padding(padding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                SettingsGroup(title = "æ ¸å¿ƒç­–ç•¥") {
                    TimeoutSlider(
                        title = "æ™ºèƒ½æ¨¡å¼åå°è¶…æ—¶",
                        value = uiState.standardTimeoutSec.toFloat(),
                        onValueChange = { viewModel.setStandardTimeout(it.roundToInt()) },
                        valueRange = 30f..300f,
                        unit = "ç§’"
                    )
                }
            }

            item {
                SettingsGroup(title = "å®šæ—¶è§£å†» (å¿ƒè·³)") {
                    SwitchSetting(
                        title = "å¯ç”¨å®šæ—¶è§£å†»",
                        subtitle = "å®šæœŸå”¤é†’åº”ç”¨ä»¥åŒæ­¥æ¶ˆæ¯ï¼Œå¹³è¡¡ç»­èˆªä¸é€šçŸ¥",
                        checked = uiState.isTimedUnfreezeEnabled,
                        onCheckedChange = viewModel::setTimedUnfreezeEnabled
                    )

                    if (uiState.isTimedUnfreezeEnabled) {
                        Spacer(Modifier.height(16.dp))
                        TimeoutSlider(
                            title = "è§£å†»é—´éš”",
                            value = uiState.timedUnfreezeIntervalSec.toFloat(),
                            onValueChange = { viewModel.setTimedUnfreezeInterval(it.roundToInt()) },
                            valueRange = 300f..7200f,
                            unit = "åˆ†é’Ÿ",
                            displayValueTransform = { (it / 60).roundToInt() }
                        )
                    }
                }
            }

            // [æ ¸å¿ƒæ–°å¢] â€œå…³äºâ€åŒºåŸŸ
            item {
                SettingsGroup(title = "å…³äº") {
                    InfoItem(title = "ä½œè€…", value = "zzaolv")
                    Divider(modifier = Modifier.padding(vertical = 8.dp))
                    InfoItem(title = "æ„å»ºæ—¶é—´", value = uiState.buildTime)
                    Divider(modifier = Modifier.padding(vertical = 8.dp))
                    ClickableInfoItem(
                        title = "é¡¹ç›®åœ°å€ï¼ˆåˆ«ç‚¹ï¼‰",
                        icon = AppIcons.GitHub,
                        onClick = { viewModel.onGitHubIconClicked() }
                    )
                }
            }
        }
    }
}

// [æ ¸å¿ƒæ–°å¢] å¯é‡ç”¨çš„ä¿¡æ¯å±•ç¤ºè¡Œ
@Composable
fun InfoItem(title: String, value: String) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.bodyLarge,
            modifier = Modifier.weight(1f)
        )
        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

// [æ ¸å¿ƒæ–°å¢] å¯é‡ç”¨çš„ã€å¸¦å›¾æ ‡çš„ã€å¯ç‚¹å‡»çš„ä¿¡æ¯è¡Œ
@Composable
fun ClickableInfoItem(
    title: String,
    icon: ImageVector,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.bodyLarge,
            modifier = Modifier.weight(1f)
        )
        Icon(
            imageVector = icon,
            contentDescription = title,
            tint = MaterialTheme.colorScheme.primary
        )
    }
}


@Composable
fun SettingsGroup(title: String, content: @Composable ColumnScope.() -> Unit) {
    Card {
        Column(Modifier.padding(16.dp)) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.primary,
                modifier = Modifier.padding(bottom = 8.dp)
            )
            content()
        }
    }
}

@Composable
fun SwitchSetting(
    title: String,
    subtitle: String,
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onCheckedChange(!checked) },
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(title, style = MaterialTheme.typography.bodyLarge)
            Text(
                text = subtitle,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        Switch(
            checked = checked,
            onCheckedChange = onCheckedChange
        )
    }
}

@Composable
fun TimeoutSlider(
    title: String,
    value: Float,
    onValueChange: (Float) -> Unit,
    valueRange: ClosedFloatingPointRange<Float>,
    unit: String,
    displayValueTransform: (Float) -> Int = { it.roundToInt() }
) {
    var sliderPosition by remember(value) { mutableFloatStateOf(value) }

    Column {
        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(title, modifier = Modifier.weight(1f))
            Text(
                "${displayValueTransform(sliderPosition)} $unit",
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.primary,
                textDecoration = TextDecoration.Underline
            )
        }
        Slider(
            value = sliderPosition,
            onValueChange = { sliderPosition = it },
            valueRange = valueRange,
            steps = ((valueRange.endInclusive - valueRange.start) / (if(unit == "åˆ†é’Ÿ") 300f else 10f)).roundToInt() - 1,
            onValueChangeFinished = {
                onValueChange(sliderPosition)
            }
        )
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/settings/SettingsViewModel.kt
package com.crfzit.crfzit.ui.settings

import android.app.Application
import android.content.Intent
import android.net.Uri
import android.widget.Toast
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.BuildConfig // å¯¼å…¥è‡ªåŠ¨ç”Ÿæˆçš„BuildConfig
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

data class SettingsUiState(
    val isLoading: Boolean = true,
    val standardTimeoutSec: Int = 90,
    val isTimedUnfreezeEnabled: Boolean = true,
    val timedUnfreezeIntervalSec: Int = 1800,
    // [æ ¸å¿ƒæ–°å¢] æ–°å¢ç”¨äºæ˜¾ç¤ºæ„å»ºæ—¶é—´çš„å­—æ®µ
    val buildTime: String = "N/A"
)

class SettingsViewModel(private val app: Application) : AndroidViewModel(app) {
    private val daemonRepository = DaemonRepository.getInstance()

    private val _uiState = MutableStateFlow(SettingsUiState())
    val uiState = _uiState.asStateFlow()

    // [æ ¸å¿ƒæ–°å¢] å®šä¹‰åŸç¥ç›¸å…³çš„å¸¸é‡
    private companion object {
        const val GENSHIN_PACKAGE_NAME = "com.miHoYo.GenshinImpact"
        const val GENSHIN_URL = "https://ys.mihoyo.com/main/"
    }

    init {
        loadSettings()
        loadBuildInfo() // åœ¨åˆå§‹åŒ–æ—¶åŠ è½½æ„å»ºä¿¡æ¯
    }

    private fun loadBuildInfo() {
        // [æ ¸å¿ƒæ–°å¢] ä»BuildConfigè·å–æ—¶é—´æˆ³å¹¶æ ¼å¼åŒ–
        try {
            val buildTimestamp = BuildConfig.BUILD_TIME
            val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault())
            _uiState.update { it.copy(buildTime = dateFormat.format(Date(buildTimestamp))) }
        } catch (e: Exception) {
            // In case of any error, keep the default "N/A"
        }
    }

    // [æ ¸å¿ƒæ–°å¢] å¤„ç†GitHubå›¾æ ‡ç‚¹å‡»äº‹ä»¶çš„æ¶è¶£å‘³é€»è¾‘
    fun onGitHubIconClicked() {
        val packageManager = app.packageManager
        val launchIntent = packageManager.getLaunchIntentForPackage(GENSHIN_PACKAGE_NAME)

        if (launchIntent != null) {
            // å¦‚æœå®‰è£…äº†åŸç¥ï¼Œå¯åŠ¨å®ƒï¼
            Toast.makeText(app, "æ­£åœ¨å¯åŠ¨...", Toast.LENGTH_SHORT).show()
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            app.startActivity(launchIntent)
        } else {
            // å¦‚æœæ²¡å®‰è£…ï¼Œè·³è½¬åˆ°å®˜ç½‘
            Toast.makeText(app, "æœªæ£€æµ‹åˆ°åº”ç”¨ï¼Œæ­£åœ¨å‰å¾€å®˜ç½‘...", Toast.LENGTH_SHORT).show()
            val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(GENSHIN_URL))
            browserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            app.startActivity(browserIntent)
        }
    }

    private fun loadSettings() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val config = daemonRepository.getAllPolicies()
            if (config != null) {
                val masterConfig = config.masterConfig
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        standardTimeoutSec = masterConfig.standardTimeoutSec,
                        isTimedUnfreezeEnabled = masterConfig.isTimedUnfreezeEnabled,
                        timedUnfreezeIntervalSec = masterConfig.timedUnfreezeIntervalSec
                    )
                }
            } else {
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }

    fun setStandardTimeout(seconds: Int) {
        _uiState.update { it.copy(standardTimeoutSec = seconds) }
        sendMasterConfigUpdate()
    }

    fun setTimedUnfreezeEnabled(isEnabled: Boolean) {
        _uiState.update { it.copy(isTimedUnfreezeEnabled = isEnabled) }
        sendMasterConfigUpdate()
    }

    fun setTimedUnfreezeInterval(seconds: Int) {
        _uiState.update { it.copy(timedUnfreezeIntervalSec = seconds) }
        sendMasterConfigUpdate()
    }

    private fun sendMasterConfigUpdate() {
        viewModelScope.launch {
            val currentState = _uiState.value
            val payload = mapOf(
                "standard_timeout_sec" to currentState.standardTimeoutSec,
                "is_timed_unfreeze_enabled" to currentState.isTimedUnfreezeEnabled,
                "timed_unfreeze_interval_sec" to currentState.timedUnfreezeIntervalSec
            )
            daemonRepository.setMasterConfig(payload)
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsScreen.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsScreen.kt
package com.crfzit.crfzit.ui.stats

import android.graphics.Paint
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.PathEffect
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.crfzit.crfzit.data.model.MetricsRecord
import kotlin.math.abs

private val ChartColors = listOf(
    Color(0xFFF44336), Color(0xFF4CAF50), Color(0xFF2196F3), Color(0xFFFFC107),
    Color(0xFF9C27B0), Color(0xFF00BCD4), Color(0xFFE91E63), Color(0xFFFF9800)
)

@Composable
fun StatisticsScreen(viewModel: StatisticsViewModel = viewModel()) {
    val uiState by viewModel.uiState.collectAsState()

    if (uiState.isLoading && uiState.records.isEmpty()) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            CircularProgressIndicator()
        }
    } else {
        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                val coreCount = uiState.records.firstOrNull()?.perCoreCpuUsagePercent?.size ?: 0
                ChartCard(title = "CPU ä½¿ç”¨ç‡ (%)") {
                    MultiLineChart(
                        records = uiState.records,
                        valueExtractor = { it.perCoreCpuUsagePercent },
                        range = 0f..100f
                    )
                    if (coreCount > 0) {
                        Spacer(Modifier.height(8.dp))
                        ChartLegend(coreCount = coreCount)
                    }
                }
            }
            item {
                ChartCard(title = "å†…å­˜ä½¿ç”¨ç‡ (%)") {
                    LineChart(
                        records = uiState.records,
                        color = Color(0xFF34A853),
                        valueExtractor = {
                            if (it.memTotalKb > 0) (it.memTotalKb - it.memAvailableKb) * 100f / it.memTotalKb else 0f
                        },
                        range = 0f..100f,
                        labelFormat = "%.1f%%"
                    )
                }
            }
            item {
                ChartCard(title = "ç”µæ± æ¸©åº¦ (Â°C)") {
                    LineChart(
                        records = uiState.records,
                        color = Color(0xFFF4B400),
                        valueExtractor = { it.batteryTempCelsius },
                        range = 20f..50f,
                        labelFormat = "%.1fÂ°C"
                    )
                }
            }
        }
    }
}

@Composable
fun ChartCard(title: String, content: @Composable ColumnScope.() -> Unit) {
    Card(shape = RoundedCornerShape(16.dp)) {
        Column(Modifier.padding(horizontal = 16.dp, vertical = 20.dp)) {
            Text(title, style = MaterialTheme.typography.titleMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
            Spacer(Modifier.height(16.dp))
            content()
        }
    }
}

@Composable
fun ChartLegend(coreCount: Int) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(top = 4.dp),
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        for (i in 0 until coreCount) {
            val color = ChartColors.getOrElse(i) { Color.Gray }
            Box(modifier = Modifier.size(10.dp).background(color, shape = RoundedCornerShape(2.dp)))
            Text(text = "C${i}", style = MaterialTheme.typography.labelSmall, modifier = Modifier.padding(start = 4.dp, end = 12.dp))
        }
    }
}

@Composable
private fun rememberTextPaint(color: Color = Color.Black, spSize: Float = 12f, align: Paint.Align = Paint.Align.CENTER): Paint {
    val density = LocalDensity.current
    val textColor = color.toArgb()
    return remember(density, color, spSize, align) {
        Paint().apply {
            this.color = textColor; this.textAlign = align; this.textSize = with(density) { spSize.sp.toPx() }
        }
    }
}

fun DrawScope.drawChartScaffold(yRange: ClosedFloatingPointRange<Float>, yAxisPaint: Paint, yAxisLabelCount: Int = 5) {
    val gridPath = Path()
    val step = size.height / (yAxisLabelCount - 1)
    (0 until yAxisLabelCount).forEach { i ->
        val y = i * step
        gridPath.moveTo(0f, y); gridPath.lineTo(size.width, y)
        val labelValue = yRange.endInclusive - i * (yRange.endInclusive - yRange.start) / (yAxisLabelCount - 1)
        drawIntoCanvas { it.nativeCanvas.drawText("%.0f".format(labelValue), -12f, y + yAxisPaint.textSize / 3, yAxisPaint) }
    }
    drawPath(gridPath, Color.Gray.copy(alpha = 0.3f), style = Stroke(width = 1f, pathEffect = PathEffect.dashPathEffect(floatArrayOf(10f, 10f))))
}

private data class LabelInfo(val index: Int, val x: Float, val y: Float, val text: String, val priority: Int)

@Composable
fun LineChart(
    modifier: Modifier = Modifier,
    records: List<MetricsRecord>,
    color: Color,
    valueExtractor: (MetricsRecord) -> Float,
    range: ClosedFloatingPointRange<Float>? = null,
    labelFormat: String = "%.1f"
) {
    // [æ ¸å¿ƒä¿®å¤] 1. åˆ›å»ºä¸‰ç§å¯¹é½æ–¹å¼çš„ç”»ç¬”
    val leftTextPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurface, spSize = 10f, align = Paint.Align.LEFT)
    val centerTextPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurface, spSize = 10f, align = Paint.Align.CENTER)
    val rightTextPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurface, spSize = 10f, align = Paint.Align.RIGHT)
    val yAxisPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurfaceVariant, spSize = 10f, align = Paint.Align.RIGHT)
    val labelCollisionThreshold: Dp = 40.dp

    Canvas(modifier = modifier.fillMaxWidth().height(150.dp).padding(start = 32.dp)) {
        val yValues = records.map(valueExtractor)
        val yMin = range?.start ?: (yValues.minOrNull() ?: 0f)
        val yMax = range?.endInclusive ?: (yValues.maxOrNull() ?: 100f)
        val yRangeValue = (yMax - yMin).coerceAtLeast(1f)

        drawChartScaffold(yRange = yMin..yMax, yAxisPaint = yAxisPaint)
        if (records.isEmpty()) return@Canvas

        val xStep = if (records.size > 1) size.width / (records.size - 1) else size.width / 2
        val path = Path()

        val labelsToConsider = mutableMapOf<Int, LabelInfo>()
        if (records.isNotEmpty()) {
            val latestIndex = records.indices.last
            val minIndex = yValues.withIndex().minByOrNull { it.value }?.index ?: -1
            val maxIndex = yValues.withIndex().maxByOrNull { it.value }?.index ?: -1

            val latestY = size.height - ((yValues[latestIndex] - yMin) / yRangeValue * size.height)
            labelsToConsider[latestIndex] = LabelInfo(latestIndex, if (records.size == 1) xStep else latestIndex * xStep, latestY, labelFormat.format(yValues[latestIndex]), 3)

            if (maxIndex != -1) {
                val maxY = size.height - ((yValues[maxIndex] - yMin) / yRangeValue * size.height)
                labelsToConsider[maxIndex] = LabelInfo(maxIndex, if (records.size == 1) xStep else maxIndex * xStep, maxY, labelFormat.format(yValues[maxIndex]), 2)
            }
            if (minIndex != -1) {
                val minY = size.height - ((yValues[minIndex] - yMin) / yRangeValue * size.height)
                labelsToConsider[minIndex] = LabelInfo(minIndex, if (records.size == 1) xStep else minIndex * xStep, minY, labelFormat.format(yValues[minIndex]), 1)
            }
        }

        val finalLabels = mutableListOf<LabelInfo>()
        val sortedLabels = labelsToConsider.values.sortedByDescending { it.priority }
        for (label in sortedLabels) {
            var hasCollision = false
            for (existingLabel in finalLabels) {
                if (abs(label.x - existingLabel.x) < labelCollisionThreshold.toPx()) { hasCollision = true; break }
            }
            if (!hasCollision) { finalLabels.add(label) }
        }

        records.forEachIndexed { index, _ ->
            val x = if (records.size == 1) xStep else index * xStep
            val y = size.height - ((yValues[index] - yMin) / yRangeValue * size.height)
            if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)
            if (records.size == 1) drawCircle(color, radius = 8f, center = Offset(x, y))
        }
        if (records.size > 1) drawPath(path = path, color = color, style = Stroke(width = 4f))

        finalLabels.forEach { label ->
            // [æ ¸å¿ƒä¿®å¤] 2. è¾¹ç•Œæ„ŸçŸ¥å’ŒåŠ¨æ€å¯¹é½
            val paint = when {
                label.x < 20.dp.toPx() -> leftTextPaint // é è¿‘å·¦è¾¹ç•Œï¼Œå·¦å¯¹é½
                label.x > size.width - 20.dp.toPx() -> rightTextPaint // é è¿‘å³è¾¹ç•Œï¼Œå³å¯¹é½
                else -> centerTextPaint // å…¶ä»–æƒ…å†µå±…ä¸­
            }
            // [æ ¸å¿ƒä¿®å¤] 3. å¢å¼ºå‚ç›´é¿è®©
            val yOffset = when {
                label.y < 20f -> 30f // ç¦»é¡¶éƒ¨å¤ªè¿‘ï¼Œå‘ä¸‹ç¿»è½¬
                label.y > size.height - 20f -> -30f // ç¦»åº•éƒ¨å¤ªè¿‘ï¼Œå‘ä¸Šç¿»è½¬
                else -> -15f // é»˜è®¤åœ¨ä¸Šæ–¹
            }
            drawIntoCanvas {
                it.nativeCanvas.drawText(label.text, label.x, label.y + yOffset, paint)
            }
        }
    }
}

@Composable
fun MultiLineChart(
    modifier: Modifier = Modifier,
    records: List<MetricsRecord>,
    valueExtractor: (MetricsRecord) -> List<Float>,
    range: ClosedFloatingPointRange<Float>
) {
    val yAxisPaint = rememberTextPaint(color = MaterialTheme.colorScheme.onSurfaceVariant, spSize = 10f, align = Paint.Align.RIGHT)
    Canvas(modifier = modifier.fillMaxWidth().height(150.dp).padding(start = 32.dp)) {
        drawChartScaffold(yRange = range, yAxisPaint = yAxisPaint)
        if (records.isEmpty()) return@Canvas
        val coreCount = records.first().perCoreCpuUsagePercent.size
        if (coreCount == 0) return@Canvas
        val xStep = if (records.size > 1) size.width / (records.size - 1) else size.width / 2
        for (coreIndex in 0 until coreCount) {
            val path = Path()
            val color = ChartColors.getOrElse(coreIndex) { Color.Gray }
            records.forEachIndexed { recordIndex, record ->
                val x = if (records.size == 1) xStep else recordIndex * xStep
                val yValue = record.perCoreCpuUsagePercent.getOrElse(coreIndex) { 0f }
                val y = size.height - ((yValue - range.start) / (range.endInclusive - range.start) * size.height)
                if (recordIndex == 0) path.moveTo(x, y) else path.lineTo(x, y)
                if (records.size == 1) drawCircle(color, radius = 8f, center = Offset(x, y))
            }
            if (records.size > 1) drawPath(path = path, color = color, style = Stroke(width = 4f))
        }
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsViewModel.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/stats/StatisticsViewModel.kt
package com.crfzit.crfzit.ui.stats

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.crfzit.crfzit.data.model.MetricsRecord
import com.crfzit.crfzit.data.repository.DaemonRepository
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

data class StatisticsUiState(
    val isLoading: Boolean = true,
    val records: List<MetricsRecord> = emptyList()
)

class StatisticsViewModel : ViewModel() {
    private val daemonRepository = DaemonRepository.getInstance()
    private val _uiState = MutableStateFlow(StatisticsUiState())
    val uiState: StateFlow<StatisticsUiState> = _uiState.asStateFlow()

    // [æ ¸å¿ƒä¿®æ”¹] 1. å®šä¹‰ä¸€ä¸ª27ç§’çš„æ—¶é—´çª—å£ï¼ˆå•ä½ï¼šæ¯«ç§’ï¼‰
    private val timeWindowMs = 27_000L

    init {
        loadInitialStats()
        listenForNewStats()
    }

    private fun loadInitialStats() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val history = daemonRepository.getHistoryStats() ?: emptyList()

            // [æ ¸å¿ƒä¿®æ”¹] 2. å¯¹åˆå§‹åŠ è½½çš„æ•°æ®ä¹Ÿåº”ç”¨æ—¶é—´çª—å£
            val filteredHistory = if (history.isNotEmpty()) {
                val latestTimestamp = history.last().timestamp
                history.filter { record ->
                    latestTimestamp - record.timestamp <= timeWindowMs
                }
            } else {
                emptyList()
            }

            _uiState.update { it.copy(isLoading = false, records = filteredHistory) }
        }
    }

    private fun listenForNewStats() {
        viewModelScope.launch {
            daemonRepository.getStatsStream().collect { newRecord ->
                _uiState.update { currentState ->
                    // [æ ¸å¿ƒä¿®æ”¹] 3. å®æ—¶ç»´æŠ¤ä¸€ä¸ªæ»šåŠ¨çš„æ—¶é—´çª—å£

                    // å°†æ–°è®°å½•æ·»åŠ åˆ°å½“å‰åˆ—è¡¨
                    val combinedList = currentState.records + newRecord

                    // è·å–æœ€æ–°è®°å½•çš„æ—¶é—´æˆ³ä½œä¸ºåŸºå‡†
                    val latestTimestamp = newRecord.timestamp

                    // è¿‡æ»¤æ‰æ‰€æœ‰ä¸åœ¨27ç§’æ—¶é—´çª—å£å†…çš„æ•°æ®
                    val windowedList = combinedList.filter { record ->
                        latestTimestamp - record.timestamp <= timeWindowMs
                    }

                    currentState.copy(records = windowedList)
                }
            }
        }
    }

    // ViewModelçš„ onCleared æ–¹æ³•ä¿æŒä¸å˜ï¼Œæ— éœ€ä¿®æ”¹
    override fun onCleared() {
        super.onCleared()
    }
}
```

app/src/main/java/com/crfzit/crfzit/ui/theme/Color.kt
```
package com.crfzit.crfzit.ui.theme // ç¡®ä¿åŒ…åæ­£ç¡®

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)
```

app/src/main/java/com/crfzit/crfzit/ui/theme/Theme.kt
```
// app/src/main/java/com/crfzit/crfzit/ui/theme
package com.crfzit.crfzit.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40
)

@Composable
fun CRFzitTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            // ã€å…¨é¢å±é€‚é…ã€‘å°†çŠ¶æ€æ è®¾ç½®ä¸ºé€æ˜ï¼Œè®©Scaffoldæ¥æ§åˆ¶é¢œè‰²
            window.statusBarColor = Color.Transparent.toArgb()
            // ã€å…¨é¢å±é€‚é…ã€‘è®¾ç½®å¯¼èˆªæ é¢œè‰²ä¸ºé€æ˜ï¼Œå¹¶ç¡®ä¿å†…å®¹å’Œå¯¼èˆªæ å›¾æ ‡é¢œè‰²å¯¹æ¯”åº¦
            window.navigationBarColor = Color.Transparent.toArgb()
            // è®¾ç½®çŠ¶æ€æ å›¾æ ‡é¢œè‰²
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
            // è®¾ç½®å¯¼èˆªæ å›¾æ ‡é¢œè‰²
            WindowCompat.getInsetsController(window, view).isAppearanceLightNavigationBars = !darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
```

app/src/main/java/com/crfzit/crfzit/ui/theme/Type.kt
```
package com.crfzit.crfzit.ui.theme // ç¡®ä¿åŒ…åæ­£ç¡®

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
)
```



settings.gradle.kts

// D:/project/Cerberus/settings.gradle.kts

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}

// æ ¸å¿ƒï¼šè¿™é‡Œæ˜¯å”¯ä¸€ä¸”åˆå¹¶åçš„ dependencyResolutionManagement å—
dependencyResolutionManagement {
    // ä»“åº“ç®¡ç†æ¨¡å¼è®¾ç½®ï¼Œä¿æŒä¸å˜
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)

    // ğŸ‡¨ğŸ‡³ æŠŠæ‰€æœ‰ä»“åº“éƒ½æ”¾åœ¨è¿™ä¸€ä¸ª repositories å—é‡Œ
    repositories {
        google()
        mavenCentral()
        // ğŸ‡¨ğŸ‡³ æŠŠ Xposed çš„ä»“åº“ä¹ŸåŠ åˆ°è¿™é‡Œ
        maven { url = uri("https://api.xposed.info/") }
    }
}

rootProject.name = "CRFzit" // æ‚¨å¯ä»¥ä¿®æ”¹ä¸º "Cerberus"
include(":app")